diff -urN linux-4.9-01/arch/arm/boot/dts/bcm2837.dtsi linux-4.9-02/arch/arm/boot/dts/bcm2837.dtsi
--- linux-4.9-01/arch/arm/boot/dts/bcm2837.dtsi	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.9-02/arch/arm/boot/dts/bcm2837.dtsi	2017-01-21 11:59:15.908231787 +0000
@@ -0,0 +1,76 @@
+#include "bcm283x.dtsi"
+
+/ {
+	compatible = "brcm,bcm2837";
+
+	soc {
+		ranges = <0x7e000000 0x3f000000 0x1000000>,
+			 <0x40000000 0x40000000 0x00001000>;
+		dma-ranges = <0xc0000000 0x00000000 0x3f000000>;
+
+		local_intc: local_intc {
+			compatible = "brcm,bcm2836-l1-intc";
+			reg = <0x40000000 0x100>;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+			interrupt-parent = <&local_intc>;
+		};
+	};
+
+	timer {
+		compatible = "arm,armv7-timer";
+		interrupt-parent = <&local_intc>;
+		interrupts = <0>, // PHYS_SECURE_PPI
+			     <1>, // PHYS_NONSECURE_PPI
+			     <3>, // VIRT_PPI
+			     <2>; // HYP_PPI
+		always-on;
+	};
+
+	cpus: cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a53";
+			reg = <0>;
+			enable-method = "spin-table";
+			cpu-release-addr = <0x0 0x000000d8>;
+		};
+
+		cpu1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a53";
+			reg = <1>;
+			enable-method = "spin-table";
+			cpu-release-addr = <0x0 0x000000e0>;
+		};
+
+		cpu2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a53";
+			reg = <2>;
+			enable-method = "spin-table";
+			cpu-release-addr = <0x0 0x000000e8>;
+		};
+
+		cpu3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a53";
+			reg = <3>;
+			enable-method = "spin-table";
+			cpu-release-addr = <0x0 0x000000f0>;
+		};
+	};
+};
+
+/* Make the BCM2835-style global interrupt controller be a child of the
+ * CPU-local interrupt controller.
+ */
+&intc {
+	compatible = "brcm,bcm2836-armctrl-ic";
+	reg = <0x7e00b200 0x200>;
+	interrupt-parent = <&local_intc>;
+	interrupts = <8>;
+};
diff -urN linux-4.9-01/arch/arm/boot/dts/bcm2837-rpi-3-b.dts linux-4.9-02/arch/arm/boot/dts/bcm2837-rpi-3-b.dts
--- linux-4.9-01/arch/arm/boot/dts/bcm2837-rpi-3-b.dts	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.9-02/arch/arm/boot/dts/bcm2837-rpi-3-b.dts	2017-01-21 11:59:15.908231787 +0000
@@ -0,0 +1,24 @@
+/dts-v1/;
+#include "bcm2837.dtsi"
+#include "bcm2835-rpi.dtsi"
+#include "bcm283x-rpi-smsc9514.dtsi"
+#include "bcm283x-rpi-usb-host.dtsi"
+
+/ {
+	compatible = "raspberrypi,3-model-b", "brcm,bcm2837";
+	model = "Raspberry Pi 3 Model B";
+
+	memory {
+		reg = <0 0x40000000>;
+	};
+
+	leds {
+		act {
+			gpios = <&gpio 47 0>;
+		};
+	};
+};
+
+&uart1 {
+	status = "okay";
+};
diff -urN linux-4.9-01/arch/arm/boot/dts/imx6sx-udoo-neo-basic.dts linux-4.9-02/arch/arm/boot/dts/imx6sx-udoo-neo-basic.dts
--- linux-4.9-01/arch/arm/boot/dts/imx6sx-udoo-neo-basic.dts	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.9-02/arch/arm/boot/dts/imx6sx-udoo-neo-basic.dts	2017-01-21 11:59:17.351190389 +0000
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2016 Andreas Färber
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/dts-v1/;
+
+#include "imx6sx-udoo-neo.dtsi"
+
+/ {
+	model = "UDOO Neo Basic";
+	compatible = "udoo,neobasic", "fsl,imx6sx";
+
+	memory {
+		reg = <0x80000000 0x20000000>;
+	};
+};
+
+&fec1 {
+	phy-handle = <&ethphy1>;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy1: ethernet-phy@0 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <0>;
+		};
+	};
+};
diff -urN linux-4.9-01/arch/arm/boot/dts/imx6sx-udoo-neo.dtsi linux-4.9-02/arch/arm/boot/dts/imx6sx-udoo-neo.dtsi
--- linux-4.9-01/arch/arm/boot/dts/imx6sx-udoo-neo.dtsi	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.9-02/arch/arm/boot/dts/imx6sx-udoo-neo.dtsi	2017-01-21 11:59:17.351190389 +0000
@@ -0,0 +1,293 @@
+/*
+ * Copyright (c) 2016 Andreas Färber
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "imx6sx.dtsi"
+
+/ {
+	compatible = "fsl,imx6sx";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		red {
+			label = "udoo-neo:red:mmc";
+			gpios = <&gpio6 0 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+			linux,default-trigger = "mmc0";
+		};
+
+		orange {
+			label = "udoo-neo:orange:user";
+			gpios = <&gpio4 6 GPIO_ACTIVE_HIGH>;
+			default-state = "keep";
+		};
+	};
+
+	reg_sdio_pwr: regulator-sdio-pwr {
+		compatible = "regulator-fixed";
+		gpio = <&gpio6 1 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-name = "SDIO_PWR";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-boot-on;
+	};
+};
+
+&cpu0 {
+	arm-supply = <&sw1a_reg>;
+	soc-supply = <&sw1c_reg>;
+};
+
+&fec1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet1>;
+	phy-mode = "rmii";
+	phy-reset-gpios = <&gpio2 1 GPIO_ACTIVE_LOW>;
+};
+
+&i2c1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	clock-frequency = <100000>;
+	status = "okay";
+
+	pmic: pmic@08 {
+		compatible = "fsl,pfuze3000";
+		reg = <0x08>;
+
+		regulators {
+			sw1a_reg: sw1a {
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1475000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw1c_reg: sw1b {
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1475000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <1850000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3a_reg: sw3 {
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <1650000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
+			};
+
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vref_reg: vrefddr {
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vgen1_reg: vldo1 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen2_reg: vldo2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen3_reg: vccsd {
+				regulator-min-microvolt = <2850000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen4_reg: v33 {
+				regulator-min-microvolt = <2850000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen5_reg: vldo3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen6_reg: vldo4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
+&iomuxc {
+	pinctrl_enet1: enet1grp {
+		fsl,pins =
+			<MX6SX_PAD_ENET1_CRS__GPIO2_IO_1	0xa0b1>,
+			<MX6SX_PAD_ENET1_MDC__ENET1_MDC		0xa0b1>,
+			<MX6SX_PAD_ENET1_MDIO__ENET1_MDIO	0xa0b1>,
+			<MX6SX_PAD_RGMII1_TD0__ENET1_TX_DATA_0	0xa0b1>,
+			<MX6SX_PAD_RGMII1_TD1__ENET1_TX_DATA_1	0xa0b1>,
+			<MX6SX_PAD_RGMII1_TX_CTL__ENET1_TX_EN	0xa0b1>,
+
+			<MX6SX_PAD_ENET1_TX_CLK__ENET1_REF_CLK1	0x3081>,
+			<MX6SX_PAD_ENET2_TX_CLK__GPIO2_IO_9	0x3081>,
+			<MX6SX_PAD_RGMII1_RD0__ENET1_RX_DATA_0	0x3081>,
+			<MX6SX_PAD_RGMII1_RD1__ENET1_RX_DATA_1	0x3081>,
+			<MX6SX_PAD_RGMII1_RX_CTL__ENET1_RX_EN	0x3081>,
+			<MX6SX_PAD_RGMII1_RXC__ENET1_RX_ER	0x3081>,
+
+			<MX6SX_PAD_ENET2_RX_CLK__ENET2_REF_CLK_25M	0x91>;
+	};
+
+	pinctrl_i2c1: i2c1grp {
+		fsl,pins =
+			<MX6SX_PAD_GPIO1_IO00__I2C1_SCL		0x4001b8b1>,
+			<MX6SX_PAD_GPIO1_IO01__I2C1_SDA		0x4001b8b1>;
+	};
+
+	pinctrl_uart1: uart1grp {
+		fsl,pins =
+			<MX6SX_PAD_GPIO1_IO04__UART1_TX		0x1b0b1>,
+			<MX6SX_PAD_GPIO1_IO05__UART1_RX		0x1b0b1>;
+	};
+
+	pinctrl_uart2: uart2grp {
+		fsl,pins =
+			<MX6SX_PAD_GPIO1_IO06__UART2_TX		0x1b0b1>,
+			<MX6SX_PAD_GPIO1_IO07__UART2_RX		0x1b0b1>;
+	};
+
+	pinctrl_uart5: uart5grp {
+		fsl,pins =
+			<MX6SX_PAD_SD4_DATA4__UART5_RX		0x1b0b1>,
+			<MX6SX_PAD_SD4_DATA5__UART5_TX		0x1b0b1>;
+	};
+
+	pinctrl_uart6: uart6grp {
+		fsl,pins =
+			<MX6SX_PAD_CSI_DATA00__UART6_RI_B	0x1b0b1>,
+			<MX6SX_PAD_CSI_DATA01__UART6_DSR_B	0x1b0b1>,
+			<MX6SX_PAD_CSI_DATA02__UART6_DTR_B	0x1b0b1>,
+			<MX6SX_PAD_CSI_DATA03__UART6_DCD_B	0x1b0b1>,
+			<MX6SX_PAD_CSI_DATA04__UART6_RX		0x1b0b1>,
+			<MX6SX_PAD_CSI_DATA05__UART6_TX		0x1b0b1>,
+			<MX6SX_PAD_CSI_DATA06__UART6_RTS_B	0x1b0b1>,
+			<MX6SX_PAD_CSI_DATA07__UART6_CTS_B	0x1b0b1>;
+	};
+
+	pinctrl_usdhc2: usdhc2grp {
+		fsl,pins =
+			<MX6SX_PAD_SD2_CMD__USDHC2_CMD		0x17059>,
+			<MX6SX_PAD_SD2_CLK__USDHC2_CLK		0x10059>,
+			<MX6SX_PAD_SD2_DATA0__USDHC2_DATA0	0x17059>,
+			<MX6SX_PAD_SD2_DATA1__USDHC2_DATA1	0x17059>,
+			<MX6SX_PAD_SD2_DATA2__USDHC2_DATA2	0x17059>,
+			<MX6SX_PAD_SD2_DATA3__USDHC2_DATA3	0x17059>,
+			<MX6SX_PAD_SD1_DATA0__GPIO6_IO_2	0x17059>; /* CD */
+	};
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	status = "okay";
+};
+
+/* Cortex-M4 serial */
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "disabled";
+};
+
+/* Arduino serial */
+&uart5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart5>;
+	status = "disabled";
+};
+
+&uart6 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart6>;
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2>;
+	vmmc-supply = <&reg_sdio_pwr>;
+	bus-width = <4>;
+	cd-gpios = <&gpio6 2 GPIO_ACTIVE_LOW>;
+	no-1-8-v;
+	keep-power-in-suspend;
+	wakeup-source;
+	status = "okay";
+};
diff -urN linux-4.9-01/arch/arm/boot/dts/imx6sx-udoo-neo-extended.dts linux-4.9-02/arch/arm/boot/dts/imx6sx-udoo-neo-extended.dts
--- linux-4.9-01/arch/arm/boot/dts/imx6sx-udoo-neo-extended.dts	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.9-02/arch/arm/boot/dts/imx6sx-udoo-neo-extended.dts	2017-01-21 11:59:17.351190389 +0000
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2016 Andreas Färber
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/dts-v1/;
+
+#include "imx6sx-udoo-neo.dtsi"
+
+/ {
+	model = "UDOO Neo Extended";
+	compatible = "udoo,neoextended", "fsl,imx6sx";
+
+	memory {
+		reg = <0x80000000 0x40000000>;
+	};
+};
diff -urN linux-4.9-01/arch/arm/boot/dts/imx6sx-udoo-neo-full.dts linux-4.9-02/arch/arm/boot/dts/imx6sx-udoo-neo-full.dts
--- linux-4.9-01/arch/arm/boot/dts/imx6sx-udoo-neo-full.dts	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.9-02/arch/arm/boot/dts/imx6sx-udoo-neo-full.dts	2017-01-21 11:59:17.351190389 +0000
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2016 Andreas Färber
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/dts-v1/;
+
+#include "imx6sx-udoo-neo.dtsi"
+
+/ {
+	model = "UDOO Neo Full";
+	compatible = "udoo,neofull", "fsl,imx6sx";
+
+	memory {
+		reg = <0x80000000 0x40000000>;
+	};
+};
+
+&fec1 {
+	phy-handle = <&ethphy1>;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy1: ethernet-phy@0 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <0>;
+		};
+	};
+};
diff -urN linux-4.9-01/arch/arm/boot/dts/Makefile linux-4.9-02/arch/arm/boot/dts/Makefile
--- linux-4.9-01/arch/arm/boot/dts/Makefile	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/arm/boot/dts/Makefile	2017-01-21 11:59:17.350190417 +0000
@@ -70,7 +70,8 @@
 	bcm2835-rpi-b-plus.dtb \
 	bcm2835-rpi-a-plus.dtb \
 	bcm2836-rpi-2-b.dtb \
-	bcm2835-rpi-zero.dtb
+	bcm2835-rpi-zero.dtb \
+	bcm2837-rpi-3-b.dtb
 dtb-$(CONFIG_ARCH_BCM_5301X) += \
 	bcm4708-asus-rt-ac56u.dtb \
 	bcm4708-asus-rt-ac68u.dtb \
@@ -416,7 +417,10 @@
 	imx6sx-sabreauto.dtb \
 	imx6sx-sdb-reva.dtb \
 	imx6sx-sdb-sai.dtb \
-	imx6sx-sdb.dtb
+	imx6sx-sdb.dtb \
+	imx6sx-udoo-neo-basic.dtb \
+	imx6sx-udoo-neo-extended.dtb \
+	imx6sx-udoo-neo-full.dtb
 dtb-$(CONFIG_SOC_IMX6UL) += \
 	imx6ul-14x14-evk.dtb \
 	imx6ul-geam-kit.dtb \
diff -urN linux-4.9-01/arch/arm/boot/dts/sun8i-h3.dtsi linux-4.9-02/arch/arm/boot/dts/sun8i-h3.dtsi
--- linux-4.9-01/arch/arm/boot/dts/sun8i-h3.dtsi	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/arm/boot/dts/sun8i-h3.dtsi	2017-01-21 11:59:17.304191739 +0000
@@ -140,6 +140,11 @@
 		#size-cells = <1>;
 		ranges;
 
+		syscon: syscon@01c00000 {
+			compatible = "syscon";
+			reg = <0x01c00000 0x1000>;
+		};
+
 		dma: dma-controller@01c02000 {
 			compatible = "allwinner,sun8i-h3-dma";
 			reg = <0x01c02000 0x1000>;
@@ -530,6 +535,30 @@
 			#size-cells = <0>;
 		};
 
+		emac: ethernet@1c30000 {
+			compatible = "allwinner,sun8i-h3-emac";
+			syscon = <&syscon>;
+			reg = <0x01c30000 0x104>;
+			interrupts = <GIC_SPI 82 IRQ_TYPE_LEVEL_HIGH>;
+			resets = <&ccu RST_BUS_EMAC>;
+			reset-names = "ahb";
+			clocks = <&ccu CLK_BUS_EMAC>;
+			clock-names = "ahb";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			mdio: mdio {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				int_mii_phy: ethernet-phy@1 {
+					reg = <1>;
+					clocks = <&ccu CLK_BUS_EPHY>;
+					resets = <&ccu RST_BUS_EPHY>;
+				};
+			};
+		};
+
 		gic: interrupt-controller@01c81000 {
 			compatible = "arm,cortex-a7-gic", "arm,cortex-a15-gic";
 			reg = <0x01c81000 0x1000>,
diff -urN linux-4.9-01/arch/arm/boot/dts/sun8i-h3-orangepi-2.dts linux-4.9-02/arch/arm/boot/dts/sun8i-h3-orangepi-2.dts
--- linux-4.9-01/arch/arm/boot/dts/sun8i-h3-orangepi-2.dts	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/arm/boot/dts/sun8i-h3-orangepi-2.dts	2017-01-21 11:59:17.305191710 +0000
@@ -54,6 +54,7 @@
 
 	aliases {
 		serial0 = &uart0;
+		ethernet0 = &emac;
 		/* ethernet0 is the H3 emac, defined in sun8i-h3.dtsi */
 		ethernet1 = &rtl8189;
 	};
@@ -212,3 +213,10 @@
 	usb1_vbus-supply = <&reg_usb1_vbus>;
 	status = "okay";
 };
+
+&emac {
+	phy-handle = <&int_mii_phy>;
+	phy-mode = "mii";
+	allwinner,leds-active-low;
+	status = "okay";
+};
diff -urN linux-4.9-01/arch/arm/boot/dts/sun8i-h3-orangepi-one.dts linux-4.9-02/arch/arm/boot/dts/sun8i-h3-orangepi-one.dts
--- linux-4.9-01/arch/arm/boot/dts/sun8i-h3-orangepi-one.dts	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/arm/boot/dts/sun8i-h3-orangepi-one.dts	2017-01-21 11:59:17.305191710 +0000
@@ -54,6 +54,7 @@
 
 	aliases {
 		serial0 = &uart0;
+		ethernet0 = &emac;
 	};
 
 	chosen {
@@ -94,6 +95,13 @@
 	status = "okay";
 };
 
+&emac {
+	phy-handle = <&int_mii_phy>;
+	phy-mode = "mii";
+	allwinner,leds-active-low;
+	status = "okay";
+};
+
 &mmc0 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&mmc0_pins_a>, <&mmc0_cd_pin>;
diff -urN linux-4.9-01/arch/arm/boot/dts/sun8i-h3-orangepi-pc.dts linux-4.9-02/arch/arm/boot/dts/sun8i-h3-orangepi-pc.dts
--- linux-4.9-01/arch/arm/boot/dts/sun8i-h3-orangepi-pc.dts	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/arm/boot/dts/sun8i-h3-orangepi-pc.dts	2017-01-21 11:59:17.305191710 +0000
@@ -54,6 +54,7 @@
 
 	aliases {
 		serial0 = &uart0;
+		ethernet0 = &emac;
 	};
 
 	chosen {
@@ -183,3 +184,10 @@
 	/* USB VBUS is always on */
 	status = "okay";
 };
+
+&emac {
+	phy-handle = <&int_mii_phy>;
+	phy-mode = "mii";
+	allwinner,leds-active-low;
+	status = "okay";
+};
diff -urN linux-4.9-01/arch/arm/include/asm/crash-driver.h linux-4.9-02/arch/arm/include/asm/crash-driver.h
--- linux-4.9-01/arch/arm/include/asm/crash-driver.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.9-02/arch/arm/include/asm/crash-driver.h	2017-01-21 11:59:17.825176785 +0000
@@ -0,0 +1,6 @@
+#ifndef _ARM_CRASH_H
+#define _ARM_CRASH_H
+
+#include <asm-generic/crash-driver.h>
+
+#endif /* _ARM_CRASH_H */
diff -urN linux-4.9-01/arch/arm/Kconfig linux-4.9-02/arch/arm/Kconfig
--- linux-4.9-01/arch/arm/Kconfig	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/arm/Kconfig	2017-01-21 11:59:17.333190906 +0000
@@ -1496,8 +1496,7 @@
 
 config HZ_FIXED
 	int
-	default 200 if ARCH_EBSA110 || ARCH_S3C24XX || \
-		ARCH_S5PV210 || ARCH_EXYNOS4
+	default 200 if ARCH_EBSA110
 	default 128 if SOC_AT91RM9200
 	default 0
 
diff -urN linux-4.9-01/arch/arm64/boot/dts/rockchip/Makefile linux-4.9-02/arch/arm64/boot/dts/rockchip/Makefile
--- linux-4.9-01/arch/arm64/boot/dts/rockchip/Makefile	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/arm64/boot/dts/rockchip/Makefile	2017-01-21 11:59:14.616268858 +0000
@@ -1,6 +1,7 @@
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3368-evb-act8846.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3368-geekbox.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3368-orion-r68-meta.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3368-geekbox-landingship.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3368-r88.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3399-evb.dtb
 
diff -urN linux-4.9-01/arch/arm64/boot/dts/rockchip/rk3368-evb.dtsi linux-4.9-02/arch/arm64/boot/dts/rockchip/rk3368-evb.dtsi
--- linux-4.9-01/arch/arm64/boot/dts/rockchip/rk3368-evb.dtsi	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/arm64/boot/dts/rockchip/rk3368-evb.dtsi	2017-01-21 11:59:14.616268858 +0000
@@ -49,7 +49,7 @@
 		stdout-path = "serial2:115200n8";
 	};
 
-	memory {
+	memory@0 {
 		device_type = "memory";
 		reg = <0x0 0x0 0x0 0x40000000>;
 	};
diff -urN linux-4.9-01/arch/arm64/boot/dts/rockchip/rk3368-geekbox-landingship.dts linux-4.9-02/arch/arm64/boot/dts/rockchip/rk3368-geekbox-landingship.dts
--- linux-4.9-01/arch/arm64/boot/dts/rockchip/rk3368-geekbox-landingship.dts	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.9-02/arch/arm64/boot/dts/rockchip/rk3368-geekbox-landingship.dts	2017-01-21 11:59:14.616268858 +0000
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2016 Andreas Färber
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "rk3368-geekbox.dts"
+
+/ {
+	model = "GeekBox on Landingship";
+	compatible = "geekbuying,geekbox-landingship",
+		     "geekbuying,geekbox", "rockchip,rk3368";
+};
+
+&i2c1 {
+	status = "disabled";
+};
+
+&i2c2 {
+	status = "okay";
+};
diff -urN linux-4.9-01/arch/arm64/boot/dts/rockchip/rk3368-r88.dts linux-4.9-02/arch/arm64/boot/dts/rockchip/rk3368-r88.dts
--- linux-4.9-01/arch/arm64/boot/dts/rockchip/rk3368-r88.dts	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/arm64/boot/dts/rockchip/rk3368-r88.dts	2017-01-21 11:59:14.616268858 +0000
@@ -52,7 +52,7 @@
 		stdout-path = "serial2:115200n8";
 	};
 
-	memory {
+	memory@0 {
 		device_type = "memory";
 		reg = <0x0 0x0 0x0 0x40000000>;
 	};
diff -urN linux-4.9-01/arch/arm64/include/asm/crash-driver.h linux-4.9-02/arch/arm64/include/asm/crash-driver.h
--- linux-4.9-01/arch/arm64/include/asm/crash-driver.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.9-02/arch/arm64/include/asm/crash-driver.h	2017-01-21 11:59:17.848176125 +0000
@@ -0,0 +1,22 @@
+#ifndef _ARM64_CRASH_H
+#define _ARM64_CRASH_H
+
+#include <asm-generic/crash-driver.h>
+
+#define DEV_CRASH_ARCH_DATA _IOR('c', 1, long)
+
+static long
+crash_arch_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	extern u64 kimage_voffset;
+
+	switch (cmd)
+	{
+	case DEV_CRASH_ARCH_DATA:
+		return put_user(kimage_voffset, (unsigned long __user *)arg);
+	default:
+		return -EINVAL;
+	}
+}
+
+#endif /* _ARM64_CRASH_H */
diff -urN linux-4.9-01/arch/arm64/kernel/cpuinfo.c linux-4.9-02/arch/arm64/kernel/cpuinfo.c
--- linux-4.9-01/arch/arm64/kernel/cpuinfo.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/arm64/kernel/cpuinfo.c	2017-01-21 11:59:14.557270549 +0000
@@ -325,6 +325,8 @@
 
 static void __cpuinfo_store_cpu(struct cpuinfo_arm64 *info)
 {
+	bool qdf2432_cpu = read_cpuid_id() == 0x510f2811;
+
 	info->reg_cntfrq = arch_timer_get_cntfrq();
 	info->reg_ctr = read_cpuid_cachetype();
 	info->reg_dczid = read_cpuid(DCZID_EL0);
@@ -337,7 +339,7 @@
 	info->reg_id_aa64isar1 = read_cpuid(ID_AA64ISAR1_EL1);
 	info->reg_id_aa64mmfr0 = read_cpuid(ID_AA64MMFR0_EL1);
 	info->reg_id_aa64mmfr1 = read_cpuid(ID_AA64MMFR1_EL1);
-	info->reg_id_aa64mmfr2 = read_cpuid(ID_AA64MMFR2_EL1);
+	info->reg_id_aa64mmfr2 = qdf2432_cpu ? 0 : read_cpuid(ID_AA64MMFR2_EL1);
 	info->reg_id_aa64pfr0 = read_cpuid(ID_AA64PFR0_EL1);
 	info->reg_id_aa64pfr1 = read_cpuid(ID_AA64PFR1_EL1);
 
diff -urN linux-4.9-01/arch/arm64/kernel/pci.c linux-4.9-02/arch/arm64/kernel/pci.c
--- linux-4.9-01/arch/arm64/kernel/pci.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/arm64/kernel/pci.c	2017-01-21 11:59:14.758264783 +0000
@@ -125,24 +125,17 @@
 	u16 seg = root->segment;
 	struct pci_config_window *cfg;
 	struct resource cfgres;
-	unsigned int bsz;
+	struct pci_ecam_ops *ecam_ops;
+	int ret;
 
-	/* Use address from _CBA if present, otherwise lookup MCFG */
-	if (!root->mcfg_addr)
-		root->mcfg_addr = pci_mcfg_lookup(seg, bus_res);
-
-	if (!root->mcfg_addr) {
+	ret = pci_mcfg_lookup(root, &cfgres, &ecam_ops);
+	if (ret) {
 		dev_err(&root->device->dev, "%04x:%pR ECAM region not found\n",
 			seg, bus_res);
 		return NULL;
 	}
 
-	bsz = 1 << pci_generic_ecam_ops.bus_shift;
-	cfgres.start = root->mcfg_addr + bus_res->start * bsz;
-	cfgres.end = cfgres.start + resource_size(bus_res) * bsz - 1;
-	cfgres.flags = IORESOURCE_MEM;
-	cfg = pci_ecam_create(&root->device->dev, &cfgres, bus_res,
-			      &pci_generic_ecam_ops);
+	cfg = pci_ecam_create(&root->device->dev, &cfgres, bus_res, ecam_ops);
 	if (IS_ERR(cfg)) {
 		dev_err(&root->device->dev, "%04x:%pR error %ld mapping ECAM\n",
 			seg, bus_res, PTR_ERR(cfg));
diff -urN linux-4.9-01/arch/arm64/mm/init.c linux-4.9-02/arch/arm64/mm/init.c
--- linux-4.9-01/arch/arm64/mm/init.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/arm64/mm/init.c	2017-01-21 11:59:15.648239255 +0000
@@ -147,7 +147,7 @@
 #ifdef CONFIG_HAVE_ARCH_PFN_VALID
 int pfn_valid(unsigned long pfn)
 {
-	return memblock_is_map_memory(pfn << PAGE_SHIFT);
+	return memblock_is_memory(pfn << PAGE_SHIFT);
 }
 EXPORT_SYMBOL(pfn_valid);
 #endif
diff -urN linux-4.9-01/arch/arm64/mm/ioremap.c linux-4.9-02/arch/arm64/mm/ioremap.c
--- linux-4.9-01/arch/arm64/mm/ioremap.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/arm64/mm/ioremap.c	2017-01-21 11:59:15.648239255 +0000
@@ -21,6 +21,7 @@
  */
 
 #include <linux/export.h>
+#include <linux/memblock.h>
 #include <linux/mm.h>
 #include <linux/vmalloc.h>
 #include <linux/io.h>
@@ -55,7 +56,7 @@
 	/*
 	 * Don't allow RAM to be mapped.
 	 */
-	if (WARN_ON(pfn_valid(__phys_to_pfn(phys_addr))))
+	if (WARN_ON(memblock_is_map_memory(phys_addr)))
 		return NULL;
 
 	area = get_vm_area_caller(size, VM_IOREMAP, caller);
@@ -96,7 +97,7 @@
 void __iomem *ioremap_cache(phys_addr_t phys_addr, size_t size)
 {
 	/* For normal memory we already have a cacheable mapping. */
-	if (pfn_valid(__phys_to_pfn(phys_addr)))
+	if (memblock_is_map_memory(phys_addr))
 		return (void __iomem *)__phys_to_virt(phys_addr);
 
 	return __ioremap_caller(phys_addr, size, __pgprot(PROT_NORMAL),
diff -urN linux-4.9-01/arch/ia64/include/asm/crash-driver.h linux-4.9-02/arch/ia64/include/asm/crash-driver.h
--- linux-4.9-01/arch/ia64/include/asm/crash-driver.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.9-02/arch/ia64/include/asm/crash-driver.h	2017-01-21 11:59:17.825176785 +0000
@@ -0,0 +1,90 @@
+#ifndef _ASM_IA64_CRASH_H
+#define _ASM_IA64_CRASH_H
+
+/*
+ * linux/include/asm-ia64/crash-driver.h
+ *
+ * Copyright (c) 2004 Red Hat, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifdef __KERNEL__
+
+#include <linux/efi.h>
+#include <linux/mm.h>
+#include <asm/mmzone.h>
+
+static inline void *
+map_virtual(u64 offset, struct page **pp)
+{
+	struct page *page;
+	unsigned long pfn;
+	u32 type;
+
+	if (REGION_NUMBER(offset) == 5) {
+		char byte;
+
+		if (__get_user(byte, (char *)offset) == 0)
+			return (void *)offset;
+		else
+			return NULL;
+	}
+
+	switch (type = efi_mem_type(offset))
+	{
+	case EFI_LOADER_CODE:
+	case EFI_LOADER_DATA:
+	case EFI_BOOT_SERVICES_CODE:
+	case EFI_BOOT_SERVICES_DATA:
+	case EFI_CONVENTIONAL_MEMORY:
+		break;
+
+	default:
+		printk(KERN_INFO
+		    "crash memory driver: invalid memory type for %lx: %d\n",
+			offset, type);
+		return NULL;
+	}
+
+	pfn = offset >> PAGE_SHIFT;
+
+	if (!pfn_valid(pfn)) {
+		printk(KERN_INFO
+			"crash memory driver: invalid pfn: %lx )\n", pfn);
+		return NULL;
+	}
+
+	page = pfn_to_page(pfn);
+
+	if (!page->virtual) {
+		printk(KERN_INFO
+		    "crash memory driver: offset: %lx page: %lx page->virtual: NULL\n",
+			offset, (unsigned long)page);
+		return NULL;
+	}
+
+	return (page->virtual + (offset & (PAGE_SIZE-1)));
+}
+
+static inline void unmap_virtual(struct page *page)
+{
+	return;
+}
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_IA64_CRASH_H */
diff -urN linux-4.9-01/arch/ia64/kernel/ia64_ksyms.c linux-4.9-02/arch/ia64/kernel/ia64_ksyms.c
--- linux-4.9-01/arch/ia64/kernel/ia64_ksyms.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/ia64/kernel/ia64_ksyms.c	2017-01-21 11:59:17.826176757 +0000
@@ -9,3 +9,6 @@
 EXPORT_SYMBOL(min_low_pfn);	/* defined by bootmem.c, but not exported by generic code */
 EXPORT_SYMBOL(max_low_pfn);	/* defined by bootmem.c, but not exported by generic code */
 #endif
+
+#include <linux/efi.h>
+EXPORT_SYMBOL_GPL(efi_mem_type);
diff -urN linux-4.9-01/arch/powerpc/include/asm/crash-driver.h linux-4.9-02/arch/powerpc/include/asm/crash-driver.h
--- linux-4.9-01/arch/powerpc/include/asm/crash-driver.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.9-02/arch/powerpc/include/asm/crash-driver.h	2017-01-21 11:59:17.826176757 +0000
@@ -0,0 +1,6 @@
+#ifndef _PPC64_CRASH_H
+#define _PPC64_CRASH_H
+
+#include <asm-generic/crash-driver.h>
+
+#endif /* _PPC64_CRASH_H */
diff -urN linux-4.9-01/arch/s390/include/asm/crash-driver.h linux-4.9-02/arch/s390/include/asm/crash-driver.h
--- linux-4.9-01/arch/s390/include/asm/crash-driver.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.9-02/arch/s390/include/asm/crash-driver.h	2017-01-21 11:59:17.826176757 +0000
@@ -0,0 +1,60 @@
+#ifndef _S390_CRASH_H
+#define _S390_CRASH_H
+
+#ifdef __KERNEL__
+
+#include <linux/mm.h>
+#include <linux/highmem.h>
+
+/*
+ * For swapped prefix pages get bounce buffer using xlate_dev_mem_ptr()
+ */
+static inline void *map_virtual(u64 offset, struct page **pp)
+{
+	struct page *page;
+	unsigned long pfn;
+	void *vaddr;
+
+	vaddr = xlate_dev_mem_ptr(offset);
+	pfn = ((unsigned long) vaddr) >> PAGE_SHIFT;
+	if ((unsigned long) vaddr != offset)
+		page = pfn_to_page(pfn);
+	else
+		page = NULL;
+
+	if (!page_is_ram(pfn)) {
+		printk(KERN_INFO
+		    "crash memory driver: !page_is_ram(pfn: %lx)\n", pfn);
+		return NULL;
+	}
+
+	if (!pfn_valid(pfn)) {
+		printk(KERN_INFO
+		    "crash memory driver: invalid pfn: %lx )\n", pfn);
+		return NULL;
+	}
+
+	*pp = page;
+	return vaddr;
+}
+
+/*
+ * Free bounce buffer if necessary
+ */
+static inline void unmap_virtual(struct page *page)
+{
+	void *vaddr;
+
+	if (page) {
+		/*
+		 * Because for bounce buffers vaddr will never be 0
+		 * unxlate_dev_mem_ptr() will always free the bounce buffer.
+		 */
+		vaddr = (void *)(page_to_pfn(page) << PAGE_SHIFT);
+		unxlate_dev_mem_ptr(0, vaddr);
+	}
+}
+
+#endif /* __KERNEL__ */
+
+#endif /* _S390_CRASH_H */
diff -urN linux-4.9-01/arch/s390/mm/maccess.c linux-4.9-02/arch/s390/mm/maccess.c
--- linux-4.9-01/arch/s390/mm/maccess.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/s390/mm/maccess.c	2017-01-21 11:59:17.826176757 +0000
@@ -201,6 +201,7 @@
 	put_online_cpus();
 	return bounce;
 }
+EXPORT_SYMBOL_GPL(xlate_dev_mem_ptr);
 
 /*
  * Free converted buffer for /dev/mem access (if necessary)
@@ -210,3 +211,4 @@
 	if ((void *) addr != buf)
 		free_page((unsigned long) buf);
 }
+EXPORT_SYMBOL_GPL(unxlate_dev_mem_ptr);
diff -urN linux-4.9-01/arch/x86/boot/compressed/eboot.c linux-4.9-02/arch/x86/boot/compressed/eboot.c
--- linux-4.9-01/arch/x86/boot/compressed/eboot.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/x86/boot/compressed/eboot.c	2017-01-21 11:59:18.505157275 +0000
@@ -12,6 +12,7 @@
 #include <asm/efi.h>
 #include <asm/setup.h>
 #include <asm/desc.h>
+#include <asm/bootparam_utils.h>
 
 #include "../string.h"
 #include "eboot.h"
@@ -537,6 +538,85 @@
 	efi_call_early(free_pool, pci_handle);
 }
 
+static int get_secure_boot(void)
+{
+	u8 sb, setup, moksbstate;
+	unsigned long datasize = sizeof(sb);
+	u32 attr;
+	efi_guid_t var_guid = EFI_GLOBAL_VARIABLE_GUID;
+	efi_status_t status;
+
+	status = efi_early->call((unsigned long)sys_table->runtime->get_variable,
+				L"SecureBoot", &var_guid, NULL, &datasize, &sb);
+
+	if (status != EFI_SUCCESS)
+		return 0;
+
+	if (sb == 0)
+		return 0;
+
+
+	status = efi_early->call((unsigned long)sys_table->runtime->get_variable,
+				L"SetupMode", &var_guid, NULL, &datasize,
+				&setup);
+
+	if (status != EFI_SUCCESS)
+		return 0;
+
+	if (setup == 1)
+		return 0;
+
+	/* See if a user has put shim into insecure_mode.  If so, and the variable
+	 * doesn't have the runtime attribute set, we might as well honor that.
+	 */
+	var_guid = EFI_SHIM_LOCK_GUID;
+	status = efi_early->call((unsigned long)sys_table->runtime->get_variable,
+				L"MokSBState", &var_guid, &attr, &datasize,
+				&moksbstate);
+
+	/* If it fails, we don't care why.  Default to secure */
+	if (status != EFI_SUCCESS)
+		return 1;
+
+	if (!(attr & EFI_VARIABLE_RUNTIME_ACCESS)) {
+		if (moksbstate == 1)
+			return 0;
+	}
+
+	return 1;
+}
+
+
+/*
+ * See if we have Graphics Output Protocol
+ */
+static efi_status_t setup_gop(struct screen_info *si, efi_guid_t *proto,
+			      unsigned long size)
+{
+	efi_status_t status;
+	void **gop_handle = NULL;
+
+	status = efi_call_early(allocate_pool, EFI_LOADER_DATA,
+				size, (void **)&gop_handle);
+	if (status != EFI_SUCCESS)
+		return status;
+
+	status = efi_call_early(locate_handle,
+				EFI_LOCATE_BY_PROTOCOL,
+				proto, NULL, &size, gop_handle);
+	if (status != EFI_SUCCESS)
+		goto free_handle;
+
+	if (efi_early->is64)
+		status = setup_gop64(si, proto, size, gop_handle);
+	else
+		status = setup_gop32(si, proto, size, gop_handle);
+
+free_handle:
+	efi_call_early(free_pool, gop_handle);
+	return status;
+}
+
 static efi_status_t
 setup_uga32(void **uga_handle, unsigned long size, u32 *width, u32 *height)
 {
@@ -1094,6 +1174,10 @@
 	else
 		setup_boot_services32(efi_early);
 
+	sanitize_boot_params(boot_params);
+
+	boot_params->secure_boot = get_secure_boot();
+
 	setup_graphics(boot_params);
 
 	setup_efi_pci(boot_params);
diff -urN linux-4.9-01/arch/x86/include/asm/crash-driver.h linux-4.9-02/arch/x86/include/asm/crash-driver.h
--- linux-4.9-01/arch/x86/include/asm/crash-driver.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.9-02/arch/x86/include/asm/crash-driver.h	2017-01-21 11:59:17.826176757 +0000
@@ -0,0 +1,6 @@
+#ifndef _X86_CRASH_H
+#define _X86_CRASH_H
+
+#include <asm-generic/crash-driver.h>
+
+#endif /* _X86_CRASH_H */
diff -urN linux-4.9-01/arch/x86/include/uapi/asm/bootparam.h linux-4.9-02/arch/x86/include/uapi/asm/bootparam.h
--- linux-4.9-01/arch/x86/include/uapi/asm/bootparam.h	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/x86/include/uapi/asm/bootparam.h	2017-01-21 11:59:18.420159714 +0000
@@ -134,7 +134,8 @@
 	__u8  eddbuf_entries;				/* 0x1e9 */
 	__u8  edd_mbr_sig_buf_entries;			/* 0x1ea */
 	__u8  kbd_status;				/* 0x1eb */
-	__u8  _pad5[3];					/* 0x1ec */
+	__u8  secure_boot;				/* 0x1ec */
+	__u8  _pad5[2];					/* 0x1ed */
 	/*
 	 * The sentinel is set to a nonzero value (0xff) in header.S.
 	 *
diff -urN linux-4.9-01/arch/x86/Kconfig linux-4.9-02/arch/x86/Kconfig
--- linux-4.9-01/arch/x86/Kconfig	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/x86/Kconfig	2017-01-21 11:59:18.420159714 +0000
@@ -1786,6 +1786,17 @@
 
 	   If unsure, say N.
 
+config EFI_SECURE_BOOT_SIG_ENFORCE
+	def_bool n
+	depends on EFI
+	prompt "Force module signing when UEFI Secure Boot is enabled"
+	---help---
+	  UEFI Secure Boot provides a mechanism for ensuring that the
+	  firmware will only load signed bootloaders and kernels. Certain
+	  use cases may also require that all kernel modules also be signed.
+	  Say Y here to automatically enable module signature enforcement
+	  when a system boots with UEFI Secure Boot enabled.
+
 config SECCOMP
 	def_bool y
 	prompt "Enable seccomp to safely compute untrusted bytecode"
diff -urN linux-4.9-01/arch/x86/kernel/ioport.c linux-4.9-02/arch/x86/kernel/ioport.c
--- linux-4.9-01/arch/x86/kernel/ioport.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/x86/kernel/ioport.c	2017-01-21 11:59:18.125168178 +0000
@@ -15,6 +15,7 @@
 #include <linux/thread_info.h>
 #include <linux/syscalls.h>
 #include <linux/bitmap.h>
+#include <linux/module.h>
 #include <asm/syscalls.h>
 
 /*
@@ -28,7 +29,7 @@
 
 	if ((from + num <= from) || (from + num > IO_BITMAP_BITS))
 		return -EINVAL;
-	if (turn_on && !capable(CAP_SYS_RAWIO))
+	if (turn_on && (!capable(CAP_SYS_RAWIO) || secure_modules()))
 		return -EPERM;
 
 	/*
@@ -108,7 +109,7 @@
 		return -EINVAL;
 	/* Trying to gain more privileges? */
 	if (level > old) {
-		if (!capable(CAP_SYS_RAWIO))
+		if (!capable(CAP_SYS_RAWIO) || secure_modules())
 			return -EPERM;
 	}
 	regs->flags = (regs->flags & ~X86_EFLAGS_IOPL) |
diff -urN linux-4.9-01/arch/x86/kernel/kexec-bzimage64.c linux-4.9-02/arch/x86/kernel/kexec-bzimage64.c
--- linux-4.9-01/arch/x86/kernel/kexec-bzimage64.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/x86/kernel/kexec-bzimage64.c	2017-01-21 11:59:18.958144278 +0000
@@ -179,6 +179,7 @@
 	if (efi_enabled(EFI_OLD_MEMMAP))
 		return 0;
 
+	params->secure_boot = boot_params.secure_boot;
 	ei->efi_loader_signature = current_ei->efi_loader_signature;
 	ei->efi_systab = current_ei->efi_systab;
 	ei->efi_systab_hi = current_ei->efi_systab_hi;
diff -urN linux-4.9-01/arch/x86/kernel/msr.c linux-4.9-02/arch/x86/kernel/msr.c
--- linux-4.9-01/arch/x86/kernel/msr.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/x86/kernel/msr.c	2017-01-21 11:59:18.406160115 +0000
@@ -83,6 +83,9 @@
 	int err = 0;
 	ssize_t bytes = 0;
 
+	if (secure_modules())
+		return -EPERM;
+
 	if (count % 8)
 		return -EINVAL;	/* Invalid chunk size */
 
@@ -130,6 +133,10 @@
 			err = -EBADF;
 			break;
 		}
+		if (secure_modules()) {
+			err = -EPERM;
+			break;
+		}
 		if (copy_from_user(&regs, uregs, sizeof regs)) {
 			err = -EFAULT;
 			break;
diff -urN linux-4.9-01/arch/x86/kernel/setup.c linux-4.9-02/arch/x86/kernel/setup.c
--- linux-4.9-01/arch/x86/kernel/setup.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/arch/x86/kernel/setup.c	2017-01-21 11:59:18.696151795 +0000
@@ -70,6 +70,11 @@
 #include <linux/tboot.h>
 #include <linux/jiffies.h>
 
+#include <linux/fips.h>
+#include <linux/cred.h>
+#include <linux/sysrq.h>
+#include <linux/init_task.h>
+
 #include <video/edid.h>
 
 #include <asm/mtrr.h>
@@ -1160,6 +1165,14 @@
 
 	io_delay_init();
 
+#ifdef CONFIG_EFI_SECURE_BOOT_SIG_ENFORCE
+	if (boot_params.secure_boot) {
+		set_bit(EFI_SECURE_BOOT, &efi.flags);
+		enforce_signed_modules();
+		pr_info("Secure boot enabled\n");
+	}
+#endif
+
 	/*
 	 * Parse the ACPI tables for possible boot-time SMP configuration.
 	 */
@@ -1283,6 +1296,37 @@
 
 #endif /* CONFIG_X86_32 */
 
+#ifdef CONFIG_MAGIC_SYSRQ
+#ifdef CONFIG_MODULE_SIG
+extern bool sig_enforce;
+#endif
+
+static void sysrq_handle_secure_boot(int key)
+{
+	if (!efi_enabled(EFI_SECURE_BOOT))
+		return;
+
+	pr_info("Secure boot disabled\n");
+#ifdef CONFIG_MODULE_SIG
+	sig_enforce = fips_enabled;
+#endif
+}
+static struct sysrq_key_op secure_boot_sysrq_op = {
+	.handler	=	sysrq_handle_secure_boot,
+	.help_msg	=	"unSB(x)",
+	.action_msg	=	"Disabling Secure Boot restrictions",
+	.enable_mask	=	SYSRQ_DISABLE_USERSPACE,
+};
+static int __init secure_boot_sysrq(void)
+{
+	if (efi_enabled(EFI_SECURE_BOOT))
+		register_sysrq_key('x', &secure_boot_sysrq_op);
+	return 0;
+}
+late_initcall(secure_boot_sysrq);
+#endif /*CONFIG_MAGIC_SYSRQ*/
+
+
 static struct notifier_block kernel_offset_notifier = {
 	.notifier_call = dump_kernel_offset
 };
diff -urN linux-4.9-01/certs/system_keyring.c linux-4.9-02/certs/system_keyring.c
--- linux-4.9-01/certs/system_keyring.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/certs/system_keyring.c	2017-01-21 11:59:18.652153057 +0000
@@ -22,11 +22,27 @@
 #ifdef CONFIG_SECONDARY_TRUSTED_KEYRING
 static struct key *secondary_trusted_keys;
 #endif
+#ifdef CONFIG_SYSTEM_BLACKLIST_KEYRING
+struct key *system_blacklist_keyring;
+#endif
 
 extern __initconst const u8 system_certificate_list[];
 extern __initconst const unsigned long system_certificate_list_size;
 
 /**
+ * get_system_keyring - Return a pointer to the system keyring
+ *
+ */
+struct key *get_system_keyring(void)
+{
+	struct key *system_keyring = NULL;
+
+	system_keyring = builtin_trusted_keys;
+	return system_keyring;
+}
+EXPORT_SYMBOL_GPL(get_system_keyring);
+
+/**
  * restrict_link_to_builtin_trusted - Restrict keyring addition by built in CA
  *
  * Restrict the addition of keys into a keyring based on the key-to-be-added
@@ -99,6 +115,16 @@
 	if (key_link(secondary_trusted_keys, builtin_trusted_keys) < 0)
 		panic("Can't link trusted keyrings\n");
 #endif
+#ifdef CONFIG_SYSTEM_BLACKLIST_KEYRING
+	system_blacklist_keyring = keyring_alloc(".system_blacklist_keyring",
+			KUIDT_INIT(0), KGIDT_INIT(0), current_cred(),
+			((KEY_POS_ALL & ~KEY_POS_SETATTR) |
+			 KEY_USR_VIEW | KEY_USR_READ | KEY_USR_SEARCH),
+			KEY_ALLOC_NOT_IN_QUOTA,
+			NULL, NULL);
+	if (IS_ERR(system_blacklist_keyring))
+		panic("Can't allocate system blacklist keyring\n");
+#endif
 
 	return 0;
 }
@@ -214,6 +240,15 @@
 		trusted_keys = builtin_trusted_keys;
 #endif
 	}
+#ifdef CONFIG_SYSTEM_BLACKLIST_KEYRING
+	ret = pkcs7_validate_trust(pkcs7, system_blacklist_keyring);
+	if (!ret) {
+		/* module is signed with a cert in the blacklist.  reject */
+		pr_err("Module key is in the blacklist\n");
+		ret = -EKEYREJECTED;
+		goto error;
+	}
+#endif
 	ret = pkcs7_validate_trust(pkcs7, trusted_keys);
 	if (ret < 0) {
 		if (ret == -ENOKEY)
diff -urN linux-4.9-01/crypto/asymmetric_keys/efi_parser.c linux-4.9-02/crypto/asymmetric_keys/efi_parser.c
--- linux-4.9-01/crypto/asymmetric_keys/efi_parser.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.9-02/crypto/asymmetric_keys/efi_parser.c	2017-01-21 11:59:18.578155181 +0000
@@ -0,0 +1,108 @@
+/* EFI signature/key/certificate list parser
+ *
+ * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public Licence
+ * as published by the Free Software Foundation; either version
+ * 2 of the Licence, or (at your option) any later version.
+ */
+
+#define pr_fmt(fmt) "EFI: "fmt
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/err.h>
+#include <linux/efi.h>
+#include <keys/asymmetric-type.h>
+
+static __initdata efi_guid_t efi_cert_x509_guid = EFI_CERT_X509_GUID;
+
+/**
+ * parse_efi_signature_list - Parse an EFI signature list for certificates
+ * @data: The data blob to parse
+ * @size: The size of the data blob
+ * @keyring: The keyring to add extracted keys to
+ */
+int __init parse_efi_signature_list(const void *data, size_t size, struct key *keyring)
+{
+	unsigned offs = 0;
+	size_t lsize, esize, hsize, elsize;
+
+	pr_devel("-->%s(,%zu)\n", __func__, size);
+
+	while (size > 0) {
+		efi_signature_list_t list;
+		const efi_signature_data_t *elem;
+		key_ref_t key;
+
+		if (size < sizeof(list))
+			return -EBADMSG;
+
+		memcpy(&list, data, sizeof(list));
+		pr_devel("LIST[%04x] guid=%pUl ls=%x hs=%x ss=%x\n",
+			 offs,
+			 list.signature_type.b, list.signature_list_size,
+			 list.signature_header_size, list.signature_size);
+
+		lsize = list.signature_list_size;
+		hsize = list.signature_header_size;
+		esize = list.signature_size;
+		elsize = lsize - sizeof(list) - hsize;
+
+		if (lsize > size) {
+			pr_devel("<--%s() = -EBADMSG [overrun @%x]\n",
+				 __func__, offs);
+			return -EBADMSG;
+		}
+		if (lsize < sizeof(list) ||
+		    lsize - sizeof(list) < hsize ||
+		    esize < sizeof(*elem) ||
+		    elsize < esize ||
+		    elsize % esize != 0) {
+			pr_devel("- bad size combo @%x\n", offs);
+			return -EBADMSG;
+		}
+
+		if (efi_guidcmp(list.signature_type, efi_cert_x509_guid) != 0) {
+			data += lsize;
+			size -= lsize;
+			offs += lsize;
+			continue;
+		}
+
+		data += sizeof(list) + hsize;
+		size -= sizeof(list) + hsize;
+		offs += sizeof(list) + hsize;
+
+		for (; elsize > 0; elsize -= esize) {
+			elem = data;
+
+			pr_devel("ELEM[%04x]\n", offs);
+
+			key = key_create_or_update(
+				make_key_ref(keyring, 1),
+				"asymmetric",
+				NULL,
+				&elem->signature_data,
+				esize - sizeof(*elem),
+				(KEY_POS_ALL & ~KEY_POS_SETATTR) |
+				KEY_USR_VIEW,
+				KEY_ALLOC_NOT_IN_QUOTA);
+
+			if (IS_ERR(key))
+				pr_err("Problem loading in-kernel X.509 certificate (%ld)\n",
+				       PTR_ERR(key));
+			else
+				pr_notice("Loaded cert '%s' linked to '%s'\n",
+					  key_ref_to_ptr(key)->description,
+					  keyring->description);
+
+			data += esize;
+			size -= esize;
+			offs += esize;
+		}
+	}
+
+	return 0;
+}
diff -urN linux-4.9-01/crypto/asymmetric_keys/Kconfig linux-4.9-02/crypto/asymmetric_keys/Kconfig
--- linux-4.9-01/crypto/asymmetric_keys/Kconfig	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/crypto/asymmetric_keys/Kconfig	2017-01-21 11:59:18.570155410 +0000
@@ -61,4 +61,12 @@
 	  This option provides support for verifying the signature(s) on a
 	  signed PE binary.
 
+config EFI_SIGNATURE_LIST_PARSER
+	bool "EFI signature list parser"
+	depends on EFI
+	select X509_CERTIFICATE_PARSER
+	help
+	  This option provides support for parsing EFI signature lists for
+	  X.509 certificates and turning them into keys.
+
 endif # ASYMMETRIC_KEY_TYPE
diff -urN linux-4.9-01/crypto/asymmetric_keys/Makefile linux-4.9-02/crypto/asymmetric_keys/Makefile
--- linux-4.9-01/crypto/asymmetric_keys/Makefile	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/crypto/asymmetric_keys/Makefile	2017-01-21 11:59:18.578155181 +0000
@@ -10,6 +10,7 @@
 	signature.o
 
 obj-$(CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE) += public_key.o
+obj-$(CONFIG_EFI_SIGNATURE_LIST_PARSER) += efi_parser.o
 
 #
 # X.509 Certificate handling
diff -urN linux-4.9-01/Documentation/devicetree/bindings/arm/rockchip.txt linux-4.9-02/Documentation/devicetree/bindings/arm/rockchip.txt
--- linux-4.9-01/Documentation/devicetree/bindings/arm/rockchip.txt	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/Documentation/devicetree/bindings/arm/rockchip.txt	2017-01-21 11:59:14.615268886 +0000
@@ -99,6 +99,15 @@
     Required root node properties:
       - compatible = "mqmaker,miqi", "rockchip,rk3288";
 
+- GeekBuying GeekBox:
+    Required root node properties:
+      - compatible = "geekbuying,geekbox", "rockchip,rk3368";
+
+- GeekBuying Landingship with GeekBox module:
+    Required root node properties:
+      - compatible = "geekbuying,geekbox-landingship",
+		     "geekbuying,geekbox", "rockchip,rk3368";
+
 - Rockchip RK3368 evb:
     Required root node properties:
       - compatible = "rockchip,rk3368-evb-act8846", "rockchip,rk3368";
diff -urN linux-4.9-01/Documentation/devicetree/bindings/net/allwinner,sun8i-emac.txt linux-4.9-02/Documentation/devicetree/bindings/net/allwinner,sun8i-emac.txt
--- linux-4.9-01/Documentation/devicetree/bindings/net/allwinner,sun8i-emac.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.9-02/Documentation/devicetree/bindings/net/allwinner,sun8i-emac.txt	2017-01-21 11:59:17.233193771 +0000
@@ -0,0 +1,70 @@
+* Allwinner sun8i EMAC ethernet controller
+
+Required properties:
+- compatible: should be one of the following string:
+		"allwinner,sun8i-a83t-emac"
+		"allwinner,sun8i-h3-emac"
+		"allwinner,sun50i-a64-emac"
+- reg: address and length of the register for the device.
+- syscon: A phandle to the syscon of the SoC
+- interrupts: interrupt for the device
+- clocks: A phandle to the reference clock for this device
+- clock-names: should be "ahb"
+- resets: A phandle to the reset control for this device
+- reset-names: should be "ahb"
+- phy-mode: See ethernet.txt
+- phy-handle: See ethernet.txt
+- #address-cells: shall be 1
+- #size-cells: shall be 0
+
+Optional properties:
+- allwinner,tx-delay: TX clock delay chain value. Range value is 0-0x07. Default is 0)
+- allwinner,rx-delay: RX clock delay chain value. Range value is 0-0x1F. Default is 0)
+Both delay properties does not have units, there are arbitrary value.
+The TX/RX clock delay chain settings are board specific and could be found
+in vendor FEX files.
+
+Optional properties for "allwinner,sun8i-h3-emac":
+- allwinner,leds-active-low: EPHY LEDs are active low
+
+Required child node of emac:
+- mdio bus node: should be named mdio
+
+Required properties of the mdio node:
+- #address-cells: shall be 1
+- #size-cells: shall be 0
+
+The device node referenced by "phy" or "phy-handle" should be a child node
+of the mdio node. See phy.txt for the generic PHY bindings.
+
+Required properties of the phy node with "allwinner,sun8i-h3-emac":
+- clocks: an extra phandle to the reference clock for the EPHY
+- resets: an extra phandle to the reset control for the EPHY
+
+Example:
+
+emac: ethernet@01c0b000 {
+	compatible = "allwinner,sun8i-h3-emac";
+	syscon = <&syscon>;
+	reg = <0x01c0b000 0x104>;
+	interrupts = <GIC_SPI 82 IRQ_TYPE_LEVEL_HIGH>;
+	resets = <&ccu RST_BUS_EMAC>;
+	reset-names = "ahb";
+	clocks = <&ccu CLK_BUS_EMAC>;
+	clock-names = "ahb";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	phy = <&int_mii_phy>;
+	phy-mode = "mii";
+	allwinner,leds-active-low;
+	mdio: mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		int_mii_phy: ethernet-phy@1 {
+			reg = <1>;
+			clocks = <&ccu CLK_BUS_EPHY>;
+			resets = <&ccu RST_BUS_EPHY>;
+		};
+	};
+};
diff -urN linux-4.9-01/Documentation/x86/zero-page.txt linux-4.9-02/Documentation/x86/zero-page.txt
--- linux-4.9-01/Documentation/x86/zero-page.txt	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/Documentation/x86/zero-page.txt	2017-01-21 11:59:18.419159742 +0000
@@ -31,6 +31,8 @@
 1E9/001	ALL	eddbuf_entries	Number of entries in eddbuf (below)
 1EA/001	ALL	edd_mbr_sig_buf_entries	Number of entries in edd_mbr_sig_buffer
 				(below)
+1EB/001	ALL     kbd_status      Numlock is enabled
+1EC/001	ALL     secure_boot	Secure boot is enabled in the firmware
 1EF/001	ALL	sentinel	Used to detect broken bootloaders
 290/040	ALL	edd_mbr_sig_buffer EDD MBR signatures
 2D0/A00	ALL	e820_map	E820 memory map table
diff -urN linux-4.9-01/drivers/acpi/custom_method.c linux-4.9-02/drivers/acpi/custom_method.c
--- linux-4.9-01/drivers/acpi/custom_method.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/acpi/custom_method.c	2017-01-21 11:59:18.165167030 +0000
@@ -29,6 +29,9 @@
 	struct acpi_table_header table;
 	acpi_status status;
 
+	if (secure_modules())
+		return -EPERM;
+
 	if (!(*ppos)) {
 		/* parse the table header to get the table length */
 		if (count <= sizeof(struct acpi_table_header))
diff -urN linux-4.9-01/drivers/acpi/osl.c linux-4.9-02/drivers/acpi/osl.c
--- linux-4.9-01/drivers/acpi/osl.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/acpi/osl.c	2017-01-21 11:59:18.379160890 +0000
@@ -40,6 +40,7 @@
 #include <linux/list.h>
 #include <linux/jiffies.h>
 #include <linux/semaphore.h>
+#include <linux/module.h>
 
 #include <asm/io.h>
 #include <asm/uaccess.h>
@@ -191,7 +192,7 @@
 acpi_physical_address __init acpi_os_get_root_pointer(void)
 {
 #ifdef CONFIG_KEXEC
-	if (acpi_rsdp)
+	if (acpi_rsdp && !secure_modules())
 		return acpi_rsdp;
 #endif
 
diff -urN linux-4.9-01/drivers/acpi/pci_mcfg.c linux-4.9-02/drivers/acpi/pci_mcfg.c
--- linux-4.9-01/drivers/acpi/pci_mcfg.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/acpi/pci_mcfg.c	2017-01-21 11:59:15.016257380 +0000
@@ -22,6 +22,7 @@
 #include <linux/kernel.h>
 #include <linux/pci.h>
 #include <linux/pci-acpi.h>
+#include <linux/pci-ecam.h>
 
 /* Structure to hold entries from the MCFG table */
 struct mcfg_entry {
@@ -31,13 +32,179 @@
 	u8			bus_start;
 	u8			bus_end;
 };
+struct mcfg_fixup {
+	char oem_id[ACPI_OEM_ID_SIZE + 1];
+	char oem_table_id[ACPI_OEM_TABLE_ID_SIZE + 1];
+	u32 oem_revision;
+	u16 seg;
+	struct resource bus_range;
+	struct pci_ecam_ops *ops;
+	struct resource cfgres;
+};
+
+#define MCFG_DOM_ANY			(-1)
+#define MCFG_BUS_RANGE(start, end)	DEFINE_RES_NAMED((start),	\
+						((end) - (start) + 1),	\
+						NULL, IORESOURCE_BUS)
+#define MCFG_BUS_ANY		MCFG_BUS_RANGE(0x0, 0xff)
+#define MCFG_RES_EMPTY		DEFINE_RES_NAMED(0, 0, NULL, 0)
+
+static struct mcfg_fixup mcfg_quirks[] = {
+/*	{ OEM_ID, OEM_TABLE_ID, REV, DOMAIN, BUS_RANGE, cfgres, ops }, */
+#ifdef CONFIG_PCI_HOST_THUNDER_PEM
+	/* SoC pass2.x */
+	{ "CAVIUM", "THUNDERX", 1, 4, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x88001f000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 1, 5, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x884057000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 1, 6, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x88808f000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 1, 7, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x89001f000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 1, 8, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x894057000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 1, 9, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x89808f000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 1, 14, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x98001f000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 1, 15, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x984057000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 1, 16, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x98808f000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 1, 17, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x99001f000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 1, 18, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x994057000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 1, 19, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x99808f000000UL, 0x39 * SZ_16M) },
+
+	/* SoC pass1.x */
+	{ "CAVIUM", "THUNDERX", 2, 4, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x88001f000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 2, 5, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x884057000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 2, 6, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x88808f000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 2, 7, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x89001f000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 2, 8, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x894057000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 2, 9, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x89808f000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 2, 14, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x98001f000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 2, 15, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x984057000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 2, 16, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x98808f000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 2, 17, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x99001f000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 2, 18, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x994057000000UL, 0x39 * SZ_16M) },
+	{ "CAVIUM", "THUNDERX", 2, 19, MCFG_BUS_ANY, &pci_thunder_pem_ops,
+	  DEFINE_RES_MEM(0x99808f000000UL, 0x39 * SZ_16M) },
+#endif
+#ifdef CONFIG_PCI_HOST_THUNDER_ECAM
+	/* SoC pass1.x */
+	{ "CAVIUM", "THUNDERX", 2, 0, MCFG_BUS_ANY, &pci_thunder_ecam_ops,
+	  MCFG_RES_EMPTY},
+	{ "CAVIUM", "THUNDERX", 2, 1, MCFG_BUS_ANY, &pci_thunder_ecam_ops,
+	  MCFG_RES_EMPTY},
+	{ "CAVIUM", "THUNDERX", 2, 2, MCFG_BUS_ANY, &pci_thunder_ecam_ops,
+	  MCFG_RES_EMPTY},
+	{ "CAVIUM", "THUNDERX", 2, 3, MCFG_BUS_ANY, &pci_thunder_ecam_ops,
+	  MCFG_RES_EMPTY},
+	{ "CAVIUM", "THUNDERX", 2, 10, MCFG_BUS_ANY, &pci_thunder_ecam_ops,
+	  MCFG_RES_EMPTY},
+	{ "CAVIUM", "THUNDERX", 2, 11, MCFG_BUS_ANY, &pci_thunder_ecam_ops,
+	  MCFG_RES_EMPTY},
+	{ "CAVIUM", "THUNDERX", 2, 12, MCFG_BUS_ANY, &pci_thunder_ecam_ops,
+	  MCFG_RES_EMPTY},
+	{ "CAVIUM", "THUNDERX", 2, 13, MCFG_BUS_ANY, &pci_thunder_ecam_ops,
+	  MCFG_RES_EMPTY},
+#endif
+#ifdef CONFIG_PCI_XGENE
+	{"APM   ", "XGENE   ", 1, 0, MCFG_BUS_ANY,
+		&xgene_v1_pcie_ecam_ops, MCFG_RES_EMPTY},
+	{"APM   ", "XGENE   ", 1, 1, MCFG_BUS_ANY,
+		&xgene_v1_pcie_ecam_ops, MCFG_RES_EMPTY},
+	{"APM   ", "XGENE   ", 1, 2, MCFG_BUS_ANY,
+		&xgene_v1_pcie_ecam_ops, MCFG_RES_EMPTY},
+	{"APM   ", "XGENE   ", 1, 3, MCFG_BUS_ANY,
+		&xgene_v1_pcie_ecam_ops, MCFG_RES_EMPTY},
+	{"APM   ", "XGENE   ", 1, 4, MCFG_BUS_ANY,
+		&xgene_v1_pcie_ecam_ops, MCFG_RES_EMPTY},
+	{"APM   ", "XGENE   ", 2, 0, MCFG_BUS_ANY,
+		&xgene_v1_pcie_ecam_ops, MCFG_RES_EMPTY},
+	{"APM   ", "XGENE   ", 2, 1, MCFG_BUS_ANY,
+		&xgene_v1_pcie_ecam_ops, MCFG_RES_EMPTY},
+	{"APM   ", "XGENE   ", 2, 2, MCFG_BUS_ANY,
+		&xgene_v1_pcie_ecam_ops, MCFG_RES_EMPTY},
+	{"APM   ", "XGENE   ", 2, 3, MCFG_BUS_ANY,
+		&xgene_v1_pcie_ecam_ops, MCFG_RES_EMPTY},
+	{"APM   ", "XGENE   ", 2, 4, MCFG_BUS_ANY,
+		&xgene_v1_pcie_ecam_ops, MCFG_RES_EMPTY},
+	{"APM   ", "XGENE   ", 3, 0, MCFG_BUS_ANY,
+		&xgene_v2_1_pcie_ecam_ops, MCFG_RES_EMPTY},
+	{"APM   ", "XGENE   ", 3, 1, MCFG_BUS_ANY,
+		&xgene_v2_1_pcie_ecam_ops, MCFG_RES_EMPTY},
+	{"APM   ", "XGENE   ", 4, 0, MCFG_BUS_ANY,
+		&xgene_v2_2_pcie_ecam_ops, MCFG_RES_EMPTY},
+	{"APM   ", "XGENE   ", 4, 1, MCFG_BUS_ANY,
+		&xgene_v2_2_pcie_ecam_ops, MCFG_RES_EMPTY},
+	{"APM   ", "XGENE   ", 4, 2, MCFG_BUS_ANY,
+		&xgene_v2_2_pcie_ecam_ops, MCFG_RES_EMPTY},
+#endif
+};
+
+static char mcfg_oem_id[ACPI_OEM_ID_SIZE];
+static char mcfg_oem_table_id[ACPI_OEM_TABLE_ID_SIZE];
+static u32 mcfg_oem_revision;
+
+static void pci_mcfg_match_quirks(struct acpi_pci_root *root,
+				  struct resource *cfgres,
+				  struct pci_ecam_ops **ecam_ops)
+{
+	struct mcfg_fixup *f;
+	int i;
+
+	/*
+	 * First match against PCI topology <domain:bus> then use OEM ID, OEM
+	 * table ID, and OEM revision from MCFG table standard header.
+	 */
+	for (i = 0, f = mcfg_quirks; i < ARRAY_SIZE(mcfg_quirks); i++, f++) {
+		if (f->seg == root->segment &&
+		    resource_contains(&f->bus_range, &root->secondary) &&
+		    !memcmp(f->oem_id, mcfg_oem_id, ACPI_OEM_ID_SIZE) &&
+		    !memcmp(f->oem_table_id, mcfg_oem_table_id,
+		            ACPI_OEM_TABLE_ID_SIZE) &&
+		    f->oem_revision == mcfg_oem_revision) {
+			if (f->cfgres.start)
+				*cfgres = f->cfgres;
+			if (f->ops)
+				*ecam_ops =  f->ops;
+			dev_info(&root->device->dev, "Applying PCI MCFG quirks for %s %s rev: %d\n",
+				 f->oem_id, f->oem_table_id, f->oem_revision);
+			return;
+		}
+	}
+}
 
 /* List to save MCFG entries */
 static LIST_HEAD(pci_mcfg_list);
 
-phys_addr_t pci_mcfg_lookup(u16 seg, struct resource *bus_res)
+int pci_mcfg_lookup(struct acpi_pci_root *root, struct resource *cfgres,
+		    struct pci_ecam_ops **ecam_ops)
 {
+	struct pci_ecam_ops *ops = &pci_generic_ecam_ops;
+	struct resource *bus_res = &root->secondary;
+	u16 seg = root->segment;
 	struct mcfg_entry *e;
+	struct resource res;
+
+	/* Use address from _CBA if present, otherwise lookup MCFG */
+	if (root->mcfg_addr)
+		goto skip_lookup;
 
 	/*
 	 * We expect exact match, unless MCFG entry end bus covers more than
@@ -45,10 +212,32 @@
 	 */
 	list_for_each_entry(e, &pci_mcfg_list, list) {
 		if (e->segment == seg && e->bus_start == bus_res->start &&
-		    e->bus_end >= bus_res->end)
-			return e->addr;
+		    e->bus_end >= bus_res->end) {
+			root->mcfg_addr = e->addr;
+		}
+
+	}
+
+skip_lookup:
+	memset(&res, 0, sizeof(res));
+	if (root->mcfg_addr) {
+		res.start = root->mcfg_addr + (bus_res->start << 20);
+		res.end = res.start + (resource_size(bus_res) << 20) - 1;
+		res.flags = IORESOURCE_MEM;
 	}
 
+	/*
+	 * Let to override default ECAM ops and CFG resource range.
+	 * Also, this might even retrieve CFG resource range in case MCFG
+	 * does not have it. Invalid CFG start address means MCFG firmware bug
+	 * or we need another quirk in array.
+	 */
+	pci_mcfg_match_quirks(root, &res, &ops);
+	if (!res.start)
+		return -ENXIO;
+
+	*cfgres = res;
+	*ecam_ops = ops;
 	return 0;
 }
 
@@ -79,6 +268,11 @@
 		list_add(&e->list, &pci_mcfg_list);
 	}
 
+	/* Save MCFG IDs and revision for quirks matching */
+	memcpy(mcfg_oem_id, header->oem_id, ACPI_OEM_ID_SIZE);
+	memcpy(mcfg_oem_table_id, header->oem_table_id, ACPI_OEM_TABLE_ID_SIZE);
+	mcfg_oem_revision = header->revision;
+
 	pr_info("MCFG table detected, %d entries\n", n);
 	return 0;
 }
diff -urN linux-4.9-01/drivers/base/firmware_class.c linux-4.9-02/drivers/base/firmware_class.c
--- linux-4.9-01/drivers/base/firmware_class.c	2017-01-21 11:57:04.604998922 +0000
+++ linux-4.9-02/drivers/base/firmware_class.c	2017-01-21 11:59:18.949144536 +0000
@@ -1163,7 +1163,7 @@
 		}
 	} else {
 		ret = usermodehelper_read_trylock();
-		if (WARN_ON(ret)) {
+		if (ret) {
 			dev_err(device, "firmware: %s will not be loaded\n",
 				name);
 			goto out;
diff -urN linux-4.9-01/drivers/block/floppy.c linux-4.9-02/drivers/block/floppy.c
--- linux-4.9-01/drivers/block/floppy.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/block/floppy.c	2017-01-21 11:59:17.514185708 +0000
@@ -4638,8 +4638,7 @@
 	{"PNP0700", 0},
 	{}
 };
-
-MODULE_DEVICE_TABLE(pnp, floppy_pnpids);
+/* MODULE_DEVICE_TABLE(pnp, floppy_pnpids); */
 
 #else
 
diff -urN linux-4.9-01/drivers/char/crash.c linux-4.9-02/drivers/char/crash.c
--- linux-4.9-01/drivers/char/crash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.9-02/drivers/char/crash.c	2017-01-21 11:59:17.916174179 +0000
@@ -0,0 +1,166 @@
+/*
+ *  linux/drivers/char/crash.c
+ *
+ *  Copyright (C) 2004  Dave Anderson <anderson@redhat.com>
+ *  Copyright (C) 2004  Red Hat, Inc.
+ */
+
+/******************************************************************************
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2, or (at your option)
+ *   any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *****************************************************************************/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/types.h>
+#include <asm/crash-driver.h>
+
+#define CRASH_VERSION   "1.3"
+
+/*
+ *  These are the file operation functions that allow crash utility
+ *  access to physical memory.
+ */
+
+static loff_t
+crash_llseek(struct file * file, loff_t offset, int orig)
+{
+	switch (orig) {
+	case 0:
+		file->f_pos = offset;
+		return file->f_pos;
+	case 1:
+		file->f_pos += offset;
+		return file->f_pos;
+	default:
+		return -EINVAL;
+	}
+}
+
+/*
+ *  Determine the page address for an address offset value,
+ *  get a virtual address for it, and copy it out.
+ *  Accesses must fit within a page.
+ */
+static ssize_t
+crash_read(struct file *file, char *buf, size_t count, loff_t *poff)
+{
+	void *vaddr;
+	struct page *page;
+	u64 offset;
+	ssize_t read;
+	char *buffer = file->private_data;
+
+	offset = *poff;
+	if (offset >> PAGE_SHIFT != (offset+count-1) >> PAGE_SHIFT)
+		return -EINVAL;
+
+	vaddr = map_virtual(offset, &page);
+	if (!vaddr)
+		return -EFAULT;
+	/*
+	 * Use bounce buffer to bypass the CONFIG_HARDENED_USERCOPY
+	 * kernel text restriction.
+	*/
+	memcpy(buffer, (char *)vaddr, count);
+	if (copy_to_user(buf, buffer, count)) {
+		unmap_virtual(page);
+		return -EFAULT;
+	}
+	unmap_virtual(page);
+
+	read = count;
+	*poff += read;
+	return read;
+}
+
+static int
+crash_open(struct inode * inode, struct file * filp)
+{
+	if (!capable(CAP_SYS_RAWIO))
+		return -EPERM;
+
+	filp->private_data = (void *)__get_free_page(GFP_KERNEL);
+	if (!filp->private_data)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static int
+crash_release(struct inode *inode, struct file *filp)
+{
+	free_pages((unsigned long)filp->private_data, 0);
+	return 0;
+}
+
+static long
+crash_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+#ifdef DEV_CRASH_ARCH_DATA
+	return crash_arch_ioctl(file, cmd, arg);
+#else
+	return -EINVAL;
+#endif
+}
+
+static struct file_operations crash_fops = {
+	.owner = THIS_MODULE,
+	.llseek = crash_llseek,
+	.read = crash_read,
+	.unlocked_ioctl = crash_ioctl,
+	.open = crash_open,
+	.release = crash_release,
+};
+
+static struct miscdevice crash_dev = {
+	MISC_DYNAMIC_MINOR,
+	"crash",
+	&crash_fops
+};
+
+static int __init
+crash_init(void)
+{
+	int ret;
+
+	ret = misc_register(&crash_dev);
+	if (ret) {
+		printk(KERN_ERR
+		    "crash memory driver: cannot misc_register (MISC_DYNAMIC_MINOR)\n");
+		goto out;
+	}
+
+	ret = 0;
+	printk(KERN_INFO "crash memory driver: version %s\n", CRASH_VERSION);
+out:
+	return ret;
+}
+
+static void __exit
+crash_cleanup_module(void)
+{
+	misc_deregister(&crash_dev);
+}
+
+module_init(crash_init);
+module_exit(crash_cleanup_module);
+
+MODULE_LICENSE("GPL");
diff -urN linux-4.9-01/drivers/char/Kconfig linux-4.9-02/drivers/char/Kconfig
--- linux-4.9-01/drivers/char/Kconfig	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/char/Kconfig	2017-01-21 11:59:17.848176125 +0000
@@ -4,6 +4,10 @@
 
 menu "Character devices"
 
+config CRASH
+	tristate "Crash Utility memory driver"
+	depends on X86_32 || X86_64 || ARM || ARM64 || PPC64 || S390
+
 source "drivers/tty/Kconfig"
 
 config DEVMEM
diff -urN linux-4.9-01/drivers/char/Makefile linux-4.9-02/drivers/char/Makefile
--- linux-4.9-01/drivers/char/Makefile	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/char/Makefile	2017-01-21 11:59:17.847176154 +0000
@@ -60,3 +60,5 @@
 obj-$(CONFIG_TILE_SROM)		+= tile-srom.o
 obj-$(CONFIG_XILLYBUS)		+= xillybus/
 obj-$(CONFIG_POWERNV_OP_PANEL)	+= powernv-op-panel.o
+
+obj-$(CONFIG_CRASH)            += crash.o
diff -urN linux-4.9-01/drivers/char/mem.c linux-4.9-02/drivers/char/mem.c
--- linux-4.9-01/drivers/char/mem.c	2017-01-21 11:57:04.606998865 +0000
+++ linux-4.9-02/drivers/char/mem.c	2017-01-21 11:59:18.357161521 +0000
@@ -28,6 +28,7 @@
 #include <linux/export.h>
 #include <linux/io.h>
 #include <linux/uio.h>
+#include <linux/module.h>
 
 #include <linux/uaccess.h>
 
@@ -163,6 +164,9 @@
 	if (p != *ppos)
 		return -EFBIG;
 
+	if (secure_modules())
+		return -EPERM;
+
 	if (!valid_phys_addr_range(p, count))
 		return -EFAULT;
 
@@ -513,6 +517,9 @@
 	char *kbuf; /* k-addr because vwrite() takes vmlist_lock rwlock */
 	int err = 0;
 
+	if (secure_modules())
+		return -EPERM;
+
 	if (p < (unsigned long) high_memory) {
 		unsigned long to_write = min_t(unsigned long, count,
 					       (unsigned long)high_memory - p);
@@ -578,6 +585,9 @@
 	unsigned long i = *ppos;
 	const char __user *tmp = buf;
 
+	if (secure_modules())
+		return -EPERM;
+
 	if (!access_ok(VERIFY_READ, buf, count))
 		return -EFAULT;
 	while (count-- > 0 && i < 65536) {
diff -urN linux-4.9-01/drivers/clk/bcm/clk-bcm2835.c linux-4.9-02/drivers/clk/bcm/clk-bcm2835.c
--- linux-4.9-01/drivers/clk/bcm/clk-bcm2835.c	2017-01-21 11:57:04.606998865 +0000
+++ linux-4.9-02/drivers/clk/bcm/clk-bcm2835.c	2017-01-21 11:59:16.089226594 +0000
@@ -436,6 +436,9 @@
 	const char *const *parents;
 	int num_mux_parents;
 
+	/* Bitmap encoding which parents accept rate change propagation. */
+	unsigned int set_rate_parent;
+
 	u32 ctl_reg;
 	u32 div_reg;
 
@@ -1017,10 +1020,60 @@
 	return strncmp(clk_hw_get_name(hw), "pllc", 4) == 0;
 }
 
+static unsigned long bcm2835_clock_choose_div_and_prate(struct clk_hw *hw,
+							int parent_idx,
+							unsigned long rate,
+							u32 *div,
+							unsigned long *prate)
+{
+	struct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);
+	struct bcm2835_cprman *cprman = clock->cprman;
+	const struct bcm2835_clock_data *data = clock->data;
+	unsigned long best_rate = 0;
+	u32 curdiv, mindiv, maxdiv;
+	struct clk_hw *parent;
+
+	parent = clk_hw_get_parent_by_index(hw, parent_idx);
+
+	if (!(BIT(parent_idx) & data->set_rate_parent)) {
+		*prate = clk_hw_get_rate(parent);
+		*div = bcm2835_clock_choose_div(hw, rate, *prate, true);
+
+		return bcm2835_clock_rate_from_divisor(clock, *prate,
+						       *div);
+	}
+
+	if (data->frac_bits)
+		dev_warn(cprman->dev,
+			"frac bits are not used when propagating rate change");
+
+	/* clamp to min divider of 2 if we're dealing with a mash clock */
+	mindiv = data->is_mash_clock ? 2 : 1;
+	maxdiv = BIT(data->int_bits) - 1;
+
+	/* TODO: Be smart, and only test a subset of the available divisors. */
+	for (curdiv = mindiv; curdiv <= maxdiv; curdiv++) {
+		unsigned long tmp_rate;
+
+		tmp_rate = clk_hw_round_rate(parent, rate * curdiv);
+		tmp_rate /= curdiv;
+		if (curdiv == mindiv ||
+		    (tmp_rate > best_rate && tmp_rate <= rate))
+			best_rate = tmp_rate;
+
+		if (best_rate == rate)
+			break;
+	}
+
+	*div = curdiv << CM_DIV_FRAC_BITS;
+	*prate = curdiv * best_rate;
+
+	return best_rate;
+}
+
 static int bcm2835_clock_determine_rate(struct clk_hw *hw,
 					struct clk_rate_request *req)
 {
-	struct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);
 	struct clk_hw *parent, *best_parent = NULL;
 	bool current_parent_is_pllc;
 	unsigned long rate, best_rate = 0;
@@ -1048,9 +1101,8 @@
 		if (bcm2835_clk_is_pllc(parent) && !current_parent_is_pllc)
 			continue;
 
-		prate = clk_hw_get_rate(parent);
-		div = bcm2835_clock_choose_div(hw, req->rate, prate, true);
-		rate = bcm2835_clock_rate_from_divisor(clock, prate, div);
+		rate = bcm2835_clock_choose_div_and_prate(hw, i, req->rate,
+							  &div, &prate);
 		if (rate > best_rate && rate <= req->rate) {
 			best_parent = parent;
 			best_prate = prate;
@@ -1262,6 +1314,13 @@
 	init.name = data->name;
 	init.flags = data->flags | CLK_IGNORE_UNUSED;
 
+	/*
+	 * Pass the CLK_SET_RATE_PARENT flag if we are allowed to propagate
+	 * rate changes on at least of the parents.
+	 */
+	if (data->set_rate_parent)
+		init.flags |= CLK_SET_RATE_PARENT;
+
 	if (data->is_vpu_clock) {
 		init.ops = &bcm2835_vpu_clock_clk_ops;
 	} else {
@@ -1598,7 +1657,7 @@
 		.a2w_reg = A2W_PLLH_AUX,
 		.load_mask = CM_PLLH_LOADAUX,
 		.hold_mask = 0,
-		.fixed_divider = 10),
+		.fixed_divider = 1),
 	[BCM2835_PLLH_PIX]	= REGISTER_PLL_DIV(
 		.name = "pllh_pix",
 		.source_pll = "pllh",
@@ -1802,7 +1861,12 @@
 		.ctl_reg = CM_VECCTL,
 		.div_reg = CM_VECDIV,
 		.int_bits = 4,
-		.frac_bits = 0),
+		.frac_bits = 0,
+		/*
+		 * Allow rate change propagation only on PLLH_AUX which is
+		 * assigned index 7 in the parent array.
+		 */
+		.set_rate_parent = BIT(7)),
 
 	/* dsi clocks */
 	[BCM2835_CLOCK_DSI0E]	= REGISTER_PER_CLK(
diff -urN linux-4.9-01/drivers/clocksource/bcm2835_timer.c linux-4.9-02/drivers/clocksource/bcm2835_timer.c
--- linux-4.9-01/drivers/clocksource/bcm2835_timer.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/clocksource/bcm2835_timer.c	2017-01-21 11:59:16.071227111 +0000
@@ -96,7 +96,7 @@
 	ret = of_property_read_u32(node, "clock-frequency", &freq);
 	if (ret) {
 		pr_err("Can't read clock-frequency");
-		return ret;
+		goto err_iounmap;
 	}
 
 	system_clock = base + REG_COUNTER_LO;
@@ -108,13 +108,15 @@
 	irq = irq_of_parse_and_map(node, DEFAULT_TIMER);
 	if (irq <= 0) {
 		pr_err("Can't parse IRQ");
-		return -EINVAL;
+		ret = -EINVAL;
+		goto err_iounmap;
 	}
 
 	timer = kzalloc(sizeof(*timer), GFP_KERNEL);
 	if (!timer) {
 		pr_err("Can't allocate timer struct\n");
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto err_iounmap;
 	}
 
 	timer->control = base + REG_CONTROL;
@@ -133,7 +135,7 @@
 	ret = setup_irq(irq, &timer->act);
 	if (ret) {
 		pr_err("Can't set up timer IRQ\n");
-		return ret;
+		goto err_iounmap;
 	}
 
 	clockevents_config_and_register(&timer->evt, freq, 0xf, 0xffffffff);
@@ -141,6 +143,10 @@
 	pr_info("bcm2835: system timer (irq = %d)\n", irq);
 
 	return 0;
+
+err_iounmap:
+	iounmap(base);
+	return ret;
 }
 CLOCKSOURCE_OF_DECLARE(bcm2835, "brcm,bcm2835-system-timer",
 			bcm2835_timer_init);
diff -urN linux-4.9-01/drivers/gpu/drm/i915/intel_display.c linux-4.9-02/drivers/gpu/drm/i915/intel_display.c
--- linux-4.9-01/drivers/gpu/drm/i915/intel_display.c	2017-01-21 11:57:04.645997746 +0000
+++ linux-4.9-02/drivers/gpu/drm/i915/intel_display.c	2017-01-21 11:59:18.798148868 +0000
@@ -13621,7 +13621,7 @@
 	sw_config = to_intel_crtc_state(crtc->state);
 	if (!intel_pipe_config_compare(dev, sw_config,
 				       pipe_config, false)) {
-		I915_STATE_WARN(1, "pipe state doesn't match!\n");
+		DRM_DEBUG_KMS("pipe state doesn't match!\n");
 		intel_dump_pipe_config(intel_crtc, pipe_config,
 				       "[hw state]");
 		intel_dump_pipe_config(intel_crtc, sw_config,
diff -urN linux-4.9-01/drivers/gpu/drm/nouveau/nouveau_backlight.c linux-4.9-02/drivers/gpu/drm/nouveau/nouveau_backlight.c
--- linux-4.9-01/drivers/gpu/drm/nouveau/nouveau_backlight.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/gpu/drm/nouveau/nouveau_backlight.c	2017-01-21 11:59:19.071141036 +0000
@@ -232,6 +232,7 @@
 		case NV_DEVICE_INFO_V0_TESLA:
 		case NV_DEVICE_INFO_V0_FERMI:
 		case NV_DEVICE_INFO_V0_KEPLER:
+		case NV_DEVICE_INFO_V0_MAXWELL:
 			return nv50_backlight_init(connector);
 		default:
 			break;
diff -urN linux-4.9-01/drivers/i2c/busses/i2c-bcm2835.c linux-4.9-02/drivers/i2c/busses/i2c-bcm2835.c
--- linux-4.9-01/drivers/i2c/busses/i2c-bcm2835.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/i2c/busses/i2c-bcm2835.c	2017-01-21 11:59:16.050227713 +0000
@@ -50,20 +50,19 @@
 #define BCM2835_I2C_S_CLKT	BIT(9)
 #define BCM2835_I2C_S_LEN	BIT(10) /* Fake bit for SW error reporting */
 
-#define BCM2835_I2C_BITMSK_S	0x03FF
-
 #define BCM2835_I2C_CDIV_MIN	0x0002
 #define BCM2835_I2C_CDIV_MAX	0xFFFE
 
-#define BCM2835_I2C_TIMEOUT (msecs_to_jiffies(1000))
-
 struct bcm2835_i2c_dev {
 	struct device *dev;
 	void __iomem *regs;
 	struct clk *clk;
 	int irq;
+	u32 bus_clk_rate;
 	struct i2c_adapter adapter;
 	struct completion completion;
+	struct i2c_msg *curr_msg;
+	int num_msgs;
 	u32 msg_err;
 	u8 *msg_buf;
 	size_t msg_buf_remaining;
@@ -80,6 +79,30 @@
 	return readl(i2c_dev->regs + reg);
 }
 
+static int bcm2835_i2c_set_divider(struct bcm2835_i2c_dev *i2c_dev)
+{
+	u32 divider;
+
+	divider = DIV_ROUND_UP(clk_get_rate(i2c_dev->clk),
+			       i2c_dev->bus_clk_rate);
+	/*
+	 * Per the datasheet, the register is always interpreted as an even
+	 * number, by rounding down. In other words, the LSB is ignored. So,
+	 * if the LSB is set, increment the divider to avoid any issue.
+	 */
+	if (divider & 1)
+		divider++;
+	if ((divider < BCM2835_I2C_CDIV_MIN) ||
+	    (divider > BCM2835_I2C_CDIV_MAX)) {
+		dev_err_ratelimited(i2c_dev->dev, "Invalid clock-frequency\n");
+		return -EINVAL;
+	}
+
+	bcm2835_i2c_writel(i2c_dev, BCM2835_I2C_DIV, divider);
+
+	return 0;
+}
+
 static void bcm2835_fill_txfifo(struct bcm2835_i2c_dev *i2c_dev)
 {
 	u32 val;
@@ -110,106 +133,159 @@
 	}
 }
 
+/*
+ * Repeated Start Condition (Sr)
+ * The BCM2835 ARM Peripherals datasheet mentions a way to trigger a Sr when it
+ * talks about reading from a slave with 10 bit address. This is achieved by
+ * issuing a write, poll the I2CS.TA flag and wait for it to be set, and then
+ * issue a read.
+ * A comment in https://github.com/raspberrypi/linux/issues/254 shows how the
+ * firmware actually does it using polling and says that it's a workaround for
+ * a problem in the state machine.
+ * It turns out that it is possible to use the TXW interrupt to know when the
+ * transfer is active, provided the FIFO has not been prefilled.
+ */
+
+static void bcm2835_i2c_start_transfer(struct bcm2835_i2c_dev *i2c_dev)
+{
+	u32 c = BCM2835_I2C_C_ST | BCM2835_I2C_C_I2CEN;
+	struct i2c_msg *msg = i2c_dev->curr_msg;
+	bool last_msg = (i2c_dev->num_msgs == 1);
+
+	if (!i2c_dev->num_msgs)
+		return;
+
+	i2c_dev->num_msgs--;
+	i2c_dev->msg_buf = msg->buf;
+	i2c_dev->msg_buf_remaining = msg->len;
+
+	if (msg->flags & I2C_M_RD)
+		c |= BCM2835_I2C_C_READ | BCM2835_I2C_C_INTR;
+	else
+		c |= BCM2835_I2C_C_INTT;
+
+	if (last_msg)
+		c |= BCM2835_I2C_C_INTD;
+
+	bcm2835_i2c_writel(i2c_dev, BCM2835_I2C_A, msg->addr);
+	bcm2835_i2c_writel(i2c_dev, BCM2835_I2C_DLEN, msg->len);
+	bcm2835_i2c_writel(i2c_dev, BCM2835_I2C_C, c);
+}
+
+/*
+ * Note about I2C_C_CLEAR on error:
+ * The I2C_C_CLEAR on errors will take some time to resolve -- if you were in
+ * non-idle state and I2C_C_READ, it sets an abort_rx flag and runs through
+ * the state machine to send a NACK and a STOP. Since we're setting CLEAR
+ * without I2CEN, that NACK will be hanging around queued up for next time
+ * we start the engine.
+ */
+
 static irqreturn_t bcm2835_i2c_isr(int this_irq, void *data)
 {
 	struct bcm2835_i2c_dev *i2c_dev = data;
 	u32 val, err;
 
 	val = bcm2835_i2c_readl(i2c_dev, BCM2835_I2C_S);
-	val &= BCM2835_I2C_BITMSK_S;
-	bcm2835_i2c_writel(i2c_dev, BCM2835_I2C_S, val);
 
 	err = val & (BCM2835_I2C_S_CLKT | BCM2835_I2C_S_ERR);
 	if (err) {
 		i2c_dev->msg_err = err;
-		complete(&i2c_dev->completion);
-		return IRQ_HANDLED;
-	}
-
-	if (val & BCM2835_I2C_S_RXD) {
-		bcm2835_drain_rxfifo(i2c_dev);
-		if (!(val & BCM2835_I2C_S_DONE))
-			return IRQ_HANDLED;
+		goto complete;
 	}
 
 	if (val & BCM2835_I2C_S_DONE) {
-		if (i2c_dev->msg_buf_remaining)
+		if (i2c_dev->curr_msg->flags & I2C_M_RD) {
+			bcm2835_drain_rxfifo(i2c_dev);
+			val = bcm2835_i2c_readl(i2c_dev, BCM2835_I2C_S);
+		}
+
+		if ((val & BCM2835_I2C_S_RXD) || i2c_dev->msg_buf_remaining)
 			i2c_dev->msg_err = BCM2835_I2C_S_LEN;
 		else
 			i2c_dev->msg_err = 0;
-		complete(&i2c_dev->completion);
-		return IRQ_HANDLED;
+		goto complete;
 	}
 
-	if (val & BCM2835_I2C_S_TXD) {
+	if (val & BCM2835_I2C_S_TXW) {
+		if (!i2c_dev->msg_buf_remaining) {
+			i2c_dev->msg_err = val | BCM2835_I2C_S_LEN;
+			goto complete;
+		}
+
 		bcm2835_fill_txfifo(i2c_dev);
+
+		if (i2c_dev->num_msgs && !i2c_dev->msg_buf_remaining) {
+			i2c_dev->curr_msg++;
+			bcm2835_i2c_start_transfer(i2c_dev);
+		}
+
+		return IRQ_HANDLED;
+	}
+
+	if (val & BCM2835_I2C_S_RXR) {
+		if (!i2c_dev->msg_buf_remaining) {
+			i2c_dev->msg_err = val | BCM2835_I2C_S_LEN;
+			goto complete;
+		}
+
+		bcm2835_drain_rxfifo(i2c_dev);
 		return IRQ_HANDLED;
 	}
 
 	return IRQ_NONE;
+
+complete:
+	bcm2835_i2c_writel(i2c_dev, BCM2835_I2C_C, BCM2835_I2C_C_CLEAR);
+	bcm2835_i2c_writel(i2c_dev, BCM2835_I2C_S, BCM2835_I2C_S_CLKT |
+			   BCM2835_I2C_S_ERR | BCM2835_I2C_S_DONE);
+	complete(&i2c_dev->completion);
+
+	return IRQ_HANDLED;
 }
 
-static int bcm2835_i2c_xfer_msg(struct bcm2835_i2c_dev *i2c_dev,
-				struct i2c_msg *msg)
+static int bcm2835_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],
+			    int num)
 {
-	u32 c;
+	struct bcm2835_i2c_dev *i2c_dev = i2c_get_adapdata(adap);
 	unsigned long time_left;
+	int i, ret;
 
-	i2c_dev->msg_buf = msg->buf;
-	i2c_dev->msg_buf_remaining = msg->len;
-	reinit_completion(&i2c_dev->completion);
+	for (i = 0; i < (num - 1); i++)
+		if (msgs[i].flags & I2C_M_RD) {
+			dev_warn_once(i2c_dev->dev,
+				      "only one read message supported, has to be last\n");
+			return -EOPNOTSUPP;
+		}
+
+	ret = bcm2835_i2c_set_divider(i2c_dev);
+	if (ret)
+		return ret;
 
-	bcm2835_i2c_writel(i2c_dev, BCM2835_I2C_C, BCM2835_I2C_C_CLEAR);
-
-	if (msg->flags & I2C_M_RD) {
-		c = BCM2835_I2C_C_READ | BCM2835_I2C_C_INTR;
-	} else {
-		c = BCM2835_I2C_C_INTT;
-		bcm2835_fill_txfifo(i2c_dev);
-	}
-	c |= BCM2835_I2C_C_ST | BCM2835_I2C_C_INTD | BCM2835_I2C_C_I2CEN;
+	i2c_dev->curr_msg = msgs;
+	i2c_dev->num_msgs = num;
+	reinit_completion(&i2c_dev->completion);
 
-	bcm2835_i2c_writel(i2c_dev, BCM2835_I2C_A, msg->addr);
-	bcm2835_i2c_writel(i2c_dev, BCM2835_I2C_DLEN, msg->len);
-	bcm2835_i2c_writel(i2c_dev, BCM2835_I2C_C, c);
+	bcm2835_i2c_start_transfer(i2c_dev);
 
 	time_left = wait_for_completion_timeout(&i2c_dev->completion,
-						BCM2835_I2C_TIMEOUT);
-	bcm2835_i2c_writel(i2c_dev, BCM2835_I2C_C, BCM2835_I2C_C_CLEAR);
+						adap->timeout);
 	if (!time_left) {
+		bcm2835_i2c_writel(i2c_dev, BCM2835_I2C_C,
+				   BCM2835_I2C_C_CLEAR);
 		dev_err(i2c_dev->dev, "i2c transfer timed out\n");
 		return -ETIMEDOUT;
 	}
 
-	if (likely(!i2c_dev->msg_err))
-		return 0;
+	if (!i2c_dev->msg_err)
+		return num;
 
-	if ((i2c_dev->msg_err & BCM2835_I2C_S_ERR) &&
-	    (msg->flags & I2C_M_IGNORE_NAK))
-		return 0;
-
-	dev_err(i2c_dev->dev, "i2c transfer failed: %x\n", i2c_dev->msg_err);
+	dev_dbg(i2c_dev->dev, "i2c transfer failed: %x\n", i2c_dev->msg_err);
 
 	if (i2c_dev->msg_err & BCM2835_I2C_S_ERR)
 		return -EREMOTEIO;
-	else
-		return -EIO;
-}
-
-static int bcm2835_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],
-			    int num)
-{
-	struct bcm2835_i2c_dev *i2c_dev = i2c_get_adapdata(adap);
-	int i;
-	int ret = 0;
-
-	for (i = 0; i < num; i++) {
-		ret = bcm2835_i2c_xfer_msg(i2c_dev, &msgs[i]);
-		if (ret)
-			break;
-	}
 
-	return ret ?: i;
+	return -EIO;
 }
 
 static u32 bcm2835_i2c_func(struct i2c_adapter *adap)
@@ -235,7 +311,6 @@
 {
 	struct bcm2835_i2c_dev *i2c_dev;
 	struct resource *mem, *irq;
-	u32 bus_clk_rate, divider;
 	int ret;
 	struct i2c_adapter *adap;
 
@@ -259,28 +334,13 @@
 	}
 
 	ret = of_property_read_u32(pdev->dev.of_node, "clock-frequency",
-				   &bus_clk_rate);
+				   &i2c_dev->bus_clk_rate);
 	if (ret < 0) {
 		dev_warn(&pdev->dev,
 			 "Could not read clock-frequency property\n");
-		bus_clk_rate = 100000;
+		i2c_dev->bus_clk_rate = 100000;
 	}
 
-	divider = DIV_ROUND_UP(clk_get_rate(i2c_dev->clk), bus_clk_rate);
-	/*
-	 * Per the datasheet, the register is always interpreted as an even
-	 * number, by rounding down. In other words, the LSB is ignored. So,
-	 * if the LSB is set, increment the divider to avoid any issue.
-	 */
-	if (divider & 1)
-		divider++;
-	if ((divider < BCM2835_I2C_CDIV_MIN) ||
-	    (divider > BCM2835_I2C_CDIV_MAX)) {
-		dev_err(&pdev->dev, "Invalid clock-frequency\n");
-		return -ENODEV;
-	}
-	bcm2835_i2c_writel(i2c_dev, BCM2835_I2C_DIV, divider);
-
 	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	if (!irq) {
 		dev_err(&pdev->dev, "No IRQ resource\n");
diff -urN linux-4.9-01/drivers/input/keyboard/atkbd.c linux-4.9-02/drivers/input/keyboard/atkbd.c
--- linux-4.9-01/drivers/input/keyboard/atkbd.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/input/keyboard/atkbd.c	2017-01-21 11:59:17.399189010 +0000
@@ -436,11 +436,15 @@
 		goto out;
 	case ATKBD_RET_ACK:
 	case ATKBD_RET_NAK:
+# if 0
+		/* Quite a few key switchers and other tools trigger this
+		 * and it confuses people who can do nothing about it */
 		if (printk_ratelimit())
 			dev_warn(&serio->dev,
 				 "Spurious %s on %s. "
 				 "Some program might be trying to access hardware directly.\n",
 				 data == ATKBD_RET_ACK ? "ACK" : "NAK", serio->phys);
+#endif
 		goto out;
 	case ATKBD_RET_ERR:
 		atkbd->err_count++;
diff -urN linux-4.9-01/drivers/input/misc/pcspkr.c linux-4.9-02/drivers/input/misc/pcspkr.c
--- linux-4.9-01/drivers/input/misc/pcspkr.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/input/misc/pcspkr.c	2017-01-21 11:59:17.555184532 +0000
@@ -23,7 +23,6 @@
 MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>");
 MODULE_DESCRIPTION("PC Speaker beeper driver");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:pcspkr");
 
 static int pcspkr_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
 {
diff -urN linux-4.9-01/drivers/input/misc/uinput.c linux-4.9-02/drivers/input/misc/uinput.c
--- linux-4.9-01/drivers/input/misc/uinput.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/input/misc/uinput.c	2017-01-21 11:59:18.716151221 +0000
@@ -379,6 +379,7 @@
 	if (!udev->dev)
 		return -ENOMEM;
 
+	udev->dev->flags |= INPUTDEV_FLAGS_SYNTHETIC;
 	udev->dev->event = uinput_dev_event;
 	input_set_drvdata(udev->dev, udev);
 
diff -urN linux-4.9-01/drivers/input/mouse/synaptics.c linux-4.9-02/drivers/input/mouse/synaptics.c
--- linux-4.9-01/drivers/input/mouse/synaptics.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/input/mouse/synaptics.c	2017-01-21 11:59:18.941144766 +0000
@@ -941,6 +941,14 @@
 		input_report_abs(dev, ABS_MT_PRESSURE, hw[i]->z);
 	}
 
+	/* keep (slot count <= num_fingers) by pinning all slots */
+	if (num_fingers >= 3) {
+		for (i = 0; i < 3; i++) {
+			input_mt_slot(dev, i);
+			input_mt_report_slot_state(dev, MT_TOOL_FINGER, true);
+		}
+	}
+
 	input_mt_drop_unused(dev);
 
 	/* Don't use active slot count to generate BTN_TOOL events. */
diff -urN linux-4.9-01/drivers/input/serio/i8042.c linux-4.9-02/drivers/input/serio/i8042.c
--- linux-4.9-01/drivers/input/serio/i8042.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/input/serio/i8042.c	2017-01-21 11:59:18.815148381 +0000
@@ -1582,6 +1582,22 @@
 	.notifier_call = i8042_kbd_bind_notifier,
 };
 
+#ifdef CONFIG_DMI
+static struct dmi_system_id __initdata dmi_system_table[] = {
+	{
+		.matches = {
+			DMI_MATCH(DMI_BIOS_VENDOR, "Apple Computer, Inc.")
+		},
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BIOS_VENDOR, "Apple Inc.")
+		},
+	},
+	{}
+};
+#endif /*CONFIG_DMI*/
+
 static int __init i8042_init(void)
 {
 	struct platform_device *pdev;
@@ -1589,6 +1605,12 @@
 
 	dbg_init();
 
+#ifdef CONFIG_DMI
+	/* Intel Apple Macs never have an i8042 controller */
+	if (dmi_check_system(dmi_system_table) > 0)
+		return -ENODEV;
+#endif /*CONFIG_DMI*/
+
 	err = i8042_platform_init();
 	if (err)
 		return err;
diff -urN linux-4.9-01/drivers/misc/lis3lv02d/lis3lv02d.c linux-4.9-02/drivers/misc/lis3lv02d/lis3lv02d.c
--- linux-4.9-01/drivers/misc/lis3lv02d/lis3lv02d.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/misc/lis3lv02d/lis3lv02d.c	2017-01-21 11:59:18.833147864 +0000
@@ -216,7 +216,8 @@
 /* conversion btw sampling rate and the register values */
 static int lis3_12_rates[4] = {40, 160, 640, 2560};
 static int lis3_8_rates[2] = {100, 400};
-static int lis3_3dc_rates[16] = {0, 1, 10, 25, 50, 100, 200, 400, 1600, 5000};
+/* LIS3DC: 0 = power off, above 9 = undefined */
+static int lis3_3dc_rates[16] = {0, 1, 10, 25, 50, 100, 200, 400, 1600, 5000, -1, -1, -1, -1, -1, -1};
 static int lis3_3dlh_rates[4] = {50, 100, 400, 1000};
 
 /* ODR is Output Data Rate */
@@ -231,12 +232,11 @@
 	return lis3->odrs[(ctrl >> shift)];
 }
 
-static int lis3lv02d_get_pwron_wait(struct lis3lv02d *lis3)
+static int lis3lv02d_wait_pwron(struct lis3lv02d *lis3)
 {
 	int div = lis3lv02d_get_odr(lis3);
-
-	if (WARN_ONCE(div == 0, "device returned spurious data"))
-		return -ENXIO;
+	if (div <= 0)
+		div = 1; /* maximum delay */
 
 	/* LIS3 power on delay is quite long */
 	msleep(lis3->pwron_delay / div);
@@ -303,7 +303,7 @@
 
 	lis3->read(lis3, ctlreg, &reg);
 	lis3->write(lis3, ctlreg, (reg | selftest));
-	ret = lis3lv02d_get_pwron_wait(lis3);
+	ret = lis3lv02d_wait_pwron(lis3);
 	if (ret)
 		goto fail;
 
@@ -314,7 +314,7 @@
 
 	/* back to normal settings */
 	lis3->write(lis3, ctlreg, reg);
-	ret = lis3lv02d_get_pwron_wait(lis3);
+	ret = lis3lv02d_wait_pwron(lis3);
 	if (ret)
 		goto fail;
 
@@ -434,7 +434,7 @@
 		}
 	}
 
-	err = lis3lv02d_get_pwron_wait(lis3);
+	err = lis3lv02d_wait_pwron(lis3);
 	if (err)
 		return err;
 
diff -urN linux-4.9-01/drivers/mmc/host/omap_hsmmc.c linux-4.9-02/drivers/mmc/host/omap_hsmmc.c
--- linux-4.9-01/drivers/mmc/host/omap_hsmmc.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/mmc/host/omap_hsmmc.c	2017-01-21 11:59:15.448244984 +0000
@@ -32,6 +32,7 @@
 #include <linux/of_irq.h>
 #include <linux/of_gpio.h>
 #include <linux/of_device.h>
+#include <linux/omap-dmaengine.h>
 #include <linux/mmc/host.h>
 #include <linux/mmc/core.h>
 #include <linux/mmc/mmc.h>
@@ -1992,6 +1993,8 @@
 	struct resource *res;
 	int ret, irq;
 	const struct of_device_id *match;
+	dma_cap_mask_t mask;
+	unsigned tx_req, rx_req;
 	const struct omap_mmc_of_data *data;
 	void __iomem *base;
 
@@ -2121,17 +2124,44 @@
 
 	omap_hsmmc_conf_bus_power(host);
 
-	host->rx_chan = dma_request_chan(&pdev->dev, "rx");
-	if (IS_ERR(host->rx_chan)) {
-		dev_err(mmc_dev(host->mmc), "RX DMA channel request failed\n");
-		ret = PTR_ERR(host->rx_chan);
+	if (!pdev->dev.of_node) {
+		res = platform_get_resource_byname(pdev, IORESOURCE_DMA, "tx");
+		if (!res) {
+			dev_err(mmc_dev(host->mmc), "cannot get DMA TX channel\n");
+			ret = -ENXIO;
+			goto err_irq;
+		}
+		tx_req = res->start;
+
+		res = platform_get_resource_byname(pdev, IORESOURCE_DMA, "rx");
+		if (!res) {
+			dev_err(mmc_dev(host->mmc), "cannot get DMA RX channel\n");
+			ret = -ENXIO;
+			goto err_irq;
+		}
+		rx_req = res->start;
+	}
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+
+	host->rx_chan =
+		dma_request_slave_channel_compat(mask, omap_dma_filter_fn,
+						 &rx_req, &pdev->dev, "rx");
+
+	if (!host->rx_chan) {
+		dev_err(mmc_dev(host->mmc), "unable to obtain RX DMA engine channel\n");
+		ret = -ENXIO;
 		goto err_irq;
 	}
 
-	host->tx_chan = dma_request_chan(&pdev->dev, "tx");
-	if (IS_ERR(host->tx_chan)) {
-		dev_err(mmc_dev(host->mmc), "TX DMA channel request failed\n");
-		ret = PTR_ERR(host->tx_chan);
+	host->tx_chan =
+		dma_request_slave_channel_compat(mask, omap_dma_filter_fn,
+						 &tx_req, &pdev->dev, "tx");
+
+	if (!host->tx_chan) {
+		dev_err(mmc_dev(host->mmc), "unable to obtain TX DMA engine channel\n");
+		ret = -ENXIO;
 		goto err_irq;
 	}
 
@@ -2189,9 +2219,9 @@
 	mmc_remove_host(mmc);
 err_irq:
 	device_init_wakeup(&pdev->dev, false);
-	if (!IS_ERR_OR_NULL(host->tx_chan))
+	if (host->tx_chan)
 		dma_release_channel(host->tx_chan);
-	if (!IS_ERR_OR_NULL(host->rx_chan))
+	if (host->rx_chan)
 		dma_release_channel(host->rx_chan);
 	pm_runtime_dont_use_autosuspend(host->dev);
 	pm_runtime_put_sync(host->dev);
diff -urN linux-4.9-01/drivers/mmc/host/sdhci-iproc.c linux-4.9-02/drivers/mmc/host/sdhci-iproc.c
--- linux-4.9-01/drivers/mmc/host/sdhci-iproc.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/mmc/host/sdhci-iproc.c	2017-01-21 11:59:16.153224758 +0000
@@ -143,6 +143,14 @@
 }
 
 static const struct sdhci_ops sdhci_iproc_ops = {
+	.set_clock = sdhci_set_clock,
+	.get_max_clock = sdhci_pltfm_clk_get_max_clock,
+	.set_bus_width = sdhci_set_bus_width,
+	.reset = sdhci_reset,
+	.set_uhs_signaling = sdhci_set_uhs_signaling,
+};
+
+static const struct sdhci_ops sdhci_iproc_32only_ops = {
 	.read_l = sdhci_iproc_readl,
 	.read_w = sdhci_iproc_readw,
 	.read_b = sdhci_iproc_readb,
@@ -156,6 +164,28 @@
 	.set_uhs_signaling = sdhci_set_uhs_signaling,
 };
 
+static const struct sdhci_pltfm_data sdhci_iproc_cygnus_pltfm_data = {
+	.quirks = SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK,
+	.quirks2 = SDHCI_QUIRK2_ACMD23_BROKEN,
+	.ops = &sdhci_iproc_32only_ops,
+};
+
+static const struct sdhci_iproc_data iproc_cygnus_data = {
+	.pdata = &sdhci_iproc_cygnus_pltfm_data,
+	.caps = ((0x1 << SDHCI_MAX_BLOCK_SHIFT)
+			& SDHCI_MAX_BLOCK_MASK) |
+		SDHCI_CAN_VDD_330 |
+		SDHCI_CAN_VDD_180 |
+		SDHCI_CAN_DO_SUSPEND |
+		SDHCI_CAN_DO_HISPD |
+		SDHCI_CAN_DO_ADMA2 |
+		SDHCI_CAN_DO_SDMA,
+	.caps1 = SDHCI_DRIVER_TYPE_C |
+		 SDHCI_DRIVER_TYPE_D |
+		 SDHCI_SUPPORT_DDR50,
+	.mmc_caps = MMC_CAP_1_8V_DDR,
+};
+
 static const struct sdhci_pltfm_data sdhci_iproc_pltfm_data = {
 	.quirks = SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK,
 	.quirks2 = SDHCI_QUIRK2_ACMD23_BROKEN,
@@ -181,20 +211,26 @@
 static const struct sdhci_pltfm_data sdhci_bcm2835_pltfm_data = {
 	.quirks = SDHCI_QUIRK_BROKEN_CARD_DETECTION |
 		  SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK |
-		  SDHCI_QUIRK_MISSING_CAPS,
-	.ops = &sdhci_iproc_ops,
+		  SDHCI_QUIRK_MISSING_CAPS |
+		  SDHCI_QUIRK_NO_HISPD_BIT,
+	.ops = &sdhci_iproc_32only_ops,
 };
 
 static const struct sdhci_iproc_data bcm2835_data = {
 	.pdata = &sdhci_bcm2835_pltfm_data,
-	.caps = SDHCI_CAN_VDD_330,
-	.caps1 = 0x00000000,
+	.caps = ((0x1 << SDHCI_MAX_BLOCK_SHIFT)
+			& SDHCI_MAX_BLOCK_MASK) |
+		SDHCI_CAN_VDD_330 |
+		SDHCI_CAN_DO_HISPD,
+	.caps1 = SDHCI_DRIVER_TYPE_A |
+		 SDHCI_DRIVER_TYPE_C,
 	.mmc_caps = 0x00000000,
 };
 
 static const struct of_device_id sdhci_iproc_of_match[] = {
 	{ .compatible = "brcm,bcm2835-sdhci", .data = &bcm2835_data },
-	{ .compatible = "brcm,sdhci-iproc-cygnus", .data = &iproc_data },
+	{ .compatible = "brcm,sdhci-iproc-cygnus", .data = &iproc_cygnus_data},
+	{ .compatible = "brcm,sdhci-iproc", .data = &iproc_data },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, sdhci_iproc_of_match);
diff -urN linux-4.9-01/drivers/net/ethernet/allwinner/Kconfig linux-4.9-02/drivers/net/ethernet/allwinner/Kconfig
--- linux-4.9-01/drivers/net/ethernet/allwinner/Kconfig	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/net/ethernet/allwinner/Kconfig	2017-01-21 11:59:16.215222980 +0000
@@ -33,4 +33,17 @@
           To compile this driver as a module, choose M here.  The module
           will be called sun4i-emac.
 
+config SUN8I_EMAC
+	tristate "Allwinner sun8i EMAC support"
+	depends on ARCH_SUNXI || COMPILE_TEST
+	depends on OF
+	select MII
+	select PHYLIB
+        ---help---
+	  This driver support the sun8i EMAC ethernet driver present on
+	  H3/A83T/A64 Allwinner SoCs.
+
+          To compile this driver as a module, choose M here.  The module
+          will be called sun8i-emac.
+
 endif # NET_VENDOR_ALLWINNER
diff -urN linux-4.9-01/drivers/net/ethernet/allwinner/Makefile linux-4.9-02/drivers/net/ethernet/allwinner/Makefile
--- linux-4.9-01/drivers/net/ethernet/allwinner/Makefile	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/net/ethernet/allwinner/Makefile	2017-01-21 11:59:16.222222779 +0000
@@ -3,3 +3,4 @@
 #
 
 obj-$(CONFIG_SUN4I_EMAC) += sun4i-emac.o
+obj-$(CONFIG_SUN8I_EMAC) += sun8i-emac.o
diff -urN linux-4.9-01/drivers/net/ethernet/allwinner/sun8i-emac.c linux-4.9-02/drivers/net/ethernet/allwinner/sun8i-emac.c
--- linux-4.9-01/drivers/net/ethernet/allwinner/sun8i-emac.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.9-02/drivers/net/ethernet/allwinner/sun8i-emac.c	2017-01-21 11:59:16.303220454 +0000
@@ -0,0 +1,2266 @@
+/*
+ * sun8i-emac driver
+ *
+ * Copyright (C) 2015-2016 Corentin LABBE <clabbe.montjoie@gmail.com>
+ *
+ * This is the driver for Allwinner Ethernet MAC found in H3/A83T/A64 SoC
+ *
+ * TODO:
+ * - MAC filtering
+ * - Jumbo frame
+ * - features rx-all (NETIF_F_RXALL_BIT)
+ * - PM runtime
+ */
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/etherdevice.h>
+#include <linux/interrupt.h>
+#include <linux/iopoll.h>
+#include <linux/mii.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/of_device.h>
+#include <linux/of_mdio.h>
+#include <linux/of_net.h>
+#include <linux/phy.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include <linux/scatterlist.h>
+#include <linux/skbuff.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+
+#define EMAC_BASIC_CTL0	0x00
+#define EMAC_BASIC_CTL1	0x04
+#define EMAC_INT_STA	0x08
+#define EMAC_INT_EN	0x0C
+#define EMAC_TX_CTL0	0x10
+#define EMAC_TX_CTL1	0x14
+#define EMAC_TX_FLOW_CTL	0x1C
+#define EMAC_RX_CTL0	0x24
+#define EMAC_RX_CTL1	0x28
+#define EMAC_RX_FRM_FLT	0x38
+#define EMAC_MDIO_CMD	0x48
+#define EMAC_MDIO_DATA	0x4C
+#define EMAC_TX_DMA_STA	0xB0
+#define EMAC_TX_CUR_DESC	0xB4
+#define EMAC_TX_CUR_BUF	0xB8
+#define EMAC_RX_DMA_STA	0xC0
+
+#define MDIO_CMD_MII_BUSY	BIT(0)
+#define MDIO_CMD_MII_WRITE	BIT(1)
+#define MDIO_CMD_MII_PHY_REG_ADDR_MASK	GENMASK(8, 4)
+#define MDIO_CMD_MII_PHY_REG_ADDR_SHIFT	4
+#define MDIO_CMD_MII_PHY_ADDR_MASK	GENMASK(16, 12)
+#define MDIO_CMD_MII_PHY_ADDR_SHIFT	12
+
+#define EMAC_MACADDR_HI	0x50
+#define EMAC_MACADDR_LO	0x54
+
+#define EMAC_RX_DESC_LIST 0x34
+#define EMAC_TX_DESC_LIST 0x20
+
+#define EMAC_RX_DO_CRC BIT(27)
+#define EMAC_RX_STRIP_FCS BIT(28)
+
+#define LE32_BIT(x) (cpu_to_le32(BIT(x)))
+
+#define EMAC_COULD_BE_USED_BY_DMA LE32_BIT(31)
+
+/* Used in RX_CTL1*/
+#define EMAC_RX_DMA_EN	BIT(30)
+#define EMAC_RX_DMA_START	BIT(31)
+/* Used in TX_CTL1*/
+#define EMAC_TX_DMA_EN	BIT(30)
+#define EMAC_TX_DMA_START	BIT(31)
+
+/* Used in RX_CTL0 */
+#define EMAC_RX_RECEIVER_EN		BIT(31)
+/* Used in TX_CTL0 */
+#define EMAC_TX_TRANSMITTER_EN	BIT(31)
+
+/* Basic CTL0 */
+#define EMAC_BCTL0_FD BIT(0)
+#define EMAC_BCTL0_SPEED_10		2
+#define EMAC_BCTL0_SPEED_100		3
+#define EMAC_BCTL0_SPEED_MASK	GENMASK(3, 2)
+#define EMAC_BCTL0_SPEED_SHIFT	2
+
+#define EMAC_FLOW_RX 1
+#define EMAC_FLOW_TX 2
+
+#define EMAC_TX_INT		BIT(0)
+#define EMAC_TX_DMA_STOP_INT	BIT(1)
+#define EMAC_TX_BUF_UA_INT	BIT(2)
+#define EMAC_TX_TIMEOUT_INT	BIT(3)
+#define EMAC_TX_UNDERFLOW_INT	BIT(4)
+#define EMAC_TX_EARLY_INT	BIT(5)
+#define EMAC_RX_INT		BIT(8)
+#define EMAC_RX_BUF_UA_INT	BIT(9)
+#define EMAC_RX_DMA_STOP_INT	BIT(10)
+#define EMAC_RX_TIMEOUT_INT	BIT(11)
+#define EMAC_RX_OVERFLOW_INT	BIT(12)
+#define EMAC_RX_EARLY_INT	BIT(13)
+#define EMAC_RGMII_STA_INT	BIT(16)
+
+/* Bits used in frame RX status */
+#define EMAC_DSC_RX_FIRST		BIT(9)
+#define EMAC_DSC_RX_LAST		BIT(8)
+
+/* Bits used in frame TX ctl */
+#define EMAC_MAGIC_TX_BIT		LE32_BIT(24)
+#define EMAC_TX_DO_CRC		(LE32_BIT(27) | LE32_BIT(28))
+#define EMAC_DSC_TX_FIRST		LE32_BIT(29)
+#define EMAC_DSC_TX_LAST		LE32_BIT(30)
+#define EMAC_WANT_INT			LE32_BIT(31)
+
+/* struct emac_variant - Describe an emac variant of sun8i-emac
+ * @default_syscon_value: Default value of the syscon EMAC register
+ * The default_syscon_value is also used for powering down the PHY
+ * @internal_phy:	which PHY type is internal
+ * @support_mii:	Does the SoC support MII
+ * @support_rmii:	Does the SoC support RMII
+ * @support_rgmii:	Does the SoC support RGMII
+ */
+struct emac_variant {
+	u32 default_syscon_value;
+	int internal_phy;
+	bool support_mii;
+	bool support_rmii;
+	bool support_rgmii;
+};
+
+static const struct emac_variant emac_variant_h3 = {
+	.default_syscon_value = 0x58000,
+	.internal_phy = PHY_INTERFACE_MODE_MII,
+	.support_mii = true,
+	.support_rmii = true,
+	.support_rgmii = true
+};
+
+static const struct emac_variant emac_variant_a83t = {
+	.default_syscon_value = 0,
+	.internal_phy = 0,
+	.support_mii = true,
+	.support_rgmii = true
+};
+
+static const struct emac_variant emac_variant_a64 = {
+	.default_syscon_value = 0,
+	.internal_phy = 0,
+	.support_mii = true,
+	.support_rmii = true,
+	.support_rgmii = true
+};
+
+static const char const estats_str[][ETH_GSTRING_LEN] = {
+	/* errors */
+	"rx_payload_error",
+	"rx_CRC_error",
+	"rx_phy_error",
+	"rx_length_error",
+	"rx_col_error",
+	"rx_header_error",
+	"rx_overflow_error",
+	"rx_saf_error",
+	"rx_daf_error",
+	"rx_buf_error",
+	"rx_invalid_error",
+	"tx_timeout",
+	/* misc infos */
+	"tx_stop_queue",
+	"rx_dma_ua",
+	"rx_dma_stop",
+	"tx_dma_ua",
+	"tx_dma_stop",
+	"rx_hw_csum",
+	"tx_hw_csum",
+	/* interrupts */
+	"rx_int",
+	"tx_int",
+	"tx_early_int",
+	"tx_underflow_int",
+	"tx_timeout_int",
+	"rx_early_int",
+	"rx_overflow_int",
+	"rx_timeout_int",
+	"rgmii_state_int",
+	/* debug */
+	"tx_used_desc",
+	"napi_schedule",
+	"napi_underflow",
+};
+
+struct sun8i_emac_stats {
+	u64 rx_payload_error;
+	u64 rx_crc_error;
+	u64 rx_phy_error;
+	u64 rx_length_error;
+	u64 rx_col_error;
+	u64 rx_header_error;
+	u64 rx_overflow_error;
+	u64 rx_saf_fail;
+	u64 rx_daf_fail;
+	u64 rx_buf_error;
+	u64 rx_invalid_error;
+	u64 tx_timeout;
+
+	u64 tx_stop_queue;
+	u64 rx_dma_ua;
+	u64 rx_dma_stop;
+	u64 tx_dma_ua;
+	u64 tx_dma_stop;
+	u64 rx_hw_csum;
+	u64 tx_hw_csum;
+
+	u64 rx_int;
+	u64 tx_int;
+	u64 tx_early_int;
+	u64 tx_underflow_int;
+	u64 tx_timeout_int;
+	u64 rx_early_int;
+	u64 rx_overflow_int;
+	u64 rx_timeout_int;
+	u64 rgmii_state_int;
+
+	u64 tx_used_desc;
+	u64 napi_schedule;
+	u64 napi_underflow;
+};
+
+/* The datasheet said that each descriptor can transfers up to 4096bytes
+ * But latter, a register documentation reduce that value to 2048
+ * Anyway using 2048 cause strange behaviours and even BSP driver use 2047
+ */
+#define DESC_BUF_MAX 2044
+
+/* MAGIC value for knowing if a descriptor is available or not */
+#define DCLEAN cpu_to_le32(BIT(16) | BIT(14) | BIT(12) | BIT(10) | BIT(9))
+
+/* struct dma_desc - Structure of DMA descriptor used by the hardware
+ * @status:	Status of the frame written by HW, so RO for the
+ *		driver (except for BIT(31) which is R/W)
+ * @ctl:	Information on the frame written by the driver (INT, len,...)
+ * @buf_addr:	physical address of the frame data
+ * @next:	physical address of next dma_desc
+ */
+struct dma_desc {
+	__le32 status;
+	__le32 ctl;
+	__le32 buf_addr;
+	__le32 next;
+};
+
+/* Describe how data from skb are DMA mapped (used in txinfo map member) */
+#define MAP_SINGLE 1
+#define MAP_PAGE 2
+
+/* Structure for storing information about data in TX ring buffer */
+struct txinfo {
+	struct sk_buff *skb;
+	int map;
+};
+
+struct sun8i_emac_priv {
+	void __iomem *base;
+	struct regmap *regmap;
+	int irq;
+	struct device *dev;
+	struct net_device *ndev;
+	struct mii_bus *mdio;
+	struct napi_struct napi;
+	spinlock_t tx_lock;/* control the access of transmit descriptors */
+	int duplex;
+	int speed;
+	int link;
+	int phy_interface;
+	const struct emac_variant *variant;
+	struct device_node *phy_node;
+	struct device_node *mdio_node;
+	struct clk *ahb_clk;
+	struct clk *ephy_clk;
+	bool use_internal_phy;
+
+	struct reset_control *rst_mac;
+	struct reset_control *rst_ephy;
+
+	struct dma_desc *dd_rx;
+	dma_addr_t dd_rx_phy;
+	struct dma_desc *dd_tx;
+	dma_addr_t dd_tx_phy;
+	struct sk_buff **rx_skb;
+	struct txinfo *txl;
+
+	int nbdesc_tx;
+	int nbdesc_rx;
+	int tx_slot;
+	int tx_dirty;
+	int rx_dirty;
+	struct sun8i_emac_stats estats;
+	u32 msg_enable;
+	int flow_ctrl;
+	int pause;
+};
+
+static irqreturn_t sun8i_emac_dma_interrupt(int irq, void *dev_id);
+
+static void rb_inc(int *p, const int max)
+{
+	(*p)++;
+	(*p) %= max;
+}
+
+/* Locking strategy:
+ * RX queue does not need any lock since only sun8i_emac_poll() access it.
+ * (All other RX modifiers (ringparam/ndo_stop) disable NAPI and so
+ * sun8i_emac_poll())
+ * TX queue is handled by sun8i_emac_xmit(), sun8i_emac_complete_xmit() and
+ * sun8i_emac_tx_timeout()
+ * (All other RX modifiers (ringparam/ndo_stop) disable NAPI and stop queue)
+ *
+ * sun8i_emac_xmit() could fire only once (netif_tx_lock)
+ * sun8i_emac_complete_xmit() could fire only once (called from NAPI)
+ * sun8i_emac_tx_timeout() could fire only once (netif_tx_lock) and could not
+ * race with sun8i_emac_xmit (due to netif_tx_lock) and with
+ * sun8i_emac_complete_xmit which disable NAPI.
+ *
+ * So only sun8i_emac_xmit and sun8i_emac_complete_xmit could fire at the same
+ * time.
+ * But they never could modify the same descriptors:
+ * - sun8i_emac_complete_xmit() will modify only descriptors with empty status
+ * - sun8i_emac_xmit() will modify only descriptors set to DCLEAN
+ * Proper memory barriers ensure that descriptor set to DCLEAN could not be
+ * modified latter by sun8i_emac_complete_xmit().
+ */
+
+/* Return the number of contiguous free descriptors
+ * starting from tx_slot
+ */
+static int rb_tx_numfreedesc(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	if (priv->tx_slot < priv->tx_dirty)
+		return priv->tx_dirty - priv->tx_slot;
+
+	return (priv->nbdesc_tx - priv->tx_slot) + priv->tx_dirty;
+}
+
+/* sun8i_emac_rx_skb - Allocate a skb in a DMA descriptor
+ *
+ * @ndev:	The net_device for this interface
+ * @i:		index of slot to fill
+ *
+ * Refill a DMA descriptor with a fresh skb and map it for DMA.
+*/
+static int sun8i_emac_rx_skb(struct net_device *ndev, int i)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct dma_desc *ddesc;
+	struct sk_buff *skb;
+
+	ddesc = priv->dd_rx + i;
+
+	ddesc->ctl = 0;
+
+	skb = netdev_alloc_skb_ip_align(ndev, DESC_BUF_MAX);
+	if (!skb)
+		return -ENOMEM;
+
+	/* should not happen */
+	if (unlikely(priv->rx_skb[i]))
+		dev_warn(priv->dev, "BUG: Leaking a skbuff\n");
+
+	priv->rx_skb[i] = skb;
+
+	ddesc->buf_addr = dma_map_single(priv->dev, skb->data,
+					 DESC_BUF_MAX, DMA_FROM_DEVICE);
+	if (dma_mapping_error(priv->dev, ddesc->buf_addr)) {
+		dev_err(priv->dev, "ERROR: Cannot map RX buffer for DMA\n");
+		dev_kfree_skb(skb);
+		return -EFAULT;
+	}
+	/* We cannot direcly use cpu_to_le32() after dma_map_single
+	 * since dma_mapping_error use it
+	 */
+	ddesc->buf_addr = cpu_to_le32(ddesc->buf_addr);
+	ddesc->ctl |= cpu_to_le32(DESC_BUF_MAX);
+	/* EMAC_COULD_BE_USED_BY_DMA must be the last value written */
+	wmb();
+	ddesc->status = EMAC_COULD_BE_USED_BY_DMA;
+
+	return 0;
+}
+
+static void sun8i_emac_stop_tx(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	u32 v;
+
+	netif_stop_queue(ndev);
+
+	v = readl(priv->base + EMAC_TX_CTL0);
+	/* Disable transmitter after current reception */
+	v &= ~EMAC_TX_TRANSMITTER_EN;
+	writel(v, priv->base + EMAC_TX_CTL0);
+
+	v = readl(priv->base + EMAC_TX_CTL1);
+	/* Stop TX DMA */
+	v &= ~EMAC_TX_DMA_EN;
+	writel(v, priv->base + EMAC_TX_CTL1);
+
+	/* We must be sure that all is stopped before leaving this function */
+	wmb();
+}
+
+static void sun8i_emac_stop_rx(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	u32 v;
+
+	v = readl(priv->base + EMAC_RX_CTL0);
+	/* Disable receiver after current reception */
+	v &= ~EMAC_RX_RECEIVER_EN;
+	writel(v, priv->base + EMAC_RX_CTL0);
+
+	v = readl(priv->base + EMAC_RX_CTL1);
+	/* Stop RX DMA */
+	v &= ~EMAC_RX_DMA_EN;
+	writel(v, priv->base + EMAC_RX_CTL1);
+
+	/* We must be sure that all is stopped before leaving this function */
+	wmb();
+}
+
+static void sun8i_emac_start_rx(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	u32 v;
+
+	v = readl(priv->base + EMAC_RX_CTL0);
+	/* Enable receiver */
+	v |= EMAC_RX_RECEIVER_EN;
+	writel(v, priv->base + EMAC_RX_CTL0);
+
+	v = readl(priv->base + EMAC_RX_CTL1);
+	v |= EMAC_RX_DMA_START;
+	v |= EMAC_RX_DMA_EN;
+	writel(v, priv->base + EMAC_RX_CTL1);
+}
+
+static void sun8i_emac_start_tx(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	u32 v;
+
+	v = readl(priv->base + EMAC_TX_CTL0);
+	v |= EMAC_TX_TRANSMITTER_EN;
+	writel(v, priv->base + EMAC_TX_CTL0);
+
+	v = readl(priv->base + EMAC_TX_CTL1);
+	v |= EMAC_TX_DMA_START;
+	v |= EMAC_TX_DMA_EN;
+	writel(v, priv->base + EMAC_TX_CTL1);
+}
+
+/* sun8i_emac_set_macaddr - Set MAC address for slot index
+ *
+ * @addr: the MAC address to set
+ * @index: The index of slot where to set address.
+ *
+ * The slot 0 is the main MAC address
+ */
+static void sun8i_emac_set_macaddr(struct sun8i_emac_priv *priv,
+				   const u8 *addr, int index)
+{
+	u32 v;
+
+	dev_info(priv->dev, "device MAC address slot %d %pM", index, addr);
+
+	v = (addr[5] << 8) | addr[4];
+	writel(v, priv->base + EMAC_MACADDR_HI + index * 8);
+
+	v = (addr[3] << 24) | (addr[2] << 16) | (addr[1] << 8) | addr[0];
+	writel(v, priv->base + EMAC_MACADDR_LO + index * 8);
+}
+
+static void sun8i_emac_set_link_mode(struct sun8i_emac_priv *priv)
+{
+	u32 v;
+
+	v = readl(priv->base + EMAC_BASIC_CTL0);
+
+	if (priv->duplex)
+		v |= EMAC_BCTL0_FD;
+	else
+		v &= ~EMAC_BCTL0_FD;
+
+	v &= ~EMAC_BCTL0_SPEED_MASK;
+
+	switch (priv->speed) {
+	case 1000:
+		break;
+	case 100:
+		v |= EMAC_BCTL0_SPEED_100 << EMAC_BCTL0_SPEED_SHIFT;
+		break;
+	case 10:
+		v |= EMAC_BCTL0_SPEED_10 << EMAC_BCTL0_SPEED_SHIFT;
+		break;
+	default:
+		dev_err(priv->dev, "Unsupported speed %d\n", priv->speed);
+		return;
+	}
+
+	writel(v, priv->base + EMAC_BASIC_CTL0);
+}
+
+static void sun8i_emac_flow_ctrl(struct sun8i_emac_priv *priv, int duplex,
+				 int fc)
+{
+	u32 flow = 0;
+
+	flow = readl(priv->base + EMAC_RX_CTL0);
+	if (fc & EMAC_FLOW_RX)
+		flow |= BIT(16);
+	else
+		flow &= ~BIT(16);
+	writel(flow, priv->base + EMAC_RX_CTL0);
+
+	flow = readl(priv->base + EMAC_TX_FLOW_CTL);
+	if (fc & EMAC_FLOW_TX)
+		flow |= BIT(0);
+	else
+		flow &= ~BIT(0);
+	writel(flow, priv->base + EMAC_TX_FLOW_CTL);
+}
+
+/* Grab a frame into a skb from descriptor number i */
+static int sun8i_emac_rx_from_ddesc(struct net_device *ndev, int i)
+{
+	struct sk_buff *skb;
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct dma_desc *ddesc = priv->dd_rx + i;
+	int frame_len;
+	int rxcsum_done = 0;
+	u32 dstatus = le32_to_cpu(ddesc->status);
+
+	if (ndev->features & NETIF_F_RXCSUM)
+		rxcsum_done = 1;
+
+	/* bit0/bit7 work only on IPv4/IPv6 TCP traffic,
+	 * (not on ARP for example) so we do not raise rx_errors/discard frame
+	 */
+	/* the checksum or length of received frame's payload is wrong*/
+	if (dstatus & BIT(0)) {
+		priv->estats.rx_payload_error++;
+		rxcsum_done = 0;
+	}
+
+	/* RX_CRC_ERR */
+	if (dstatus & BIT(1)) {
+		priv->ndev->stats.rx_errors++;
+		priv->ndev->stats.rx_crc_errors++;
+		priv->estats.rx_crc_error++;
+		goto discard_frame;
+	}
+
+	/* RX_PHY_ERR */
+	if ((dstatus & BIT(3))) {
+		priv->ndev->stats.rx_errors++;
+		priv->estats.rx_phy_error++;
+		goto discard_frame;
+	}
+
+	/* RX_LENGTH_ERR */
+	if ((dstatus & BIT(4))) {
+		priv->ndev->stats.rx_errors++;
+		priv->ndev->stats.rx_length_errors++;
+		priv->estats.rx_length_error++;
+		goto discard_frame;
+	}
+
+	/* RX_COL_ERR */
+	if ((dstatus & BIT(6))) {
+		priv->ndev->stats.rx_errors++;
+		priv->estats.rx_col_error++;
+		goto discard_frame;
+	}
+
+	/* RX_HEADER_ERR */
+	if ((dstatus & BIT(7))) {
+		priv->estats.rx_header_error++;
+		rxcsum_done = 0;
+	}
+
+	/* RX_OVERFLOW_ERR */
+	if ((dstatus & BIT(11))) {
+		priv->ndev->stats.rx_over_errors++;
+		priv->estats.rx_overflow_error++;
+		goto discard_frame;
+	}
+
+	/* RX_NO_ENOUGTH_BUF_ERR */
+	if ((dstatus & BIT(14))) {
+		priv->ndev->stats.rx_errors++;
+		priv->estats.rx_buf_error++;
+		goto discard_frame;
+	}
+
+	/* BIT(9) is for the first frame, not having it is bad since we do not
+	 * handle Jumbo frame
+	 */
+	if ((dstatus & EMAC_DSC_RX_FIRST) == 0) {
+		priv->ndev->stats.rx_errors++;
+		priv->estats.rx_invalid_error++;
+		goto discard_frame;
+	}
+
+	/* this frame is not the last */
+	if ((dstatus & EMAC_DSC_RX_LAST) == 0) {
+		priv->ndev->stats.rx_errors++;
+		priv->estats.rx_invalid_error++;
+		goto discard_frame;
+	}
+
+	frame_len = (dstatus >> 16) & 0x3FFF;
+	if (!(ndev->features & NETIF_F_RXFCS))
+		frame_len -= ETH_FCS_LEN;
+
+	skb = priv->rx_skb[i];
+
+	netif_dbg(priv, rx_status, priv->ndev,
+		  "%s from %02d %pad len=%d status=%x st=%x\n",
+		  __func__, i, &ddesc, frame_len, dstatus,
+		  cpu_to_le32(ddesc->ctl));
+
+	skb_put(skb, frame_len);
+
+	dma_unmap_single(priv->dev, le32_to_cpu(ddesc->buf_addr), DESC_BUF_MAX,
+			 DMA_FROM_DEVICE);
+	skb->protocol = eth_type_trans(skb, priv->ndev);
+	if (rxcsum_done) {
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+		priv->estats.rx_hw_csum++;
+	} else {
+		skb->ip_summed = CHECKSUM_PARTIAL;
+	}
+
+	priv->ndev->stats.rx_packets++;
+	priv->ndev->stats.rx_bytes += frame_len;
+	priv->rx_skb[i] = NULL;
+
+	sun8i_emac_rx_skb(ndev, i);
+	napi_gro_receive(&priv->napi, skb);
+
+	return 0;
+	/* If the frame need to be dropped, we simply reuse the buffer */
+discard_frame:
+	ddesc->ctl = cpu_to_le32(DESC_BUF_MAX);
+	/* EMAC_COULD_BE_USED_BY_DMA must be the last value written */
+	wmb();
+	ddesc->status = EMAC_COULD_BE_USED_BY_DMA;
+	return 0;
+}
+
+/* Iterate over dma_desc for finding completed xmit.
+ *
+ * The problem is: how to know that a descriptor is sent and not just in
+ * preparation.
+ * Need to have status=0 and st set but this is the state of first frame just
+ * before setting the own-by-DMA bit.
+ * The solution is to used the artificial value DCLEAN.
+ */
+static int sun8i_emac_complete_xmit(struct net_device *ndev, int budget)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct dma_desc *ddesc;
+	int frame_len;
+	int work = 0;
+	unsigned int bytes_compl = 0, pkts_compl = 0;
+	u32 dstatus;
+
+	do {
+		ddesc = priv->dd_tx + priv->tx_dirty;
+
+		if (ddesc->status & EMAC_COULD_BE_USED_BY_DMA)
+			goto xmit_end;
+
+		if (ddesc->status == DCLEAN)
+			goto xmit_end;
+
+		dstatus = cpu_to_le32(ddesc->status);
+
+		if (ddesc->status == 0 && !ddesc->ctl) {
+			dev_err(priv->dev, "BUG: reached the void %d %d\n",
+				priv->tx_dirty, priv->tx_slot);
+			goto xmit_end;
+		}
+
+		/* TX_UNDERFLOW_ERR */
+		if (dstatus & BIT(1))
+			priv->ndev->stats.tx_errors++;
+		/* TX_DEFER_ERR */
+		if (dstatus & BIT(2))
+			priv->ndev->stats.tx_errors++;
+		/* BIT 6:3 numbers of collisions */
+		if (dstatus & 0x78)
+			priv->ndev->stats.collisions +=
+				(dstatus & 0x78) >> 3;
+		/* TX_COL_ERR_1 */
+		if (dstatus & BIT(8))
+			priv->ndev->stats.tx_errors++;
+		/* TX_COL_ERR_0 */
+		if (dstatus & BIT(9))
+			priv->ndev->stats.tx_errors++;
+		/* TX_CRS_ERR */
+		if (dstatus & BIT(10))
+			priv->ndev->stats.tx_carrier_errors++;
+		/* TX_PAYLOAD_ERR */
+		if (dstatus & BIT(12))
+			priv->ndev->stats.tx_errors++;
+		/* TX_LENGTH_ERR */
+		if (dstatus & BIT(14))
+			priv->ndev->stats.tx_errors++;
+		/* TX_HEADER_ERR */
+		if (dstatus & BIT(16))
+			priv->ndev->stats.tx_errors++;
+
+		frame_len = le32_to_cpu(ddesc->ctl) & 0x3FFF;
+		bytes_compl += frame_len;
+
+		if (priv->txl[priv->tx_dirty].map == MAP_SINGLE)
+			dma_unmap_single(priv->dev,
+					 le32_to_cpu(ddesc->buf_addr),
+					 frame_len, DMA_TO_DEVICE);
+		else
+			dma_unmap_page(priv->dev,
+				       le32_to_cpu(ddesc->buf_addr),
+				       frame_len, DMA_TO_DEVICE);
+		/* we can free skb only on last frame */
+		if (priv->txl[priv->tx_dirty].skb &&
+		    (ddesc->ctl & EMAC_DSC_TX_LAST)) {
+			dev_kfree_skb_irq(priv->txl[priv->tx_dirty].skb);
+			pkts_compl++;
+		}
+
+		priv->txl[priv->tx_dirty].skb = NULL;
+		priv->txl[priv->tx_dirty].map = 0;
+		ddesc->ctl = 0;
+		/* setting status to DCLEAN is the last value to be set */
+		wmb();
+		ddesc->status = DCLEAN;
+		work++;
+
+		rb_inc(&priv->tx_dirty, priv->nbdesc_tx);
+		ddesc = priv->dd_tx + priv->tx_dirty;
+	} while (ddesc->ctl &&
+		 !(ddesc->status & EMAC_COULD_BE_USED_BY_DMA) &&
+		 work < budget);
+
+xmit_end:
+	netdev_completed_queue(ndev, pkts_compl, bytes_compl);
+
+	/* if we don't have handled all packets */
+	if (work < budget)
+		work = 0;
+
+	if (netif_queue_stopped(ndev) &&
+	    rb_tx_numfreedesc(ndev) > MAX_SKB_FRAGS + 1)
+		netif_wake_queue(ndev);
+	return work;
+}
+
+static int sun8i_emac_poll(struct napi_struct *napi, int budget)
+{
+	struct sun8i_emac_priv *priv =
+		container_of(napi, struct sun8i_emac_priv, napi);
+	struct net_device *ndev = priv->ndev;
+	int worked;
+	struct dma_desc *ddesc;
+
+	priv->estats.napi_schedule++;
+	worked = sun8i_emac_complete_xmit(ndev, budget);
+
+	ddesc = priv->dd_rx + priv->rx_dirty;
+	while (!(ddesc->status & EMAC_COULD_BE_USED_BY_DMA) &&
+	       worked < budget) {
+		sun8i_emac_rx_from_ddesc(ndev, priv->rx_dirty);
+		worked++;
+		rb_inc(&priv->rx_dirty, priv->nbdesc_rx);
+		ddesc = priv->dd_rx + priv->rx_dirty;
+	};
+	if (worked < budget) {
+		priv->estats.napi_underflow++;
+		napi_complete(&priv->napi);
+		writel(EMAC_RX_INT | EMAC_TX_INT, priv->base + EMAC_INT_EN);
+	}
+	return worked;
+}
+
+static int sun8i_mdio_read(struct mii_bus *bus, int phy_addr, int phy_reg)
+{
+	struct net_device *ndev = bus->priv;
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	int err;
+	u32 reg;
+
+	err = readl_poll_timeout(priv->base + EMAC_MDIO_CMD, reg,
+				 !(reg & MDIO_CMD_MII_BUSY), 100, 10000);
+	if (err) {
+		dev_err(priv->dev, "%s timeout %x\n", __func__, reg);
+		return err;
+	}
+
+	reg &= ~MDIO_CMD_MII_WRITE;
+	reg &= ~MDIO_CMD_MII_PHY_REG_ADDR_MASK;
+	reg |= (phy_reg << MDIO_CMD_MII_PHY_REG_ADDR_SHIFT) &
+		MDIO_CMD_MII_PHY_REG_ADDR_MASK;
+
+	reg &= ~MDIO_CMD_MII_PHY_ADDR_MASK;
+
+	reg |= (phy_addr << MDIO_CMD_MII_PHY_ADDR_SHIFT) &
+		MDIO_CMD_MII_PHY_ADDR_MASK;
+
+	reg |= MDIO_CMD_MII_BUSY;
+
+	writel(reg, priv->base + EMAC_MDIO_CMD);
+
+	err = readl_poll_timeout(priv->base + EMAC_MDIO_CMD, reg,
+				 !(reg & MDIO_CMD_MII_BUSY), 100, 10000);
+
+	if (err) {
+		dev_err(priv->dev, "%s timeout %x\n", __func__, reg);
+		return err;
+	}
+
+	return readl(priv->base + EMAC_MDIO_DATA);
+}
+
+static int sun8i_mdio_write(struct mii_bus *bus, int phy_addr, int phy_reg,
+			    u16 data)
+{
+	struct net_device *ndev = bus->priv;
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	u32 reg;
+	int err;
+
+	err = readl_poll_timeout(priv->base + EMAC_MDIO_CMD, reg,
+				 !(reg & MDIO_CMD_MII_BUSY), 100, 10000);
+	if (err) {
+		dev_err(priv->dev, "%s timeout %x\n", __func__, reg);
+		return err;
+	}
+
+	reg &= ~MDIO_CMD_MII_PHY_REG_ADDR_MASK;
+	reg |= (phy_reg << MDIO_CMD_MII_PHY_REG_ADDR_SHIFT) &
+		MDIO_CMD_MII_PHY_REG_ADDR_MASK;
+
+	reg &= ~MDIO_CMD_MII_PHY_ADDR_MASK;
+	reg |= (phy_addr << MDIO_CMD_MII_PHY_ADDR_SHIFT) &
+		MDIO_CMD_MII_PHY_ADDR_MASK;
+
+	reg |= MDIO_CMD_MII_WRITE;
+	reg |= MDIO_CMD_MII_BUSY;
+
+	writel(reg, priv->base + EMAC_MDIO_CMD);
+	writel(data, priv->base + EMAC_MDIO_DATA);
+
+	err = readl_poll_timeout(priv->base + EMAC_MDIO_CMD, reg,
+				 !(reg & MDIO_CMD_MII_BUSY), 100, 10000);
+	if (err) {
+		dev_err(priv->dev, "%s timeout %x\n", __func__, reg);
+		return err;
+	}
+
+	return 0;
+}
+
+static int sun8i_emac_mdio_register(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct mii_bus *bus;
+	int ret;
+
+	bus = mdiobus_alloc();
+	if (!bus) {
+		netdev_err(ndev, "Failed to allocate a new mdio bus\n");
+		return -ENOMEM;
+	}
+
+	bus->name = dev_name(priv->dev);
+	bus->read = &sun8i_mdio_read;
+	bus->write = &sun8i_mdio_write;
+	snprintf(bus->id, MII_BUS_ID_SIZE, "%s-%x", bus->name, priv->dev->id);
+
+	bus->parent = priv->dev;
+	bus->priv = ndev;
+
+	ret = of_mdiobus_register(bus, priv->mdio_node);
+	if (ret) {
+		netdev_err(ndev, "Could not register a MDIO bus: %d\n", ret);
+		mdiobus_free(bus);
+		return ret;
+	}
+
+	priv->mdio = bus;
+
+	return 0;
+}
+
+static void sun8i_emac_mdio_unregister(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	mdiobus_unregister(priv->mdio);
+	mdiobus_free(priv->mdio);
+}
+
+/* Run within phydev->lock */
+static void sun8i_emac_adjust_link(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct phy_device *phydev = ndev->phydev;
+	int new_state = 0;
+
+	netif_dbg(priv, link, priv->ndev,
+		  "%s link=%x duplex=%x speed=%x\n", __func__,
+		  phydev->link, phydev->duplex, phydev->speed);
+	if (!phydev)
+		return;
+
+	if (phydev->link) {
+		if (phydev->duplex != priv->duplex) {
+			new_state = 1;
+			priv->duplex = phydev->duplex;
+		}
+		if (phydev->pause)
+			sun8i_emac_flow_ctrl(priv, phydev->duplex,
+					     priv->flow_ctrl);
+
+		if (phydev->speed != priv->speed) {
+			new_state = 1;
+			priv->speed = phydev->speed;
+		}
+
+		if (priv->link == 0) {
+			new_state = 1;
+			priv->link = phydev->link;
+		}
+
+		netif_dbg(priv, link, priv->ndev,
+			  "%s new=%d link=%d pause=%d\n",
+			  __func__, new_state, priv->link, phydev->pause);
+		if (new_state)
+			sun8i_emac_set_link_mode(priv);
+	} else if (priv->link != phydev->link) {
+		new_state = 1;
+		priv->link = 0;
+		priv->speed = 0;
+		priv->duplex = -1;
+	}
+
+	if (new_state)
+		phy_print_status(phydev);
+}
+
+/* H3 specific bits for EPHY */
+#define H3_EPHY_ADDR_SHIFT	20
+#define H3_EPHY_LED_POL		BIT(17) /* 1: active low, 0: active high */
+#define H3_EPHY_SHUTDOWN	BIT(16) /* 1: shutdown, 0: power up */
+#define H3_EPHY_SELECT		BIT(15) /* 1: internal PHY, 0: external PHY */
+
+/* H3/A64 specific bits */
+#define SYSCON_RMII_EN		BIT(13) /* 1: enable RMII (overrides EPIT) */
+
+/* Generic system control EMAC_CLK bits */
+#define SYSCON_ETXDC_MASK		GENMASK(2, 0)
+#define SYSCON_ETXDC_SHIFT		10
+#define SYSCON_ERXDC_MASK		GENMASK(4, 0)
+#define SYSCON_ERXDC_SHIFT		5
+/* EMAC PHY Interface Type */
+#define SYSCON_EPIT			BIT(2) /* 1: RGMII, 0: MII */
+#define SYSCON_ETCS_MASK		GENMASK(1, 0)
+#define SYSCON_ETCS_MII		0x0
+#define SYSCON_ETCS_EXT_GMII	0x1
+#define SYSCON_ETCS_INT_GMII	0x2
+#define SYSCON_EMAC_REG		0x30
+
+static int sun8i_emac_set_syscon(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct device_node *node = priv->dev->of_node;
+	int ret;
+	u32 reg, val;
+
+	reg = priv->variant->default_syscon_value;
+
+	if (priv->variant->internal_phy) {
+		if (!priv->use_internal_phy) {
+			/* switch to external PHY interface */
+			reg &= ~H3_EPHY_SELECT;
+		} else {
+			reg |= H3_EPHY_SELECT;
+			reg &= ~H3_EPHY_SHUTDOWN;
+
+			if (of_property_read_bool(priv->phy_node,
+						  "allwinner,leds-active-low"))
+				reg |= H3_EPHY_LED_POL;
+
+			ret = of_mdio_parse_addr(priv->dev, priv->phy_node);
+			if (ret < 0) {
+				netdev_err(ndev, "Could not parse MDIO addr\n");
+				return ret;
+			}
+			/* of_mdio_parse_addr returns a valid (0 ~ 31) PHY
+			 * address. No need to mask it again.
+			 */
+			reg |= ret << H3_EPHY_ADDR_SHIFT;
+		}
+	}
+
+	if (!of_property_read_u32(node, "allwinner,tx-delay", &val)) {
+		if (val <= SYSCON_ETXDC_MASK) {
+			reg &= ~(SYSCON_ETXDC_MASK << SYSCON_ETXDC_SHIFT);
+			reg |= (val << SYSCON_ETXDC_SHIFT);
+		} else {
+			netdev_warn(ndev, "Invalid TX clock delay: %d\n", val);
+		}
+	}
+
+	if (!of_property_read_u32(node, "allwinner,rx-delay", &val)) {
+		if (val <= SYSCON_ERXDC_MASK) {
+			reg &= ~(SYSCON_ERXDC_MASK << SYSCON_ERXDC_SHIFT);
+			reg |= (val << SYSCON_ERXDC_SHIFT);
+		} else {
+			netdev_warn(ndev, "Invalid RX clock delay: %d\n", val);
+		}
+	}
+
+	/* Clear interface mode bits */
+	reg &= ~(SYSCON_ETCS_MASK | SYSCON_EPIT);
+	if (priv->variant->support_rmii)
+		reg &= ~SYSCON_RMII_EN;
+
+	switch (priv->phy_interface) {
+	case PHY_INTERFACE_MODE_MII:
+		/* default */
+		break;
+	case PHY_INTERFACE_MODE_RGMII:
+		reg |= SYSCON_EPIT | SYSCON_ETCS_INT_GMII;
+		break;
+	case PHY_INTERFACE_MODE_RMII:
+		reg |= SYSCON_RMII_EN | SYSCON_ETCS_EXT_GMII;
+		break;
+	default:
+		netdev_err(ndev, "Unsupported interface mode: %s",
+			   phy_modes(priv->phy_interface));
+		return -EINVAL;
+	}
+
+	regmap_write(priv->regmap, SYSCON_EMAC_REG, reg);
+
+	return 0;
+}
+
+static void sun8i_emac_unset_syscon(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	u32 reg = priv->variant->default_syscon_value;
+
+	regmap_write(priv->regmap, SYSCON_EMAC_REG, reg);
+}
+
+/* Set Management Data Clock, must be call after device reset */
+static void sun8i_emac_set_mdc(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	unsigned long rate;
+	u32 reg;
+
+	rate = clk_get_rate(priv->ahb_clk);
+	if (rate > 160000000)
+		reg = 0x3 << 20; /* AHB / 128 */
+	else if (rate > 80000000)
+		reg = 0x2 << 20; /* AHB / 64 */
+	else if (rate > 40000000)
+		reg = 0x1 << 20; /* AHB / 32 */
+	else
+		reg = 0x0 << 20; /* AHB / 16 */
+	netif_dbg(priv, link, ndev, "MDC auto : %x\n", reg);
+	writel(reg, priv->base + EMAC_MDIO_CMD);
+}
+
+/* "power" the device, by enabling clk/reset/regulators */
+static int sun8i_emac_power(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	int ret;
+
+	ret = clk_prepare_enable(priv->ahb_clk);
+	if (ret) {
+		netdev_err(ndev, "Could not enable AHB clock\n");
+		return ret;
+	}
+
+	if (priv->rst_mac) {
+		ret = reset_control_deassert(priv->rst_mac);
+		if (ret) {
+			netdev_err(ndev, "Could not deassert reset\n");
+			goto err_reset;
+		}
+	}
+
+	if (priv->ephy_clk) {
+		ret = clk_prepare_enable(priv->ephy_clk);
+		if (ret) {
+			netdev_err(ndev, "Could not enable EPHY clock\n");
+			goto err_ephy_clk;
+		}
+	}
+
+	if (priv->rst_ephy) {
+		ret = reset_control_deassert(priv->rst_ephy);
+		if (ret) {
+			netdev_err(ndev, "Could not deassert EPHY reset\n");
+			goto err_ephy_reset;
+		}
+	}
+
+	return 0;
+
+err_ephy_reset:
+	if (priv->ephy_clk)
+		clk_disable_unprepare(priv->ephy_clk);
+err_ephy_clk:
+	if (priv->rst_mac)
+		reset_control_assert(priv->rst_mac);
+err_reset:
+	clk_disable_unprepare(priv->ahb_clk);
+	return ret;
+}
+
+/* "Unpower" the device, disabling clocks and regulators, asserting reset */
+static void sun8i_emac_unpower(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	if (priv->rst_ephy)
+		reset_control_assert(priv->rst_ephy);
+
+	if (priv->ephy_clk)
+		clk_disable_unprepare(priv->ephy_clk);
+
+	if (priv->rst_mac)
+		reset_control_assert(priv->rst_mac);
+
+	clk_disable_unprepare(priv->ahb_clk);
+}
+
+static int sun8i_emac_init(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct device_node *node = priv->dev->of_node;
+	const u8 *addr;
+
+	/* Try to get MAC address from DT, or assign a random one */
+	addr = of_get_mac_address(node);
+	if (addr)
+		ether_addr_copy(ndev->dev_addr, addr);
+	else
+		eth_hw_addr_random(ndev);
+
+	return 0;
+}
+
+static int sun8i_emac_mdio_probe(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct phy_device *phydev = NULL;
+
+	phydev = of_phy_connect(ndev, priv->phy_node, &sun8i_emac_adjust_link,
+				0, priv->phy_interface);
+
+	if (!phydev) {
+		netdev_err(ndev, "Could not attach to PHY\n");
+		return -ENODEV;
+	}
+
+	phy_attached_info(phydev);
+
+	/* mask with MAC supported features */
+	phydev->supported &= PHY_GBIT_FEATURES;
+	phydev->advertising = phydev->supported;
+
+	priv->link = 0;
+	priv->speed = 0;
+	priv->duplex = -1;
+
+	return 0;
+}
+
+/* Allocate both RX and TX ring buffer and init them
+ * This function also write the startbase of thoses ring in the device.
+ * All structures that help managing thoses rings are also handled
+ * by this functions (rx_skb/txl)
+ */
+static int sun8i_emac_alloc_rings(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct dma_desc *ddesc;
+	int err, i;
+
+	priv->rx_skb = kcalloc(priv->nbdesc_rx, sizeof(struct sk_buff *),
+			      GFP_KERNEL);
+	if (!priv->rx_skb) {
+		err = -ENOMEM;
+		goto rx_skb_error;
+	}
+	priv->txl = kcalloc(priv->nbdesc_tx, sizeof(struct txinfo), GFP_KERNEL);
+	if (!priv->txl) {
+		err = -ENOMEM;
+		goto tx_error;
+	}
+
+	/* allocate/init RX ring */
+	priv->dd_rx = dma_zalloc_coherent(priv->dev,
+			priv->nbdesc_rx * sizeof(struct dma_desc),
+			&priv->dd_rx_phy, GFP_KERNEL);
+	if (!priv->dd_rx) {
+		dev_err(priv->dev, "ERROR: cannot allocate DMA RX buffer");
+		err = -ENOMEM;
+		goto dma_rx_error;
+	}
+	ddesc = priv->dd_rx;
+	for (i = 0; i < priv->nbdesc_rx; i++) {
+		sun8i_emac_rx_skb(ndev, i);
+		ddesc->next = cpu_to_le32(priv->dd_rx_phy + (i + 1)
+			* sizeof(struct dma_desc));
+		ddesc++;
+	}
+	/* last descriptor point back to first one */
+	ddesc--;
+	ddesc->next = cpu_to_le32(priv->dd_rx_phy);
+
+	/* allocate/init TX ring */
+	priv->dd_tx = dma_zalloc_coherent(priv->dev,
+			priv->nbdesc_tx * sizeof(struct dma_desc),
+			&priv->dd_tx_phy, GFP_KERNEL);
+	if (!priv->dd_tx) {
+		dev_err(priv->dev, "ERROR: cannot allocate DMA TX buffer");
+		err = -ENOMEM;
+		goto dma_tx_error;
+	}
+	ddesc = priv->dd_tx;
+	for (i = 0; i < priv->nbdesc_tx; i++) {
+		ddesc->status = DCLEAN;
+		ddesc->ctl = 0;
+		ddesc->next = cpu_to_le32(priv->dd_tx_phy + (i + 1)
+			* sizeof(struct dma_desc));
+		ddesc++;
+	}
+	/* last descriptor point back to first one */
+	ddesc--;
+	ddesc->next = cpu_to_le32(priv->dd_tx_phy);
+	i--;
+
+	priv->tx_slot = 0;
+	priv->tx_dirty = 0;
+	priv->rx_dirty = 0;
+
+	/* write start of RX ring descriptor */
+	writel(priv->dd_rx_phy, priv->base + EMAC_RX_DESC_LIST);
+	/* write start of TX ring descriptor */
+	writel(priv->dd_tx_phy, priv->base + EMAC_TX_DESC_LIST);
+
+	return 0;
+dma_tx_error:
+	dma_free_coherent(priv->dev, priv->nbdesc_rx * sizeof(struct dma_desc),
+			  priv->dd_rx, priv->dd_rx_phy);
+dma_rx_error:
+	kfree(priv->txl);
+tx_error:
+	kfree(priv->rx_skb);
+rx_skb_error:
+	return err;
+}
+
+static int sun8i_emac_open(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	int err;
+	u32 v;
+
+	err = sun8i_emac_power(ndev);
+	if (err)
+		return err;
+
+	err = request_irq(priv->irq, sun8i_emac_dma_interrupt, 0,
+			  dev_name(priv->dev), ndev);
+	if (err) {
+		dev_err(priv->dev, "Cannot request IRQ: %d\n", err);
+		goto err_power;
+	}
+
+	/* Set interface mode (and configure internal PHY on H3) */
+	err = sun8i_emac_set_syscon(ndev);
+	if (err)
+		goto err_irq;
+
+	/* Do SOFT RST */
+	v = readl(priv->base + EMAC_BASIC_CTL1);
+	writel(v | 0x01, priv->base + EMAC_BASIC_CTL1);
+
+	err = readl_poll_timeout(priv->base + EMAC_BASIC_CTL1, v,
+				 !(v & 0x01), 100, 10000);
+	if (err) {
+		dev_err(priv->dev, "EMAC reset timeout\n");
+		err = -EFAULT;
+		goto err_syscon;
+	}
+
+	sun8i_emac_set_mdc(ndev);
+
+	err = sun8i_emac_mdio_register(ndev);
+	if (err)
+		goto err_syscon;
+
+	err = sun8i_emac_mdio_probe(ndev);
+	if (err)
+		goto err_syscon;
+
+	/* DMA */
+	v = (8 << 24);/* burst len */
+	writel(v, priv->base + EMAC_BASIC_CTL1);
+
+	writel(EMAC_RX_INT | EMAC_TX_INT, priv->base + EMAC_INT_EN);
+
+	v = readl(priv->base + EMAC_RX_CTL0);
+	/* CHECK_CRC */
+	if (ndev->features & NETIF_F_RXCSUM)
+		v |= EMAC_RX_DO_CRC;
+	else
+		v &= ~EMAC_RX_DO_CRC;
+	/* STRIP_FCS */
+	if (ndev->features & NETIF_F_RXFCS)
+		v &= ~EMAC_RX_STRIP_FCS;
+	else
+		v |= EMAC_RX_STRIP_FCS;
+	writel(v, priv->base + EMAC_RX_CTL0);
+
+	v = readl(priv->base + EMAC_TX_CTL1);
+	/* TX_MD Transmission starts after a full frame located in TX DMA FIFO*/
+	v |= BIT(1);
+	/* Undocumented bit (called TX_NEXT_FRM in BSP), the original comment is
+	 * "Operating on second frame increase the performance
+	 * especially when transmit store-and-forward is used."
+	 */
+	v |= BIT(2);
+	writel(v, priv->base + EMAC_TX_CTL1);
+
+	v = readl(priv->base + EMAC_RX_CTL1);
+	/* RX_MD RX DMA reads data from RX DMA FIFO to host memory after a
+	 * complete frame has been written to RX DMA FIFO
+	*/
+	v |= BIT(1);
+	writel(v, priv->base + EMAC_RX_CTL1);
+
+	sun8i_emac_set_macaddr(priv, ndev->dev_addr, 0);
+
+	err = sun8i_emac_alloc_rings(ndev);
+	if (err) {
+		netdev_err(ndev, "Fail to allocate rings\n");
+		goto err_mdio;
+	}
+
+	phy_start(ndev->phydev);
+
+	sun8i_emac_start_rx(ndev);
+	sun8i_emac_start_tx(ndev);
+
+	netif_napi_add(ndev, &priv->napi, sun8i_emac_poll, 64);
+	napi_enable(&priv->napi);
+	netif_start_queue(ndev);
+
+	return 0;
+err_mdio:
+	phy_disconnect(ndev->phydev);
+err_syscon:
+	sun8i_emac_unset_syscon(ndev);
+err_irq:
+	free_irq(priv->irq, ndev);
+err_power:
+	sun8i_emac_unpower(ndev);
+	return err;
+}
+
+/* Clean the TX ring of any accepted skb for xmit */
+static void sun8i_emac_tx_clean(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	int i;
+	struct dma_desc *ddesc;
+	int frame_len;
+
+	for (i = 0; i < priv->nbdesc_tx; i++) {
+		if (priv->txl[i].skb) {
+			ddesc = priv->dd_tx + i;
+			frame_len = le32_to_cpu(ddesc->ctl) & 0x3FFF;
+			switch (priv->txl[i].map) {
+			case MAP_SINGLE:
+				dma_unmap_single(priv->dev,
+						 le32_to_cpu(ddesc->buf_addr),
+						 frame_len, DMA_TO_DEVICE);
+				break;
+			case MAP_PAGE:
+				dma_unmap_page(priv->dev,
+					       le32_to_cpu(ddesc->buf_addr),
+					       frame_len, DMA_TO_DEVICE);
+				break;
+			default:
+				dev_err(priv->dev, "Trying to free an empty slot\n");
+				continue;
+			}
+			dev_kfree_skb_any(priv->txl[i].skb);
+			priv->txl[i].skb = NULL;
+			ddesc->ctl = 0;
+			ddesc->status = DCLEAN;
+		}
+	}
+	priv->tx_slot = 0;
+	priv->tx_dirty = 0;
+}
+
+/* Clean the RX ring */
+static void sun8i_emac_rx_clean(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	int i;
+	struct dma_desc *ddesc;
+
+	/* clean RX ring */
+	for (i = 0; i < priv->nbdesc_rx; i++)
+		if (priv->rx_skb[i]) {
+			ddesc = priv->dd_rx + i;
+			dma_unmap_single(priv->dev,
+					 le32_to_cpu(ddesc->buf_addr),
+					 DESC_BUF_MAX, DMA_FROM_DEVICE);
+			dev_kfree_skb_any(priv->rx_skb[i]);
+			priv->rx_skb[i] = NULL;
+		}
+}
+
+static int sun8i_emac_stop(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	napi_disable(&priv->napi);
+
+	sun8i_emac_stop_tx(ndev);
+	sun8i_emac_stop_rx(ndev);
+
+	phy_stop(ndev->phydev);
+	phy_disconnect(ndev->phydev);
+
+	sun8i_emac_mdio_unregister(ndev);
+
+	sun8i_emac_unset_syscon(ndev);
+
+	free_irq(priv->irq, ndev);
+
+	sun8i_emac_rx_clean(ndev);
+	sun8i_emac_tx_clean(ndev);
+
+	kfree(priv->rx_skb);
+	kfree(priv->txl);
+
+	dma_free_coherent(priv->dev, priv->nbdesc_rx * sizeof(struct dma_desc),
+			  priv->dd_rx, priv->dd_rx_phy);
+	dma_free_coherent(priv->dev, priv->nbdesc_tx * sizeof(struct dma_desc),
+			  priv->dd_tx, priv->dd_tx_phy);
+
+	sun8i_emac_unpower(ndev);
+
+	return 0;
+}
+
+static netdev_tx_t sun8i_emac_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct dma_desc *ddesc;
+	struct dma_desc *first;
+	int i = 0, rbd_first;
+	unsigned int len, fraglen, tlen;
+	u32 v;
+	int n;
+	int nf;
+	const skb_frag_t *frag;
+	int do_csum = 0;
+
+	if (skb_put_padto(skb, ETH_ZLEN))
+		return NETDEV_TX_OK;
+	len = skb_headlen(skb);
+
+	n = skb_shinfo(skb)->nr_frags;
+
+	if (skb->ip_summed == CHECKSUM_PARTIAL) {
+		do_csum = 1;
+		priv->estats.tx_hw_csum++;
+	}
+	netif_dbg(priv, tx_queued, ndev, "%s len=%u skblen=%u %x\n", __func__,
+		  len, skb->len,
+		  (skb->ip_summed == CHECKSUM_PARTIAL));
+
+	/* check for contigous space
+	 * We need at least 1(skb->data) + n(numfrags) + 1(one clean slot)
+	 */
+	if (rb_tx_numfreedesc(ndev) < n + 2) {
+		dev_err_ratelimited(priv->dev, "BUG!: TX is full %d %d\n",
+				    priv->tx_dirty, priv->tx_slot);
+		netif_stop_queue(ndev);
+		return NETDEV_TX_BUSY;
+	}
+	i = priv->tx_slot;
+
+	ddesc = priv->dd_tx + i;
+	first = priv->dd_tx + i;
+	rbd_first = i;
+
+	ddesc->buf_addr = dma_map_single(priv->dev, skb->data, len,
+					 DMA_TO_DEVICE);
+	if (dma_mapping_error(priv->dev, ddesc->buf_addr)) {
+		dev_err(priv->dev, "ERROR: Cannot map buffer for DMA\n");
+		goto xmit_error;
+	}
+	/* We cannot direcly use cpu_to_le32() after dma_map_single
+	 * since dma_mapping_error use it
+	 */
+	ddesc->buf_addr = cpu_to_le32(ddesc->buf_addr);
+	priv->txl[i].map = MAP_SINGLE;
+	priv->txl[i].skb = skb;
+
+	tlen = len;
+	ddesc->ctl = le32_to_cpu(len);
+	/* Undocumented bit that make it works
+	 * Without it, packets never be sent on H3 SoC
+	 */
+	ddesc->ctl |= EMAC_MAGIC_TX_BIT;
+	if (do_csum)
+		ddesc->ctl |= EMAC_TX_DO_CRC;
+
+	/* handle fragmented skb, one descriptor per fragment  */
+	for (nf = 0; nf < n; nf++) {
+		frag = &skb_shinfo(skb)->frags[nf];
+		rb_inc(&i, priv->nbdesc_tx);
+		priv->txl[i].skb = skb;
+		ddesc = priv->dd_tx + i;
+		fraglen = skb_frag_size(frag);
+		ddesc->ctl = le32_to_cpu(fraglen);
+		tlen += fraglen,
+		ddesc->ctl |= EMAC_MAGIC_TX_BIT;
+		if (do_csum)
+			ddesc->ctl |= EMAC_TX_DO_CRC;
+
+		ddesc->buf_addr = skb_frag_dma_map(priv->dev, frag, 0,
+				fraglen, DMA_TO_DEVICE);
+		if (dma_mapping_error(priv->dev, ddesc->buf_addr)) {
+			dev_err(priv->dev, "Cannot map buffer for DMA\n");
+			goto xmit_error;
+		}
+		/* Cannot directly use cpu_to_le32() after skb_frag_dma_map
+		 * since dma_mapping_error use it
+		 */
+		ddesc->buf_addr = cpu_to_le32(ddesc->buf_addr);
+		priv->txl[i].map = MAP_PAGE;
+		ddesc->status = EMAC_COULD_BE_USED_BY_DMA;
+	}
+
+	/* frame end */
+	ddesc->ctl |= EMAC_DSC_TX_LAST;
+	/* We want an interrupt after transmission */
+	ddesc->ctl |= EMAC_WANT_INT;
+
+	rb_inc(&i, priv->nbdesc_tx);
+
+	/* This line was previously after DMA start, but with that we hit a
+	 * small race with complete_xmit() where we complete more data than
+	 * sent.
+	 * The packet is sent just after EMAC_COULD_BE_USED_BY_DMA flag set and
+	 * complete_xmit fire just after before netdev_sent_queue().
+	 * This race could be observed only when overflowing a gigabit line.
+	 */
+	netdev_sent_queue(ndev, skb->len);
+
+	/* frame begin */
+	first->ctl |= EMAC_DSC_TX_FIRST;
+	wmb();/* EMAC_COULD_BE_USED_BY_DMA must be the last value written */
+	first->status = EMAC_COULD_BE_USED_BY_DMA;
+	priv->tx_slot = i;
+
+	/* Trying to optimize this (recording DMA start/stop) seems
+	 * to lead to errors. So we always start DMA.
+	 */
+	v = readl(priv->base + EMAC_TX_CTL1);
+	v |= EMAC_TX_DMA_START;
+	v |= EMAC_TX_DMA_EN;
+	writel_relaxed(v, priv->base + EMAC_TX_CTL1);
+
+	if (rb_tx_numfreedesc(ndev) < MAX_SKB_FRAGS + 1) {
+		netif_stop_queue(ndev);
+		priv->estats.tx_stop_queue++;
+	}
+	priv->estats.tx_used_desc = rb_tx_numfreedesc(ndev);
+	priv->ndev->stats.tx_packets++;
+	priv->ndev->stats.tx_bytes += tlen;
+
+	return NETDEV_TX_OK;
+
+xmit_error:
+	/* destroy skb and return TX OK Documentation/DMA-API-HOWTO.txt */
+	/* clean descritors from rbd_first to i */
+	ddesc->ctl = 0;
+	/* setting status to DCLEAN is the last value to be set */
+	wmb();
+	ddesc->status = DCLEAN;
+	do {
+		ddesc = priv->dd_tx + rbd_first;
+		ddesc->ctl = 0;
+		/* setting status to DCLEAN is the last value to be set */
+		wmb();
+		ddesc->status = DCLEAN;
+		rb_inc(&rbd_first, priv->nbdesc_tx);
+	} while (rbd_first != i);
+	dev_kfree_skb_any(skb);
+	return NETDEV_TX_OK;
+}
+
+static int sun8i_emac_change_mtu(struct net_device *ndev, int new_mtu)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	int max_mtu;
+
+	dev_info(priv->dev, "%s set MTU to %d\n", __func__, new_mtu);
+
+	if (netif_running(ndev)) {
+		dev_err(priv->dev, "%s: must be stopped to change its MTU\n",
+			ndev->name);
+		return -EBUSY;
+	}
+
+	max_mtu = SKB_MAX_HEAD(NET_SKB_PAD + NET_IP_ALIGN);
+
+	if ((new_mtu < 68) || (new_mtu > max_mtu)) {
+		dev_err(priv->dev, "%s: invalid MTU, max MTU is: %d\n",
+			ndev->name, max_mtu);
+		return -EINVAL;
+	}
+
+	ndev->mtu = new_mtu;
+	netdev_update_features(ndev);
+	return 0;
+}
+
+static int sun8i_emac_set_features(struct net_device *ndev,
+				   netdev_features_t features)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	u32 v;
+
+	v = readl(priv->base + EMAC_BASIC_CTL0);
+	if (features & NETIF_F_LOOPBACK && netif_running(ndev)) {
+		netif_info(priv, hw, ndev, "Set loopback features");
+		v |= BIT(1);
+	} else {
+		netif_info(priv, hw, ndev, "Unset loopback features");
+		v &= ~BIT(1);
+	}
+	writel(v, priv->base + EMAC_BASIC_CTL0);
+
+	v = readl(priv->base + EMAC_RX_CTL0);
+	if (features & NETIF_F_RXCSUM) {
+		v |= EMAC_RX_DO_CRC;
+		netif_info(priv, hw, ndev, "Doing RX CRC check by hardware");
+	} else {
+		v &= ~EMAC_RX_DO_CRC;
+		netif_info(priv, hw, ndev, "No RX CRC check by hardware");
+	}
+	if (features & NETIF_F_RXFCS) {
+		v &= ~EMAC_RX_STRIP_FCS;
+		netif_info(priv, hw, ndev, "Keep FCS");
+	} else {
+		v |= EMAC_RX_STRIP_FCS;
+		netif_info(priv, hw, ndev, "Strip FCS");
+	}
+	writel(v, priv->base + EMAC_RX_CTL0);
+
+	netif_dbg(priv, drv, ndev, "%s %llx %x\n", __func__, features, v);
+
+	return 0;
+}
+
+static void sun8i_emac_set_rx_mode(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	u32 v = 0;
+	int i = 0;
+	struct netdev_hw_addr *ha;
+
+	/* Receive all multicast frames */
+	v |= BIT(16);
+	/* Receive all control frames */
+	v |= BIT(13);
+	if (ndev->flags & IFF_PROMISC)
+		v |= BIT(1);
+	if (netdev_uc_count(ndev) > 7) {
+		v |= BIT(1);
+	} else {
+		netdev_for_each_uc_addr(ha, ndev) {
+			i++;
+			sun8i_emac_set_macaddr(priv, ha->addr, i);
+		}
+	}
+	writel(v, priv->base + EMAC_RX_FRM_FLT);
+}
+
+static void sun8i_emac_tx_timeout(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	netdev_err(ndev, "%s\n", __func__);
+
+	sun8i_emac_stop_tx(ndev);
+
+	sun8i_emac_tx_clean(ndev);
+
+	/* write start of the new TX ring descriptor */
+	writel(priv->dd_tx_phy, priv->base + EMAC_TX_DESC_LIST);
+
+	sun8i_emac_start_tx(ndev);
+
+	netdev_reset_queue(ndev);
+
+	priv->estats.tx_timeout++;
+	ndev->stats.tx_errors++;
+	netif_wake_queue(ndev);
+}
+
+static int sun8i_emac_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd)
+{
+	struct phy_device *phydev = ndev->phydev;
+
+	if (!netif_running(ndev))
+		return -EINVAL;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_mii_ioctl(phydev, rq, cmd);
+}
+
+static int sun8i_emac_check_if_running(struct net_device *ndev)
+{
+	if (!netif_running(ndev))
+		return -EINVAL;
+	return 0;
+}
+
+static int sun8i_emac_get_sset_count(struct net_device *ndev, int sset)
+{
+	switch (sset) {
+	case ETH_SS_STATS:
+		return ARRAY_SIZE(estats_str);
+	}
+	return -EOPNOTSUPP;
+}
+
+static int sun8i_emac_ethtool_get_settings(struct net_device *ndev,
+					   struct ethtool_cmd *cmd)
+{
+	struct phy_device *phy = ndev->phydev;
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	if (!phy) {
+		netdev_err(ndev, "%s: %s: PHY is not registered\n",
+			   __func__, ndev->name);
+		return -ENODEV;
+	}
+
+	if (!netif_running(ndev)) {
+		dev_err(priv->dev, "interface disabled: we cannot track link speed / duplex setting\n");
+		return -EBUSY;
+	}
+
+	return phy_ethtool_gset(phy, cmd);
+}
+
+static int sun8i_emac_ethtool_set_settings(struct net_device *ndev,
+					   struct ethtool_cmd *cmd)
+{
+	struct phy_device *phy = ndev->phydev;
+
+	return phy_ethtool_sset(phy, cmd);
+}
+
+static void sun8i_emac_ethtool_getdrvinfo(struct net_device *ndev,
+					  struct ethtool_drvinfo *info)
+{
+	strlcpy(info->driver, "sun8i_emac", sizeof(info->driver));
+	strcpy(info->version, "00");
+	info->fw_version[0] = '\0';
+}
+
+static void sun8i_emac_ethtool_stats(struct net_device *ndev,
+				     struct ethtool_stats *dummy, u64 *data)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	memcpy(data, &priv->estats,
+	       sun8i_emac_get_sset_count(ndev, ETH_SS_STATS) * sizeof(u64));
+}
+
+static void sun8i_emac_ethtool_strings(struct net_device *dev, u32 stringset,
+				       u8 *buffer)
+{
+	switch (stringset) {
+	case ETH_SS_STATS:
+		memcpy(buffer, &estats_str, sizeof(estats_str));
+		break;
+	}
+}
+
+static u32 sun8i_emac_ethtool_getmsglevel(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	return priv->msg_enable;
+}
+
+static void sun8i_emac_ethtool_setmsglevel(struct net_device *ndev, u32 level)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	priv->msg_enable = level;
+}
+
+static void sun8i_emac_get_pauseparam(struct net_device *ndev,
+				      struct ethtool_pauseparam *pause)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	pause->rx_pause = 0;
+	pause->tx_pause = 0;
+	pause->autoneg = ndev->phydev->autoneg;
+
+	if (priv->flow_ctrl & EMAC_FLOW_RX)
+		pause->rx_pause = 1;
+	if (priv->flow_ctrl & EMAC_FLOW_TX)
+		pause->tx_pause = 1;
+}
+
+static int sun8i_emac_set_pauseparam(struct net_device *ndev,
+				     struct ethtool_pauseparam *pause)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct phy_device *phy = ndev->phydev;
+	int new_pause = 0;
+	int ret = 0;
+
+	if (pause->rx_pause)
+		new_pause |= EMAC_FLOW_RX;
+	if (pause->tx_pause)
+		new_pause |= EMAC_FLOW_TX;
+
+	priv->flow_ctrl = new_pause;
+	phy->autoneg = pause->autoneg;
+
+	if (phy->autoneg) {
+		if (netif_running(ndev))
+			ret = phy_start_aneg(phy);
+	} else {
+		sun8i_emac_flow_ctrl(priv, phy->duplex, priv->flow_ctrl);
+	}
+	return ret;
+}
+
+static void sun8i_emac_ethtool_get_ringparam(struct net_device *ndev,
+					     struct ethtool_ringparam *ring)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	ring->rx_pending = priv->nbdesc_rx;
+	ring->tx_pending = priv->nbdesc_tx;
+}
+
+static int sun8i_emac_ethtool_set_ringparam(struct net_device *ndev,
+					    struct ethtool_ringparam *ring)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	int err;
+
+	if (ring->rx_max_pending || ring->rx_mini_max_pending ||
+	    ring->rx_jumbo_max_pending || ring->rx_mini_pending ||
+	    ring->rx_jumbo_pending || ring->tx_max_pending)
+		return -EINVAL;
+
+	if (ring->tx_pending < MAX_SKB_FRAGS + 1) {
+		netdev_err(ndev, "The number of TX descriptors is too low");
+		return -EINVAL;
+	}
+
+	sun8i_emac_stop_tx(ndev);
+	sun8i_emac_stop_rx(ndev);
+
+	sun8i_emac_rx_clean(ndev);
+	sun8i_emac_tx_clean(ndev);
+
+	kfree(priv->rx_skb);
+	kfree(priv->txl);
+
+	dma_free_coherent(priv->dev, priv->nbdesc_rx * sizeof(struct dma_desc),
+			  priv->dd_rx, priv->dd_rx_phy);
+	dma_free_coherent(priv->dev, priv->nbdesc_tx * sizeof(struct dma_desc),
+			  priv->dd_tx, priv->dd_tx_phy);
+
+	priv->nbdesc_rx = ring->rx_pending;
+	priv->nbdesc_tx = ring->tx_pending;
+	err = sun8i_emac_alloc_rings(ndev);
+	if (err) {
+		/* Fatal error, we cannot re start */
+		netdev_err(ndev, "Fail to allocate rings\n");
+		return -EFAULT;
+	}
+
+	sun8i_emac_start_rx(ndev);
+	sun8i_emac_start_tx(ndev);
+
+	netif_start_queue(ndev);
+
+	netdev_info(ndev, "Ring Param settings: rx: %d, tx %d\n",
+		    ring->rx_pending, ring->tx_pending);
+	return 0;
+}
+
+static const struct ethtool_ops sun8i_emac_ethtool_ops = {
+	.begin = sun8i_emac_check_if_running,
+	.get_settings = sun8i_emac_ethtool_get_settings,
+	.set_settings = sun8i_emac_ethtool_set_settings,
+	.get_link = ethtool_op_get_link,
+	.get_pauseparam = sun8i_emac_get_pauseparam,
+	.set_pauseparam = sun8i_emac_set_pauseparam,
+	.get_ethtool_stats = sun8i_emac_ethtool_stats,
+	.get_strings = sun8i_emac_ethtool_strings,
+	.get_sset_count = sun8i_emac_get_sset_count,
+	.get_drvinfo = sun8i_emac_ethtool_getdrvinfo,
+	.get_msglevel = sun8i_emac_ethtool_getmsglevel,
+	.set_msglevel = sun8i_emac_ethtool_setmsglevel,
+	.get_ringparam = sun8i_emac_ethtool_get_ringparam,
+	.set_ringparam = sun8i_emac_ethtool_set_ringparam,
+};
+
+static const struct net_device_ops sun8i_emac_netdev_ops = {
+	.ndo_init = sun8i_emac_init,
+	.ndo_open = sun8i_emac_open,
+	.ndo_start_xmit = sun8i_emac_xmit,
+	.ndo_stop = sun8i_emac_stop,
+	.ndo_change_mtu = sun8i_emac_change_mtu,
+	.ndo_set_features = sun8i_emac_set_features,
+	.ndo_set_rx_mode = sun8i_emac_set_rx_mode,
+	.ndo_tx_timeout = sun8i_emac_tx_timeout,
+	.ndo_do_ioctl = sun8i_emac_ioctl,
+	.ndo_set_mac_address = eth_mac_addr,
+};
+
+/* No locking in this function since it is guaranteed to be run once and
+ * do actions only done here:
+ * - Scheduling NAPI
+ * - Stopping interrupts
+ * - Updating stats
+ *
+ * Even when not enabled via EMAC_INT_EN, some interrupt could fire, so we need
+ * to handle all of them.
+ * Interrupts know to fire when not enabled are:
+ * - EMAC_TX_DMA_STOP_INT
+ * - EMAC_TX_BUF_UA_INT
+ * - EMAC_TX_EARLY_INT
+ * - EMAC_RX_BUF_UA_INT
+ * - EMAC_RX_EARLY_INT
+ */
+static irqreturn_t sun8i_emac_dma_interrupt(int irq, void *dev_id)
+{
+	struct net_device *ndev = dev_id;
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	u32 v, u;
+
+	v = readl(priv->base + EMAC_INT_STA);
+
+	/* When this bit is asserted, a frame transmission is completed. */
+	if (v & EMAC_TX_INT) {
+		priv->estats.tx_int++;
+		writel(0, priv->base + EMAC_INT_EN);
+		napi_schedule(&priv->napi);
+	}
+
+	/* When this bit is asserted, the TX DMA FSM is stopped.
+	 * For the moment only a call to tx_timeout cause this interrupt
+	 * to fire.
+	 */
+	if (v & EMAC_TX_DMA_STOP_INT)
+		priv->estats.tx_dma_stop++;
+
+	/* When this asserted, the TX DMA can not acquire next TX descriptor
+	 * and TX DMA FSM is suspended.
+	*/
+	if (v & EMAC_TX_BUF_UA_INT) {
+		priv->estats.tx_dma_ua++;
+		writel(0, priv->base + EMAC_INT_EN);
+		napi_schedule(&priv->napi);
+	}
+
+	if (v & EMAC_TX_TIMEOUT_INT)
+		priv->estats.tx_timeout_int++;
+
+	if (v & EMAC_TX_UNDERFLOW_INT)
+		priv->estats.tx_underflow_int++;
+
+	/* When this bit asserted , the frame is transmitted to FIFO totally. */
+	if (v & EMAC_TX_EARLY_INT)
+		priv->estats.tx_early_int++;
+
+	/* When this bit is asserted, a frame reception is completed  */
+	if (v & EMAC_RX_INT) {
+		priv->estats.rx_int++;
+		writel(0, priv->base + EMAC_INT_EN);
+		napi_schedule(&priv->napi);
+	}
+
+	/* When this asserted, the RX DMA can not acquire next RX descriptor
+	 * and RX DMA FSM is suspended.
+	*/
+	if (v & EMAC_RX_BUF_UA_INT) {
+		u = readl(priv->base + EMAC_RX_CTL1);
+		writel(u | EMAC_RX_DMA_START, priv->base + EMAC_RX_CTL1);
+		priv->estats.rx_dma_ua++;
+	}
+
+	/* Same as TX DMA STOP, but never hit it */
+	if (v & EMAC_RX_DMA_STOP_INT)
+		priv->estats.rx_dma_stop++;
+
+	if (v & EMAC_RX_TIMEOUT_INT)
+		priv->estats.rx_timeout_int++;
+
+	if (v & EMAC_RX_OVERFLOW_INT)
+		priv->estats.rx_overflow_int++;
+
+	if (v & EMAC_RX_EARLY_INT)
+		priv->estats.rx_early_int++;
+
+	if (v & EMAC_RGMII_STA_INT)
+		priv->estats.rgmii_state_int++;
+
+	/* the datasheet state those register as read-only
+	 * but nothing work(freeze) without writing to it
+	 */
+	writel(v, priv->base + EMAC_INT_STA);
+
+	return IRQ_HANDLED;
+}
+
+static int sun8i_emac_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct sun8i_emac_priv *priv;
+	struct net_device *ndev;
+	struct resource *res;
+	int ret;
+
+	ndev = alloc_etherdev(sizeof(*priv));
+	if (!ndev)
+		return -ENOMEM;
+
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+	priv = netdev_priv(ndev);
+	platform_set_drvdata(pdev, ndev);
+
+	priv->variant = of_device_get_match_data(&pdev->dev);
+	if (!priv->variant) {
+		dev_err(&pdev->dev, "Missing sun8i-emac variant\n");
+		return -EINVAL;
+	}
+
+	priv->mdio_node = of_get_child_by_name(node, "mdio");
+	if (!priv->mdio_node) {
+		netdev_err(ndev, "Could not find a MDIO node\n");
+		return -EINVAL;
+	}
+
+	priv->phy_node = of_parse_phandle(node, "phy-handle", 0);
+	if (!priv->phy_node) {
+		netdev_err(ndev, "No associated PHY\n");
+		return -EINVAL;
+	}
+
+	priv->regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
+						       "syscon");
+	if (IS_ERR(priv->regmap)) {
+		ret = PTR_ERR(priv->regmap);
+		dev_err(&pdev->dev, "unable to map SYSCON:%d\n", ret);
+		return ret;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(priv->base)) {
+		ret = PTR_ERR(priv->base);
+		dev_err(&pdev->dev, "Cannot request MMIO: %d\n", ret);
+		return ret;
+	}
+
+	priv->ahb_clk = devm_clk_get(&pdev->dev, "ahb");
+	if (IS_ERR(priv->ahb_clk)) {
+		ret = PTR_ERR(priv->ahb_clk);
+		dev_err(&pdev->dev, "Cannot get AHB clock err=%d\n", ret);
+		goto probe_err;
+	}
+
+	priv->rst_mac = devm_reset_control_get_optional(&pdev->dev, "ahb");
+	if (IS_ERR(priv->rst_mac)) {
+		ret = PTR_ERR(priv->rst_mac);
+		if (ret == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+		dev_info(&pdev->dev, "No MAC reset control found %d\n", ret);
+		priv->rst_mac = NULL;
+	}
+
+	priv->phy_interface = of_get_phy_mode(node);
+	if (priv->phy_interface < 0) {
+		netdev_err(ndev, "PHY interface mode node unspecified\n");
+		return priv->phy_interface;
+	}
+
+	switch (priv->phy_interface) {
+	case PHY_INTERFACE_MODE_MII:
+		if (!priv->variant->support_mii)
+			return -EINVAL;
+		break;
+	case PHY_INTERFACE_MODE_RMII:
+		if (!priv->variant->support_rmii)
+			return -EINVAL;
+		break;
+	case PHY_INTERFACE_MODE_RGMII:
+		if (!priv->variant->support_rgmii)
+			return -EINVAL;
+		break;
+	default:
+		netdev_err(ndev, "Unsupported interface mode: %s",
+			   phy_modes(priv->phy_interface));
+		return -EINVAL;
+	}
+
+	if (priv->phy_interface == priv->variant->internal_phy)
+		priv->use_internal_phy = true;
+
+	if (priv->use_internal_phy) {
+		priv->ephy_clk = of_clk_get(priv->phy_node, 0);
+		if (IS_ERR(priv->ephy_clk)) {
+			ret = PTR_ERR(priv->ephy_clk);
+			dev_err(&pdev->dev, "Cannot get EPHY clock err=%d\n",
+				ret);
+			goto probe_err;
+		}
+
+		priv->rst_ephy = of_reset_control_get(priv->phy_node, 0);
+		if (IS_ERR(priv->rst_ephy)) {
+			ret = PTR_ERR(priv->rst_ephy);
+			if (ret == -EPROBE_DEFER)
+				goto probe_err;
+			dev_info(&pdev->dev,
+				 "No EPHY reset control found %d\n", ret);
+			priv->rst_ephy = NULL;
+		}
+	}
+
+	priv->irq = platform_get_irq(pdev, 0);
+	if (priv->irq < 0) {
+		ret = priv->irq;
+		dev_err(&pdev->dev, "Cannot claim IRQ: %d\n", ret);
+		goto probe_err;
+	}
+
+	spin_lock_init(&priv->tx_lock);
+
+	ndev->netdev_ops = &sun8i_emac_netdev_ops;
+	ndev->ethtool_ops = &sun8i_emac_ethtool_ops;
+
+	priv->ndev = ndev;
+	priv->dev = &pdev->dev;
+
+	ndev->hw_features = NETIF_F_SG | NETIF_F_HIGHDMA;
+	ndev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+		NETIF_F_RXCSUM;
+	ndev->features |= ndev->hw_features;
+	ndev->hw_features |= NETIF_F_RXFCS;
+	ndev->hw_features |= NETIF_F_RXALL;
+	ndev->hw_features |= NETIF_F_LOOPBACK;
+	ndev->priv_flags |= IFF_UNICAST_FLT;
+
+	ndev->watchdog_timeo = msecs_to_jiffies(5000);
+	netif_carrier_off(ndev);
+
+	/* Benched on OPIPC with 100M, setting more than 256 does not give any
+	 * perf boost
+	 */
+	priv->nbdesc_rx = 128;
+	priv->nbdesc_tx = 256;
+
+	ret = register_netdev(ndev);
+	if (ret) {
+		dev_err(&pdev->dev, "ERROR: Register %s failed\n", ndev->name);
+		goto probe_err;
+	}
+
+	return 0;
+
+probe_err:
+	free_netdev(ndev);
+	return ret;
+}
+
+static int sun8i_emac_remove(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+
+	unregister_netdev(ndev);
+	platform_set_drvdata(pdev, NULL);
+	free_netdev(ndev);
+
+	return 0;
+}
+
+static const struct of_device_id sun8i_emac_of_match_table[] = {
+	{ .compatible = "allwinner,sun8i-a83t-emac",
+	  .data = &emac_variant_a83t },
+	{ .compatible = "allwinner,sun8i-h3-emac",
+	  .data = &emac_variant_h3 },
+	{ .compatible = "allwinner,sun50i-a64-emac",
+	  .data = &emac_variant_a64 },
+	{}
+};
+MODULE_DEVICE_TABLE(of, sun8i_emac_of_match_table);
+
+static struct platform_driver sun8i_emac_driver = {
+	.probe          = sun8i_emac_probe,
+	.remove         = sun8i_emac_remove,
+	.driver         = {
+		.name           = "sun8i-emac",
+		.of_match_table	= sun8i_emac_of_match_table,
+	},
+};
+
+module_platform_driver(sun8i_emac_driver);
+
+MODULE_DESCRIPTION("sun8i Ethernet driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Corentin Labbe <clabbe.montjoie@gmail.com");
diff -urN linux-4.9-01/drivers/net/wireless/ath/ath9k/mac.c linux-4.9-02/drivers/net/wireless/ath/ath9k/mac.c
--- linux-4.9-01/drivers/net/wireless/ath/ath9k/mac.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/net/wireless/ath/ath9k/mac.c	2017-01-21 11:59:18.900145942 +0000
@@ -693,7 +693,7 @@
 {
 #define AH_RX_STOP_DMA_TIMEOUT 10000   /* usec */
 	struct ath_common *common = ath9k_hw_common(ah);
-	u32 mac_status, last_mac_status = 0;
+	u32 mac_status = 0, last_mac_status = 0;
 	int i;
 
 	/* Enable access to the DMA observation bus */
@@ -723,6 +723,16 @@
 	}
 
 	if (i == 0) {
+		if (!AR_SREV_9300_20_OR_LATER(ah) &&
+		    (mac_status & 0x700) == 0) {
+			/*
+			 * DMA is idle but the MAC is still stuck
+			 * processing events
+			 */
+			*reset = true;
+			return true;
+		}
+
 		ath_err(common,
 			"DMA failed to stop in %d ms AR_CR=0x%08x AR_DIAG_SW=0x%08x DMADBG_7=0x%08x\n",
 			AH_RX_STOP_DMA_TIMEOUT / 1000,
diff -urN linux-4.9-01/drivers/pci/host/Makefile linux-4.9-02/drivers/pci/host/Makefile
--- linux-4.9-01/drivers/pci/host/Makefile	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/pci/host/Makefile	2017-01-21 11:59:15.162253192 +0000
@@ -15,7 +15,7 @@
 obj-$(CONFIG_PCI_KEYSTONE) += pci-keystone-dw.o pci-keystone.o
 obj-$(CONFIG_PCIE_XILINX) += pcie-xilinx.o
 obj-$(CONFIG_PCIE_XILINX_NWL) += pcie-xilinx-nwl.o
-obj-$(CONFIG_PCI_XGENE) += pci-xgene.o
+obj-$(CONFIG_PCI_XGENE) += pci-xgene.o pci-xgene-ecam.o
 obj-$(CONFIG_PCI_XGENE_MSI) += pci-xgene-msi.o
 obj-$(CONFIG_PCI_LAYERSCAPE) += pci-layerscape.o
 obj-$(CONFIG_PCI_VERSATILE) += pci-versatile.o
diff -urN linux-4.9-01/drivers/pci/host/pci-thunder-ecam.c linux-4.9-02/drivers/pci/host/pci-thunder-ecam.c
--- linux-4.9-01/drivers/pci/host/pci-thunder-ecam.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/pci/host/pci-thunder-ecam.c	2017-01-21 11:59:14.996257954 +0000
@@ -346,7 +346,7 @@
 	return pci_generic_config_write(bus, devfn, where, size, val);
 }
 
-static struct pci_ecam_ops pci_thunder_ecam_ops = {
+struct pci_ecam_ops pci_thunder_ecam_ops = {
 	.bus_shift	= 20,
 	.pci_ops	= {
 		.map_bus        = pci_ecam_map_bus,
diff -urN linux-4.9-01/drivers/pci/host/pci-thunder-pem.c linux-4.9-02/drivers/pci/host/pci-thunder-pem.c
--- linux-4.9-01/drivers/pci/host/pci-thunder-pem.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/pci/host/pci-thunder-pem.c	2017-01-21 11:59:14.961258958 +0000
@@ -18,6 +18,7 @@
 #include <linux/init.h>
 #include <linux/of_address.h>
 #include <linux/of_pci.h>
+#include <linux/pci-acpi.h>
 #include <linux/pci-ecam.h>
 #include <linux/platform_device.h>
 
@@ -284,6 +285,40 @@
 	return pci_generic_config_write(bus, devfn, where, size, val);
 }
 
+#ifdef CONFIG_ACPI
+static struct resource thunder_pem_reg_res[] = {
+	[4] = DEFINE_RES_MEM(0x87e0c0000000UL, SZ_16M),
+	[5] = DEFINE_RES_MEM(0x87e0c1000000UL, SZ_16M),
+	[6] = DEFINE_RES_MEM(0x87e0c2000000UL, SZ_16M),
+	[7] = DEFINE_RES_MEM(0x87e0c3000000UL, SZ_16M),
+	[8] = DEFINE_RES_MEM(0x87e0c4000000UL, SZ_16M),
+	[9] = DEFINE_RES_MEM(0x87e0c5000000UL, SZ_16M),
+	[14] = DEFINE_RES_MEM(0x97e0c0000000UL, SZ_16M),
+	[15] = DEFINE_RES_MEM(0x97e0c1000000UL, SZ_16M),
+	[16] = DEFINE_RES_MEM(0x97e0c2000000UL, SZ_16M),
+	[17] = DEFINE_RES_MEM(0x97e0c3000000UL, SZ_16M),
+	[18] = DEFINE_RES_MEM(0x97e0c4000000UL, SZ_16M),
+	[19] = DEFINE_RES_MEM(0x97e0c5000000UL, SZ_16M),
+};
+
+static struct resource *thunder_pem_acpi_res(struct pci_config_window *cfg)
+{
+	struct acpi_device *adev = to_acpi_device(cfg->parent);
+	struct acpi_pci_root *root = acpi_driver_data(adev);
+
+	if ((root->segment >= 4 && root->segment <= 9) ||
+	    (root->segment >= 14 && root->segment <= 19))
+		return &thunder_pem_reg_res[root->segment];
+
+	return NULL;
+}
+#else
+static struct resource *thunder_pem_acpi_res(struct pci_config_window *cfg)
+{
+	return NULL;
+}
+#endif
+
 static int thunder_pem_init(struct pci_config_window *cfg)
 {
 	struct device *dev = cfg->parent;
@@ -292,24 +327,24 @@
 	struct thunder_pem_pci *pem_pci;
 	struct platform_device *pdev;
 
-	/* Only OF support for now */
-	if (!dev->of_node)
-		return -EINVAL;
-
 	pem_pci = devm_kzalloc(dev, sizeof(*pem_pci), GFP_KERNEL);
 	if (!pem_pci)
 		return -ENOMEM;
 
-	pdev = to_platform_device(dev);
+	if (acpi_disabled) {
+		pdev = to_platform_device(dev);
 
-	/*
-	 * The second register range is the PEM bridge to the PCIe
-	 * bus.  It has a different config access method than those
-	 * devices behind the bridge.
-	 */
-	res_pem = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+		/*
+		 * The second register range is the PEM bridge to the PCIe
+		 * bus.  It has a different config access method than those
+		 * devices behind the bridge.
+		 */
+		res_pem = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	} else {
+		res_pem = thunder_pem_acpi_res(cfg);
+	}
 	if (!res_pem) {
-		dev_err(dev, "missing \"reg[1]\"property\n");
+		dev_err(dev, "missing configuration region\n");
 		return -EINVAL;
 	}
 
@@ -332,7 +367,7 @@
 	return 0;
 }
 
-static struct pci_ecam_ops pci_thunder_pem_ops = {
+struct pci_ecam_ops pci_thunder_pem_ops = {
 	.bus_shift	= 24,
 	.init		= thunder_pem_init,
 	.pci_ops	= {
diff -urN linux-4.9-01/drivers/pci/host/pci-xgene-ecam.c linux-4.9-02/drivers/pci/host/pci-xgene-ecam.c
--- linux-4.9-01/drivers/pci/host/pci-xgene-ecam.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.9-02/drivers/pci/host/pci-xgene-ecam.c	2017-01-21 11:59:15.163253164 +0000
@@ -0,0 +1,280 @@
+/*
+ * APM X-Gene PCIe ECAM fixup driver
+ *
+ * Copyright (c) 2016, Applied Micro Circuits Corporation
+ * Author:
+ *	Duc Dang <dhdang@apm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_pci.h>
+#include <linux/pci-acpi.h>
+#include <linux/platform_device.h>
+#include <linux/pci-ecam.h>
+
+#ifdef CONFIG_ACPI
+#define RTDID			0x160
+#define ROOT_CAP_AND_CTRL	0x5C
+
+/* PCIe IP version */
+#define XGENE_PCIE_IP_VER_UNKN	0
+#define XGENE_PCIE_IP_VER_1	1
+#define XGENE_PCIE_IP_VER_2	2
+
+#define XGENE_CSR_LENGTH	0x10000
+
+struct xgene_pcie_acpi_root {
+	void __iomem *csr_base;
+	u32 version;
+};
+
+static int xgene_v1_pcie_ecam_init(struct pci_config_window *cfg)
+{
+	struct xgene_pcie_acpi_root *xgene_root;
+	struct device *dev = cfg->parent;
+	u32 csr_base;
+
+	xgene_root = devm_kzalloc(dev, sizeof(*xgene_root), GFP_KERNEL);
+	if (!xgene_root)
+		return -ENOMEM;
+
+	switch (cfg->res.start) {
+	case 0xE0D0000000ULL:
+		csr_base = 0x1F2B0000;
+		break;
+	case 0xD0D0000000ULL:
+		csr_base = 0x1F2C0000;
+		break;
+	case 0x90D0000000ULL:
+		csr_base = 0x1F2D0000;
+		break;
+	case 0xA0D0000000ULL:
+		csr_base = 0x1F500000;
+		break;
+	case 0xC0D0000000ULL:
+		csr_base = 0x1F510000;
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	xgene_root->csr_base = ioremap(csr_base, XGENE_CSR_LENGTH);
+	if (!xgene_root->csr_base) {
+		kfree(xgene_root);
+		return -ENODEV;
+	}
+
+	xgene_root->version = XGENE_PCIE_IP_VER_1;
+
+	cfg->priv = xgene_root;
+
+	return 0;
+}
+
+static int xgene_v2_1_pcie_ecam_init(struct pci_config_window *cfg)
+{
+	struct xgene_pcie_acpi_root *xgene_root;
+	struct device *dev = cfg->parent;
+	resource_size_t csr_base;
+
+	xgene_root = devm_kzalloc(dev, sizeof(*xgene_root), GFP_KERNEL);
+	if (!xgene_root)
+		return -ENOMEM;
+
+	switch (cfg->res.start) {
+	case 0xC0D0000000ULL:
+		csr_base = 0x1F2B0000;
+		break;
+	case 0xA0D0000000ULL:
+		csr_base = 0x1F2C0000;
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	xgene_root->csr_base = ioremap(csr_base, XGENE_CSR_LENGTH);
+	if (!xgene_root->csr_base) {
+		kfree(xgene_root);
+		return -ENODEV;
+	}
+
+	xgene_root->version = XGENE_PCIE_IP_VER_2;
+
+	cfg->priv = xgene_root;
+
+	return 0;
+}
+
+static int xgene_v2_2_pcie_ecam_init(struct pci_config_window *cfg)
+{
+	struct xgene_pcie_acpi_root *xgene_root;
+	struct device *dev = cfg->parent;
+	resource_size_t csr_base;
+
+	xgene_root = devm_kzalloc(dev, sizeof(*xgene_root), GFP_KERNEL);
+	if (!xgene_root)
+		return -ENOMEM;
+
+	switch (cfg->res.start) {
+	case 0xE0D0000000ULL:
+		csr_base = 0x1F2B0000;
+		break;
+	case 0xA0D0000000ULL:
+		csr_base = 0x1F500000;
+		break;
+	case 0x90D0000000ULL:
+		csr_base = 0x1F2D0000;
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	xgene_root->csr_base = ioremap(csr_base, XGENE_CSR_LENGTH);
+	if (!xgene_root->csr_base) {
+		kfree(xgene_root);
+		return -ENODEV;
+	}
+
+	xgene_root->version = XGENE_PCIE_IP_VER_2;
+
+	cfg->priv = xgene_root;
+
+	return 0;
+}
+/*
+ * For Configuration request, RTDID register is used as Bus Number,
+ * Device Number and Function number of the header fields.
+ */
+static void xgene_pcie_set_rtdid_reg(struct pci_bus *bus, uint devfn)
+{
+	struct pci_config_window *cfg = bus->sysdata;
+	struct xgene_pcie_acpi_root *port = cfg->priv;
+	unsigned int b, d, f;
+	u32 rtdid_val = 0;
+
+	b = bus->number;
+	d = PCI_SLOT(devfn);
+	f = PCI_FUNC(devfn);
+
+	if (!pci_is_root_bus(bus))
+		rtdid_val = (b << 8) | (d << 3) | f;
+
+	writel(rtdid_val, port->csr_base + RTDID);
+	/* read the register back to ensure flush */
+	readl(port->csr_base + RTDID);
+}
+
+/*
+ * X-Gene PCIe port uses BAR0-BAR1 of RC's configuration space as
+ * the translation from PCI bus to native BUS.  Entire DDR region
+ * is mapped into PCIe space using these registers, so it can be
+ * reached by DMA from EP devices.  The BAR0/1 of bridge should be
+ * hidden during enumeration to avoid the sizing and resource allocation
+ * by PCIe core.
+ */
+static bool xgene_pcie_hide_rc_bars(struct pci_bus *bus, int offset)
+{
+	if (pci_is_root_bus(bus) && ((offset == PCI_BASE_ADDRESS_0) ||
+				     (offset == PCI_BASE_ADDRESS_1)))
+		return true;
+
+	return false;
+}
+
+void __iomem *xgene_pcie_ecam_map_bus(struct pci_bus *bus,
+				      unsigned int devfn, int where)
+{
+	struct pci_config_window *cfg = bus->sysdata;
+	unsigned int busn = bus->number;
+	void __iomem *base;
+
+	if (busn < cfg->busr.start || busn > cfg->busr.end)
+		return NULL;
+
+	if ((pci_is_root_bus(bus) && devfn != 0) ||
+	    xgene_pcie_hide_rc_bars(bus, where))
+		return NULL;
+
+	xgene_pcie_set_rtdid_reg(bus, devfn);
+
+	if (busn > cfg->busr.start)
+		base = cfg->win + (1 << cfg->ops->bus_shift);
+	else
+		base = cfg->win;
+
+	return base + where;
+}
+
+static int xgene_pcie_config_read32(struct pci_bus *bus, unsigned int devfn,
+				    int where, int size, u32 *val)
+{
+	struct pci_config_window *cfg = bus->sysdata;
+	struct xgene_pcie_acpi_root *port = cfg->priv;
+
+	if (pci_generic_config_read32(bus, devfn, where & ~0x3, 4, val) !=
+	    PCIBIOS_SUCCESSFUL)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/*
+	* The v1 controller has a bug in its Configuration Request
+	* Retry Status (CRS) logic: when CRS is enabled and we read the
+	* Vendor and Device ID of a non-existent device, the controller
+	* fabricates return data of 0xFFFF0001 ("device exists but is not
+	* ready") instead of 0xFFFFFFFF ("device does not exist").  This
+	* causes the PCI core to retry the read until it times out.
+	* Avoid this by not claiming to support CRS.
+	*/
+	if (pci_is_root_bus(bus) && (port->version == XGENE_PCIE_IP_VER_1) &&
+	    ((where & ~0x3) == ROOT_CAP_AND_CTRL))
+		*val &= ~(PCI_EXP_RTCAP_CRSVIS << 16);
+
+	if (size <= 2)
+		*val = (*val >> (8 * (where & 3))) & ((1 << (size * 8)) - 1);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+struct pci_ecam_ops xgene_v1_pcie_ecam_ops = {
+	.bus_shift	= 16,
+	.init		= xgene_v1_pcie_ecam_init,
+	.pci_ops	= {
+		.map_bus	= xgene_pcie_ecam_map_bus,
+		.read		= xgene_pcie_config_read32,
+		.write		= pci_generic_config_write,
+	}
+};
+
+struct pci_ecam_ops xgene_v2_1_pcie_ecam_ops = {
+	.bus_shift	= 16,
+	.init		= xgene_v2_1_pcie_ecam_init,
+	.pci_ops	= {
+		.map_bus	= xgene_pcie_ecam_map_bus,
+		.read		= xgene_pcie_config_read32,
+		.write		= pci_generic_config_write,
+	}
+};
+
+struct pci_ecam_ops xgene_v2_2_pcie_ecam_ops = {
+	.bus_shift	= 16,
+	.init		= xgene_v2_2_pcie_ecam_init,
+	.pci_ops	= {
+		.map_bus	= xgene_pcie_ecam_map_bus,
+		.read		= xgene_pcie_config_read32,
+		.write		= pci_generic_config_write,
+	}
+};
+#endif
diff -urN linux-4.9-01/drivers/pci/pci-sysfs.c linux-4.9-02/drivers/pci/pci-sysfs.c
--- linux-4.9-01/drivers/pci/pci-sysfs.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/pci/pci-sysfs.c	2017-01-21 11:59:18.088169239 +0000
@@ -30,6 +30,7 @@
 #include <linux/vgaarb.h>
 #include <linux/pm_runtime.h>
 #include <linux/of.h>
+#include <linux/module.h>
 #include "pci.h"
 
 static int sysfs_initialized;	/* = 0 */
@@ -716,6 +717,9 @@
 	loff_t init_off = off;
 	u8 *data = (u8 *) buf;
 
+	if (secure_modules())
+		return -EPERM;
+
 	if (off > dev->cfg_size)
 		return 0;
 	if (off + count > dev->cfg_size) {
@@ -1007,6 +1011,9 @@
 	resource_size_t start, end;
 	int i;
 
+	if (secure_modules())
+		return -EPERM;
+
 	for (i = 0; i < PCI_ROM_RESOURCE; i++)
 		if (res == &pdev->resource[i])
 			break;
@@ -1106,6 +1113,9 @@
 				     struct bin_attribute *attr, char *buf,
 				     loff_t off, size_t count)
 {
+	if (secure_modules())
+		return -EPERM;
+
 	return pci_resource_io(filp, kobj, attr, buf, off, count, true);
 }
 
diff -urN linux-4.9-01/drivers/pci/proc.c linux-4.9-02/drivers/pci/proc.c
--- linux-4.9-01/drivers/pci/proc.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/pci/proc.c	2017-01-21 11:59:18.095169039 +0000
@@ -116,6 +116,9 @@
 	int size = dev->cfg_size;
 	int cnt;
 
+	if (secure_modules())
+		return -EPERM;
+
 	if (pos >= size)
 		return 0;
 	if (nbytes >= size)
@@ -195,6 +198,9 @@
 #endif /* HAVE_PCI_MMAP */
 	int ret = 0;
 
+	if (secure_modules())
+		return -EPERM;
+
 	switch (cmd) {
 	case PCIIOC_CONTROLLER:
 		ret = pci_domain_nr(dev->bus);
@@ -233,7 +239,7 @@
 	struct pci_filp_private *fpriv = file->private_data;
 	int i, ret, write_combine;
 
-	if (!capable(CAP_SYS_RAWIO))
+	if (!capable(CAP_SYS_RAWIO) || secure_modules())
 		return -EPERM;
 
 	/* Make sure the caller is mapping a real resource for this device */
diff -urN linux-4.9-01/drivers/pci/syscall.c linux-4.9-02/drivers/pci/syscall.c
--- linux-4.9-01/drivers/pci/syscall.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/pci/syscall.c	2017-01-21 11:59:18.103168809 +0000
@@ -10,6 +10,7 @@
 #include <linux/errno.h>
 #include <linux/pci.h>
 #include <linux/syscalls.h>
+#include <linux/module.h>
 #include <asm/uaccess.h>
 #include "pci.h"
 
@@ -92,7 +93,7 @@
 	u32 dword;
 	int err = 0;
 
-	if (!capable(CAP_SYS_ADMIN))
+	if (!capable(CAP_SYS_ADMIN) || secure_modules())
 		return -EPERM;
 
 	dev = pci_get_bus_and_slot(bus, dfn);
diff -urN linux-4.9-01/drivers/platform/x86/asus-wmi.c linux-4.9-02/drivers/platform/x86/asus-wmi.c
--- linux-4.9-01/drivers/platform/x86/asus-wmi.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/platform/x86/asus-wmi.c	2017-01-21 11:59:18.292163386 +0000
@@ -1872,6 +1872,9 @@
 	int err;
 	u32 retval = -1;
 
+	if (secure_modules())
+		return -EPERM;
+
 	err = asus_wmi_get_devstate(asus, asus->debug.dev_id, &retval);
 
 	if (err < 0)
@@ -1888,6 +1891,9 @@
 	int err;
 	u32 retval = -1;
 
+	if (secure_modules())
+		return -EPERM;
+
 	err = asus_wmi_set_devstate(asus->debug.dev_id, asus->debug.ctrl_param,
 				    &retval);
 
@@ -1912,6 +1918,9 @@
 	union acpi_object *obj;
 	acpi_status status;
 
+	if (secure_modules())
+		return -EPERM;
+
 	status = wmi_evaluate_method(ASUS_WMI_MGMT_GUID,
 				     1, asus->debug.method_id,
 				     &input, &output);
diff -urN linux-4.9-01/drivers/scsi/sd.c linux-4.9-02/drivers/scsi/sd.c
--- linux-4.9-01/drivers/scsi/sd.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/scsi/sd.c	2017-01-21 11:59:18.856147204 +0000
@@ -2807,7 +2807,7 @@
 static int sd_revalidate_disk(struct gendisk *disk)
 {
 	struct scsi_disk *sdkp = scsi_disk(disk);
-	struct scsi_device *sdp = sdkp->device;
+	struct scsi_device *sdp;
 	struct request_queue *q = sdkp->disk->queue;
 	unsigned char *buffer;
 	unsigned int dev_max, rw_max;
@@ -2815,6 +2815,11 @@
 	SCSI_LOG_HLQUEUE(3, sd_printk(KERN_INFO, sdkp,
 				      "sd_revalidate_disk\n"));
 
+	if (WARN_ONCE((!sdkp), "Invalid scsi_disk from %p\n", disk))
+		goto out;
+
+	sdp = sdkp->device;
+
 	/*
 	 * If the device is offline, don't try and read capacity or any
 	 * of the other niceties.
diff -urN linux-4.9-01/drivers/tty/sysrq.c linux-4.9-02/drivers/tty/sysrq.c
--- linux-4.9-01/drivers/tty/sysrq.c	2017-01-21 11:57:04.776993988 +0000
+++ linux-4.9-02/drivers/tty/sysrq.c	2017-01-21 11:59:18.716151221 +0000
@@ -479,6 +479,7 @@
 	/* x: May be registered on mips for TLB dump */
 	/* x: May be registered on ppc/powerpc for xmon */
 	/* x: May be registered on sparc64 for global PMU dump */
+	/* x: May be registered on x86_64 for disabling secure boot */
 	NULL,				/* x */
 	/* y: May be registered on sparc64 for global register dump */
 	NULL,				/* y */
@@ -522,7 +523,7 @@
                 sysrq_key_table[i] = op_p;
 }
 
-void __handle_sysrq(int key, bool check_mask)
+void __handle_sysrq(int key, int from)
 {
 	struct sysrq_key_op *op_p;
 	int orig_log_level;
@@ -542,11 +543,15 @@
 
         op_p = __sysrq_get_key_op(key);
         if (op_p) {
+		/* Ban synthetic events from some sysrq functionality */
+		if ((from == SYSRQ_FROM_PROC || from == SYSRQ_FROM_SYNTHETIC) &&
+		    op_p->enable_mask & SYSRQ_DISABLE_USERSPACE)
+			printk("This sysrq operation is disabled from userspace.\n");
 		/*
 		 * Should we check for enabled operations (/proc/sysrq-trigger
 		 * should not) and is the invoked operation enabled?
 		 */
-		if (!check_mask || sysrq_on_mask(op_p->enable_mask)) {
+		if (from == SYSRQ_FROM_KERNEL || sysrq_on_mask(op_p->enable_mask)) {
 			pr_cont("%s\n", op_p->action_msg);
 			console_loglevel = orig_log_level;
 			op_p->handler(key);
@@ -578,7 +583,7 @@
 void handle_sysrq(int key)
 {
 	if (sysrq_on())
-		__handle_sysrq(key, true);
+		__handle_sysrq(key, SYSRQ_FROM_KERNEL);
 }
 EXPORT_SYMBOL(handle_sysrq);
 
@@ -659,7 +664,7 @@
 static void sysrq_handle_reset_request(struct sysrq_state *state)
 {
 	if (state->reset_requested)
-		__handle_sysrq(sysrq_xlate[KEY_B], false);
+		__handle_sysrq(sysrq_xlate[KEY_B], SYSRQ_FROM_KERNEL);
 
 	if (sysrq_reset_downtime_ms)
 		mod_timer(&state->keyreset_timer,
@@ -810,8 +815,10 @@
 
 	default:
 		if (sysrq->active && value && value != 2) {
+			int from = sysrq->handle.dev->flags & INPUTDEV_FLAGS_SYNTHETIC ?
+					SYSRQ_FROM_SYNTHETIC : 0;
 			sysrq->need_reinject = false;
-			__handle_sysrq(sysrq_xlate[code], true);
+			__handle_sysrq(sysrq_xlate[code], from);
 		}
 		break;
 	}
@@ -1095,7 +1102,7 @@
 
 		if (get_user(c, buf))
 			return -EFAULT;
-		__handle_sysrq(c, false);
+		__handle_sysrq(c, SYSRQ_FROM_PROC);
 	}
 
 	return count;
diff -urN linux-4.9-01/drivers/usb/core/hub.c linux-4.9-02/drivers/usb/core/hub.c
--- linux-4.9-01/drivers/usb/core/hub.c	2017-01-21 11:57:04.777993959 +0000
+++ linux-4.9-02/drivers/usb/core/hub.c	2017-01-21 11:59:15.794235060 +0000
@@ -5093,6 +5093,13 @@
 			(u16) hub->change_bits[0],
 			(u16) hub->event_bits[0]);
 
+	/* Don't disconnect USB-SATA on TrimSlice */
+	if (strcmp(dev_name(hdev->bus->controller), "tegra-ehci.0") == 0) {
+		if ((hdev->state == 7) && (hub->change_bits[0] == 0) &&
+				(hub->event_bits[0] == 0x2))
+			hub->event_bits[0] = 0;
+	}
+
 	/* Lock the device, then check to see if we were
 	 * disconnected while waiting for the lock to succeed. */
 	usb_lock_device(hdev);
diff -urN linux-4.9-01/drivers/usb/phy/phy-tegra-usb.c linux-4.9-02/drivers/usb/phy/phy-tegra-usb.c
--- linux-4.9-01/drivers/usb/phy/phy-tegra-usb.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/usb/phy/phy-tegra-usb.c	2017-01-21 11:59:15.327248458 +0000
@@ -164,7 +164,7 @@
 	u8 enable_delay;
 	u8 stable_count;
 	u8 active_delay;
-	u8 xtal_freq_count;
+	u16 xtal_freq_count;
 	u16 debounce;
 };
 
@@ -201,6 +201,14 @@
 		.xtal_freq_count = 0xFE,
 		.debounce = 0xFDE8,
 	},
+	{
+		.freq = 38400000,
+		.enable_delay = 0x00,
+		.stable_count = 0x00,
+		.active_delay = 0x18,
+		.xtal_freq_count = 0x177,
+		.debounce = 0xBB80,
+	},
 };
 
 static void set_pts(struct tegra_usb_phy *phy, u8 pts_val)
diff -urN linux-4.9-01/drivers/video/console/fbcon.c linux-4.9-02/drivers/video/console/fbcon.c
--- linux-4.9-01/drivers/video/console/fbcon.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/video/console/fbcon.c	2017-01-21 11:59:17.604183126 +0000
@@ -633,13 +633,15 @@
 		kfree(save);
 	}
 
-	if (logo_lines > vc->vc_bottom) {
-		logo_shown = FBCON_LOGO_CANSHOW;
-		printk(KERN_INFO
-		       "fbcon_init: disable boot-logo (boot-logo bigger than screen).\n");
-	} else if (logo_shown != FBCON_LOGO_DONTSHOW) {
-		logo_shown = FBCON_LOGO_DRAW;
-		vc->vc_top = logo_lines;
+	if (logo_shown != FBCON_LOGO_DONTSHOW) {
+		if (logo_lines > vc->vc_bottom) {
+			logo_shown = FBCON_LOGO_CANSHOW;
+			printk(KERN_INFO
+			       "fbcon_init: disable boot-logo (boot-logo bigger than screen).\n");
+		} else {
+			logo_shown = FBCON_LOGO_DRAW;
+			vc->vc_top = logo_lines;
+		}
 	}
 }
 #endif /* MODULE */
@@ -3651,6 +3653,16 @@
 
 module_exit(fb_console_exit);
 
+#else
+
+static int __init quiet_logo(char *str)
+{
+	logo_shown = FBCON_LOGO_DONTSHOW;
+	return 0;
+}
+
+early_param("quiet", quiet_logo);
+
 #endif
 
 MODULE_LICENSE("GPL");
diff -urN linux-4.9-01/drivers/xen/xen-pciback/pciback_ops.c linux-4.9-02/drivers/xen/xen-pciback/pciback_ops.c
--- linux-4.9-01/drivers/xen/xen-pciback/pciback_ops.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/drivers/xen/xen-pciback/pciback_ops.c	2017-01-21 11:59:18.927145167 +0000
@@ -126,8 +126,6 @@
 		if (pci_is_enabled(dev))
 			pci_disable_device(dev);
 
-		pci_write_config_word(dev, PCI_COMMAND, 0);
-
 		dev->is_busmaster = 0;
 	} else {
 		pci_read_config_word(dev, PCI_COMMAND, &cmd);
diff -urN linux-4.9-01/include/asm-generic/crash-driver.h linux-4.9-02/include/asm-generic/crash-driver.h
--- linux-4.9-01/include/asm-generic/crash-driver.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.9-02/include/asm-generic/crash-driver.h	2017-01-21 11:59:17.847176154 +0000
@@ -0,0 +1,72 @@
+#ifndef __CRASH_H__
+#define __CRASH_H__
+
+/*
+ * include/linux/crash-driver.h
+ *
+ * Copyright (c) 2013 Red Hat, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifdef __KERNEL__
+
+#include <linux/mm.h>
+#include <linux/highmem.h>
+
+static inline void *
+map_virtual(u64 offset, struct page **pp)
+{
+	struct page *page;
+	unsigned long pfn;
+	void *vaddr;
+
+	pfn = (unsigned long)(offset >> PAGE_SHIFT);
+
+	if (!page_is_ram(pfn)) {
+		printk(KERN_INFO
+		    "crash memory driver: !page_is_ram(pfn: %lx)\n", pfn);
+		return NULL;
+	}
+
+	if (!pfn_valid(pfn)) {
+		printk(KERN_INFO
+		    "crash memory driver: invalid pfn: %lx )\n", pfn);
+		return NULL;
+	}
+
+	page = pfn_to_page(pfn);
+
+	vaddr = kmap(page);
+	if (!vaddr) {
+		printk(KERN_INFO
+		    "crash memory driver: pfn: %lx kmap(page: %lx) failed\n",
+			pfn, (unsigned long)page);
+		return NULL;
+	}
+
+	*pp = page;
+	return (vaddr + (offset & (PAGE_SIZE-1)));
+}
+
+static inline void unmap_virtual(struct page *page)
+{
+	kunmap(page);
+}
+
+#endif /* __KERNEL__ */
+
+#endif /* __CRASH_H__ */
diff -urN linux-4.9-01/include/keys/system_keyring.h linux-4.9-02/include/keys/system_keyring.h
--- linux-4.9-01/include/keys/system_keyring.h	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/include/keys/system_keyring.h	2017-01-21 11:59:18.653153028 +0000
@@ -33,6 +33,11 @@
 #define restrict_link_by_builtin_and_secondary_trusted restrict_link_by_builtin_trusted
 #endif
 
+#ifdef CONFIG_SYSTEM_BLACKLIST_KEYRING
+extern struct key *system_blacklist_keyring;
+#endif
+extern struct key *get_system_keyring(void);
+
 #ifdef CONFIG_IMA_BLACKLIST_KEYRING
 extern struct key *ima_blacklist_keyring;
 
diff -urN linux-4.9-01/include/linux/efi.h linux-4.9-02/include/linux/efi.h
--- linux-4.9-01/include/linux/efi.h	2017-01-21 11:57:04.895990574 +0000
+++ linux-4.9-02/include/linux/efi.h	2017-01-21 11:59:18.579155152 +0000
@@ -593,6 +593,9 @@
 #define EFI_MEMORY_ATTRIBUTES_TABLE_GUID	EFI_GUID(0xdcfa911d, 0x26eb, 0x469f,  0xa2, 0x20, 0x38, 0xb7, 0xdc, 0x46, 0x12, 0x20)
 #define EFI_CONSOLE_OUT_DEVICE_GUID		EFI_GUID(0xd3b36f2c, 0xd551, 0x11d4,  0x9a, 0x46, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)
 
+#define EFI_IMAGE_SECURITY_DATABASE_GUID	EFI_GUID(0xd719b2cb, 0x3d3a, 0x4596, 0xa3, 0xbc, 0xda, 0xd0, 0x0e, 0x67, 0x65, 0x6f)
+#define EFI_SHIM_LOCK_GUID				EFI_GUID(0x605dab50, 0xe046, 0x4300, 0xab, 0xb6, 0x3d, 0xd8, 0x10, 0xdd, 0x8b, 0x23)
+
 /*
  * This GUID is used to pass to the kernel proper the struct screen_info
  * structure that was populated by the stub based on the GOP protocol instance
@@ -601,6 +604,9 @@
 #define LINUX_EFI_ARM_SCREEN_INFO_TABLE_GUID	EFI_GUID(0xe03fc20a, 0x85dc, 0x406e,  0xb9, 0x0e, 0x4a, 0xb5, 0x02, 0x37, 0x1d, 0x95)
 #define LINUX_EFI_LOADER_ENTRY_GUID		EFI_GUID(0x4a67b082, 0x0a4c, 0x41cf,  0xb6, 0xc7, 0x44, 0x0b, 0x29, 0xbb, 0x8c, 0x4f)
 
+#define EFI_CERT_SHA256_GUID			EFI_GUID(0xc1c41626, 0x504c, 0x4092,  0xac, 0xa9, 0x41, 0xf9, 0x36, 0x93, 0x43, 0x28)
+#define EFI_CERT_X509_GUID			EFI_GUID(0xa5c059a1, 0x94e4, 0x4aa7,  0x87, 0xb5, 0xab, 0x15, 0x5c, 0x2b, 0xf0, 0x72)
+
 typedef struct {
 	efi_guid_t guid;
 	u64 table;
@@ -851,6 +857,20 @@
 	efi_memory_desc_t entry[0];
 } efi_memory_attributes_table_t;
 
+typedef struct  {
+	efi_guid_t signature_owner;
+	u8 signature_data[];
+} efi_signature_data_t;
+
+typedef struct {
+	efi_guid_t signature_type;
+	u32 signature_list_size;
+	u32 signature_header_size;
+	u32 signature_size;
+	u8 signature_header[];
+	/* efi_signature_data_t signatures[][] */
+} efi_signature_list_t;
+
 /*
  * All runtime access to EFI goes through this structure:
  */
@@ -1007,6 +1027,10 @@
 char * __init efi_md_typeattr_format(char *buf, size_t size,
 				     const efi_memory_desc_t *md);
 
+struct key;
+extern int __init parse_efi_signature_list(const void *data, size_t size,
+					   struct key *keyring);
+
 /**
  * efi_range_is_wc - check the WC bit on an address range
  * @start: starting kvirt address
@@ -1045,6 +1069,7 @@
 #define EFI_ARCH_1		7	/* First arch-specific bit */
 #define EFI_DBG			8	/* Print additional debug info at runtime */
 #define EFI_NX_PE_DATA		9	/* Can runtime data regions be mapped non-executable? */
+#define EFI_SECURE_BOOT		10	/* Are we in Secure Boot mode? */
 
 #ifdef CONFIG_EFI
 /*
diff -urN linux-4.9-01/include/linux/input.h linux-4.9-02/include/linux/input.h
--- linux-4.9-01/include/linux/input.h	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/include/linux/input.h	2017-01-21 11:59:18.717151192 +0000
@@ -42,6 +42,7 @@
  * @phys: physical path to the device in the system hierarchy
  * @uniq: unique identification code for the device (if device has it)
  * @id: id of the device (struct input_id)
+ * @flags: input device flags (SYNTHETIC, etc.)
  * @propbit: bitmap of device properties and quirks
  * @evbit: bitmap of types of events supported by the device (EV_KEY,
  *	EV_REL, etc.)
@@ -124,6 +125,8 @@
 	const char *uniq;
 	struct input_id id;
 
+	unsigned int flags;
+
 	unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];
 
 	unsigned long evbit[BITS_TO_LONGS(EV_CNT)];
@@ -190,6 +193,8 @@
 };
 #define to_input_dev(d) container_of(d, struct input_dev, dev)
 
+#define	INPUTDEV_FLAGS_SYNTHETIC	0x000000001
+
 /*
  * Verify that we are in sync with input_device_id mod_devicetable.h #defines
  */
diff -urN linux-4.9-01/include/linux/module.h linux-4.9-02/include/linux/module.h
--- linux-4.9-01/include/linux/module.h	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/include/linux/module.h	2017-01-21 11:59:18.421159685 +0000
@@ -260,6 +260,12 @@
 
 struct notifier_block;
 
+#ifdef CONFIG_MODULE_SIG
+extern void enforce_signed_modules(void);
+#else
+static inline void enforce_signed_modules(void) {};
+#endif
+
 #ifdef CONFIG_MODULES
 
 extern int modules_disabled; /* for sysctl */
@@ -641,6 +647,8 @@
 }
 #endif /* CONFIG_LIVEPATCH */
 
+extern bool secure_modules(void);
+
 #else /* !CONFIG_MODULES... */
 
 static inline struct module *__module_address(unsigned long addr)
@@ -750,6 +758,10 @@
 	return false;
 }
 
+static inline bool secure_modules(void)
+{
+	return false;
+}
 #endif /* CONFIG_MODULES */
 
 #ifdef CONFIG_SYSFS
diff -urN linux-4.9-01/include/linux/pci-acpi.h linux-4.9-02/include/linux/pci-acpi.h
--- linux-4.9-01/include/linux/pci-acpi.h	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/include/linux/pci-acpi.h	2017-01-21 11:59:14.939259589 +0000
@@ -24,7 +24,9 @@
 }
 extern phys_addr_t acpi_pci_root_get_mcfg_addr(acpi_handle handle);
 
-extern phys_addr_t pci_mcfg_lookup(u16 domain, struct resource *bus_res);
+struct pci_ecam_ops;
+extern int pci_mcfg_lookup(struct acpi_pci_root *root, struct resource *cfgres,
+			   struct pci_ecam_ops **ecam_ops);
 
 static inline acpi_handle acpi_find_root_bridge_handle(struct pci_dev *pdev)
 {
diff -urN linux-4.9-01/include/linux/pci-ecam.h linux-4.9-02/include/linux/pci-ecam.h
--- linux-4.9-01/include/linux/pci-ecam.h	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/include/linux/pci-ecam.h	2017-01-21 11:59:15.163253164 +0000
@@ -58,6 +58,18 @@
 			       int where);
 /* default ECAM ops */
 extern struct pci_ecam_ops pci_generic_ecam_ops;
+/* ECAM ops for known quirks */
+#ifdef CONFIG_PCI_HOST_THUNDER_PEM
+extern struct pci_ecam_ops pci_thunder_pem_ops;
+#endif
+#ifdef CONFIG_PCI_HOST_THUNDER_ECAM
+extern struct pci_ecam_ops pci_thunder_ecam_ops;
+#endif
+#ifdef CONFIG_PCI_XGENE
+extern struct pci_ecam_ops xgene_v1_pcie_ecam_ops;
+extern struct pci_ecam_ops xgene_v2_1_pcie_ecam_ops;
+extern struct pci_ecam_ops xgene_v2_2_pcie_ecam_ops;
+#endif
 
 #ifdef CONFIG_PCI_HOST_GENERIC
 /* for DT-based PCI controllers that support ECAM */
diff -urN linux-4.9-01/include/linux/sysrq.h linux-4.9-02/include/linux/sysrq.h
--- linux-4.9-01/include/linux/sysrq.h	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/include/linux/sysrq.h	2017-01-21 11:59:18.717151192 +0000
@@ -28,6 +28,8 @@
 #define SYSRQ_ENABLE_BOOT	0x0080
 #define SYSRQ_ENABLE_RTNICE	0x0100
 
+#define SYSRQ_DISABLE_USERSPACE	0x00010000
+
 struct sysrq_key_op {
 	void (*handler)(int);
 	char *help_msg;
@@ -42,8 +44,12 @@
  * are available -- else NULL's).
  */
 
+#define SYSRQ_FROM_KERNEL	0x0001
+#define SYSRQ_FROM_PROC		0x0002
+#define SYSRQ_FROM_SYNTHETIC	0x0004
+
 void handle_sysrq(int key);
-void __handle_sysrq(int key, bool check_mask);
+void __handle_sysrq(int key, int from);
 int register_sysrq_key(int key, struct sysrq_key_op *op);
 int unregister_sysrq_key(int key, struct sysrq_key_op *op);
 struct sysrq_key_op *__sysrq_get_key_op(int key);
diff -urN linux-4.9-01/init/Kconfig linux-4.9-02/init/Kconfig
--- linux-4.9-01/init/Kconfig	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/init/Kconfig	2017-01-21 11:59:18.873146716 +0000
@@ -1166,7 +1166,7 @@
 endif # CGROUPS
 
 config CHECKPOINT_RESTORE
-	bool "Checkpoint/restore support" if EXPERT
+	bool "Checkpoint/restore support"
 	select PROC_CHILDREN
 	default n
 	help
@@ -1178,7 +1178,7 @@
 	  If unsure, say N here.
 
 menuconfig NAMESPACES
-	bool "Namespaces support" if EXPERT
+	bool "Namespaces support"
 	depends on MULTIUSER
 	default !EXPERT
 	help
@@ -1859,6 +1859,15 @@
 	  module verification, kexec image verification and firmware blob
 	  verification.
 
+config SYSTEM_BLACKLIST_KEYRING
+	bool "Provide system-wide ring of blacklisted keys"
+	depends on KEYS
+	help
+	  Provide a system keyring to which blacklisted keys can be added.
+	  Keys in the keyring are considered entirely untrusted.  Keys in this
+	  keyring are used by the module signature checking to reject loading
+	  of modules signed with a blacklisted key.
+
 config PROFILING
 	bool "Profiling support"
 	help
@@ -2000,6 +2009,15 @@
 comment "Do not forget to sign required modules with scripts/sign-file"
 	depends on MODULE_SIG_FORCE && !MODULE_SIG_ALL
 
+config MODULE_SIG_UEFI
+	bool "Allow modules signed with certs stored in UEFI"
+	depends on MODULE_SIG && SYSTEM_BLACKLIST_KEYRING && EFI
+	select EFI_SIGNATURE_LIST_PARSER
+	help
+	  This will import certificates stored in UEFI and allow modules
+	  signed with those to be loaded.  It will also disallow loading
+	  of modules stored in the UEFI dbx variable.
+
 choice
 	prompt "Which hash algorithm should modules be signed with?"
 	depends on MODULE_SIG
diff -urN linux-4.9-01/kernel/debug/kdb/kdb_main.c linux-4.9-02/kernel/debug/kdb/kdb_main.c
--- linux-4.9-01/kernel/debug/kdb/kdb_main.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/kernel/debug/kdb/kdb_main.c	2017-01-21 11:59:18.756150073 +0000
@@ -1968,7 +1968,7 @@
 		return KDB_ARGCOUNT;
 
 	kdb_trap_printk++;
-	__handle_sysrq(*argv[1], check_mask);
+	__handle_sysrq(*argv[1], check_mask & SYSRQ_FROM_KERNEL);
 	kdb_trap_printk--;
 
 	return 0;
diff -urN linux-4.9-01/kernel/kexec.c linux-4.9-02/kernel/kexec.c
--- linux-4.9-01/kernel/kexec.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/kernel/kexec.c	2017-01-21 11:59:18.392160517 +0000
@@ -12,6 +12,7 @@
 #include <linux/mm.h>
 #include <linux/file.h>
 #include <linux/kexec.h>
+#include <linux/module.h>
 #include <linux/mutex.h>
 #include <linux/list.h>
 #include <linux/syscalls.h>
@@ -194,6 +195,13 @@
 		return -EPERM;
 
 	/*
+	 * kexec can be used to circumvent module loading restrictions, so
+	 * prevent loading in that case
+	 */
+	if (secure_modules())
+		return -EPERM;
+
+	/*
 	 * Verify we have a legal set of flags
 	 * This leaves us room for future extensions.
 	 */
diff -urN linux-4.9-01/kernel/Makefile linux-4.9-02/kernel/Makefile
--- linux-4.9-01/kernel/Makefile	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/kernel/Makefile	2017-01-21 11:59:18.653153028 +0000
@@ -57,6 +57,7 @@
 obj-$(CONFIG_UID16) += uid16.o
 obj-$(CONFIG_MODULES) += module.o
 obj-$(CONFIG_MODULE_SIG) += module_signing.o
+obj-$(CONFIG_MODULE_SIG_UEFI) += modsign_uefi.o
 obj-$(CONFIG_KALLSYMS) += kallsyms.o
 obj-$(CONFIG_BSD_PROCESS_ACCT) += acct.o
 obj-$(CONFIG_KEXEC_CORE) += kexec_core.o
@@ -113,6 +114,8 @@
 
 obj-$(CONFIG_HAS_IOMEM) += memremap.o
 
+$(obj)/modsign_uefi.o: KBUILD_CFLAGS += -fshort-wchar
+
 $(obj)/configs.o: $(obj)/config_data.h
 
 # config_data.h contains the same information as ikconfig.h but gzipped.
diff -urN linux-4.9-01/kernel/modsign_uefi.c linux-4.9-02/kernel/modsign_uefi.c
--- linux-4.9-01/kernel/modsign_uefi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.9-02/kernel/modsign_uefi.c	2017-01-21 11:59:18.966144048 +0000
@@ -0,0 +1,125 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/cred.h>
+#include <linux/err.h>
+#include <linux/efi.h>
+#include <linux/slab.h>
+#include <keys/asymmetric-type.h>
+#include <keys/system_keyring.h>
+#include "module-internal.h"
+
+static __init int check_ignore_db(void)
+{
+	efi_status_t status;
+	unsigned int db = 0;
+	unsigned long size = sizeof(db);
+	efi_guid_t guid = EFI_SHIM_LOCK_GUID;
+
+	/* Check and see if the MokIgnoreDB variable exists.  If that fails
+	 * then we don't ignore DB.  If it succeeds, we do.
+	 */
+	status = efi.get_variable(L"MokIgnoreDB", &guid, NULL, &size, &db);
+	if (status != EFI_SUCCESS)
+		return 0;
+
+	return 1;
+}
+
+static __init void *get_cert_list(efi_char16_t *name, efi_guid_t *guid, unsigned long *size)
+{
+	efi_status_t status;
+	unsigned long lsize = 4;
+	unsigned long tmpdb[4];
+	void *db = NULL;
+
+	status = efi.get_variable(name, guid, NULL, &lsize, &tmpdb);
+	if (status != EFI_BUFFER_TOO_SMALL) {
+		pr_err("Couldn't get size: 0x%lx\n", status);
+		return NULL;
+	}
+
+	db = kmalloc(lsize, GFP_KERNEL);
+	if (!db) {
+		pr_err("Couldn't allocate memory for uefi cert list\n");
+		goto out;
+	}
+
+	status = efi.get_variable(name, guid, NULL, &lsize, db);
+	if (status != EFI_SUCCESS) {
+		kfree(db);
+		db = NULL;
+		pr_err("Error reading db var: 0x%lx\n", status);
+	}
+out:
+	*size = lsize;
+	return db;
+}
+
+/*
+ *  * Load the certs contained in the UEFI databases
+ *   */
+static int __init load_uefi_certs(void)
+{
+	efi_guid_t secure_var = EFI_IMAGE_SECURITY_DATABASE_GUID;
+	efi_guid_t mok_var = EFI_SHIM_LOCK_GUID;
+	void *db = NULL, *dbx = NULL, *mok = NULL;
+	unsigned long dbsize = 0, dbxsize = 0, moksize = 0;
+	int ignore_db, rc = 0;
+	struct key *keyring = NULL;
+
+	/* Check if SB is enabled and just return if not */
+	if (!efi_enabled(EFI_SECURE_BOOT))
+		return 0;
+
+	/* Things blow up if efi runtime is disabled */
+	if (efi_runtime_disabled())
+		return 0;
+
+	keyring = get_system_keyring();
+	if (!keyring) {
+		pr_err("MODSIGN: Couldn't get system keyring\n");
+		return -EINVAL;
+	}
+
+	/* See if the user has setup Ignore DB mode */
+	ignore_db = check_ignore_db();
+
+	/* Get db, MokListRT, and dbx.  They might not exist, so it isn't
+	 * an error if we can't get them.
+	 */
+	if (!ignore_db) {
+		db = get_cert_list(L"db", &secure_var, &dbsize);
+		if (!db) {
+			pr_err("MODSIGN: Couldn't get UEFI db list\n");
+		} else {
+			rc = parse_efi_signature_list(db, dbsize, keyring);
+			if (rc)
+				pr_err("Couldn't parse db signatures: %d\n", rc);
+			kfree(db);
+		}
+	}
+
+	mok = get_cert_list(L"MokListRT", &mok_var, &moksize);
+	if (!mok) {
+		pr_info("MODSIGN: Couldn't get UEFI MokListRT\n");
+	} else {
+		rc = parse_efi_signature_list(mok, moksize, keyring);
+		if (rc)
+			pr_err("Couldn't parse MokListRT signatures: %d\n", rc);
+		kfree(mok);
+	}
+
+	dbx = get_cert_list(L"dbx", &secure_var, &dbxsize);
+	if (!dbx) {
+		pr_info("MODSIGN: Couldn't get UEFI dbx list\n");
+	} else {
+		rc = parse_efi_signature_list(dbx, dbxsize,
+			system_blacklist_keyring);
+		if (rc)
+			pr_err("Couldn't parse dbx signatures: %d\n", rc);
+		kfree(dbx);
+	}
+
+	return rc;
+}
+late_initcall(load_uefi_certs);
diff -urN linux-4.9-01/kernel/module.c linux-4.9-02/kernel/module.c
--- linux-4.9-01/kernel/module.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/kernel/module.c	2017-01-21 11:59:18.757150045 +0000
@@ -270,7 +270,7 @@
 #endif
 }
 
-static bool sig_enforce = IS_ENABLED(CONFIG_MODULE_SIG_FORCE);
+bool sig_enforce = IS_ENABLED(CONFIG_MODULE_SIG_FORCE);
 #ifndef CONFIG_MODULE_SIG_FORCE
 module_param(sig_enforce, bool_enable_only, 0644);
 #endif /* !CONFIG_MODULE_SIG_FORCE */
@@ -4285,3 +4285,20 @@
 }
 EXPORT_SYMBOL(module_layout);
 #endif
+
+#ifdef CONFIG_MODULE_SIG
+void enforce_signed_modules(void)
+{
+	sig_enforce = true;
+}
+#endif
+
+bool secure_modules(void)
+{
+#ifdef CONFIG_MODULE_SIG
+	return (sig_enforce || modules_disabled);
+#else
+	return modules_disabled;
+#endif
+}
+EXPORT_SYMBOL(secure_modules);
diff -urN linux-4.9-01/kernel/power/hibernate.c linux-4.9-02/kernel/power/hibernate.c
--- linux-4.9-01/kernel/power/hibernate.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/kernel/power/hibernate.c	2017-01-21 11:59:18.531156529 +0000
@@ -29,6 +29,7 @@
 #include <linux/ctype.h>
 #include <linux/genhd.h>
 #include <linux/ktime.h>
+#include <linux/module.h>
 #include <trace/events/power.h>
 
 #include "power.h"
@@ -67,7 +68,7 @@
 
 bool hibernation_available(void)
 {
-	return (nohibernate == 0);
+	return ((nohibernate == 0) && !secure_modules());
 }
 
 /**
diff -urN linux-4.9-01/lib/Kconfig linux-4.9-02/lib/Kconfig
--- linux-4.9-01/lib/Kconfig	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/lib/Kconfig	2017-01-21 11:59:17.380189556 +0000
@@ -399,7 +399,8 @@
 	bool
 
 config CPUMASK_OFFSTACK
-	bool "Force CPU masks off stack" if DEBUG_PER_CPU_MAPS
+	bool "Force CPU masks off stack"
+	depends on SMP
 	help
 	  Use dynamic allocation for cpumask_var_t, instead of putting
 	  them on the stack.  This is a bit more expensive, but avoids
diff -urN linux-4.9-01/lib/Kconfig.debug linux-4.9-02/lib/Kconfig.debug
--- linux-4.9-01/lib/Kconfig.debug	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/lib/Kconfig.debug	2017-01-21 11:59:17.729179540 +0000
@@ -165,7 +165,23 @@
 	  Generate dwarf4 debug info. This requires recent versions
 	  of gcc and gdb. It makes the debug information larger.
 	  But it significantly improves the success of resolving
-	  variables in gdb on optimized code.
+	  variables in gdb on optimized code.  The gcc docs also
+	  recommend enabling -fvar-tracking-assignments for maximum
+	  benefit. (see DEBUG_INFO_VTA)
+
+config DEBUG_INFO_VTA
+	bool "Enable var-tracking-assignments for debuginfo"
+	depends on DEBUG_INFO
+	help
+	  Enable gcc -fvar-tracking-assignments for improved debug
+	  information on variable locations in optimized code.  Per
+	  gcc, DEBUG_INFO_DWARF4 is recommended for best use of VTA.
+
+	  VTA has been implicated in codegen bugs (gcc PR61801,
+	  PR61904), so this may deserve some caution.  One can set
+	  GCC_COMPARE_DEBUG=-fvar-tracking-assignments-toggle in the
+	  environment to automatically compile everything both ways,
+	  generating an error if anything differs.
 
 config GDB_SCRIPTS
 	bool "Provide GDB scripts for kernel debugging"
diff -urN linux-4.9-01/MAINTAINERS linux-4.9-02/MAINTAINERS
--- linux-4.9-01/MAINTAINERS	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/MAINTAINERS	2017-01-21 11:59:17.233193771 +0000
@@ -597,6 +597,12 @@
 F:	Documentation/i2c/busses/i2c-ali1563
 F:	drivers/i2c/busses/i2c-ali1563.c
 
+ALLWINNER SUN8I-EMAC ETHERNET DRIVER
+M:	Corentin Labbe <clabbe.montjoie@gmail.com>
+L:	netdev@vger.kernel.org
+S:	Maintained
+F:	drivers/net/ethernet/allwinner/sun8i-emac.c
+
 ALLWINNER SECURITY SYSTEM
 M:	Corentin Labbe <clabbe.montjoie@gmail.com>
 L:	linux-crypto@vger.kernel.org
diff -urN linux-4.9-01/Makefile linux-4.9-02/Makefile
--- linux-4.9-01/Makefile	2017-01-21 11:57:04.569999926 +0000
+++ linux-4.9-02/Makefile	2017-01-21 11:59:17.678181003 +0000
@@ -723,7 +723,11 @@
 endif
 endif
 
+ifdef CONFIG_DEBUG_INFO_VTA
+KBUILD_CFLAGS   += $(call cc-option, -fvar-tracking-assignments)
+else
 KBUILD_CFLAGS   += $(call cc-option, -fno-var-tracking-assignments)
+endif
 
 ifdef CONFIG_DEBUG_INFO
 ifdef CONFIG_DEBUG_INFO_SPLIT
diff -urN linux-4.9-01/net/ipv4/netfilter/arp_tables.c linux-4.9-02/net/ipv4/netfilter/arp_tables.c
--- linux-4.9-01/net/ipv4/netfilter/arp_tables.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/net/ipv4/netfilter/arp_tables.c	2017-01-21 11:59:18.992143302 +0000
@@ -364,6 +364,10 @@
 
 				/* Move along one */
 				size = e->next_offset;
+
+				if (pos + size > newinfo->size - sizeof(*e))
+					return 0;
+
 				e = (struct arpt_entry *)
 					(entry0 + pos + size);
 				if (pos + size >= newinfo->size)
@@ -388,6 +392,10 @@
 					if (newpos >= newinfo->size)
 						return 0;
 				}
+
+				if (newpos > newinfo->size - sizeof(*e))
+					return 0;
+
 				e = (struct arpt_entry *)
 					(entry0 + newpos);
 				e->counters.pcnt = pos;
diff -urN linux-4.9-01/net/ipv4/netfilter/ip_tables.c linux-4.9-02/net/ipv4/netfilter/ip_tables.c
--- linux-4.9-01/net/ipv4/netfilter/ip_tables.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/net/ipv4/netfilter/ip_tables.c	2017-01-21 11:59:18.994143245 +0000
@@ -434,6 +434,10 @@
 
 				/* Move along one */
 				size = e->next_offset;
+
+				if (pos + size > newinfo->size - sizeof(*e))
+					return 0;
+
 				e = (struct ipt_entry *)
 					(entry0 + pos + size);
 				if (pos + size >= newinfo->size)
@@ -458,6 +462,10 @@
 					if (newpos >= newinfo->size)
 						return 0;
 				}
+
+				if (newpos > newinfo->size - sizeof(*e))
+					return 0;
+
 				e = (struct ipt_entry *)
 					(entry0 + newpos);
 				e->counters.pcnt = pos;
diff -urN linux-4.9-01/net/ipv6/netfilter/ip6_tables.c linux-4.9-02/net/ipv6/netfilter/ip6_tables.c
--- linux-4.9-01/net/ipv6/netfilter/ip6_tables.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/net/ipv6/netfilter/ip6_tables.c	2017-01-21 11:59:19.005142929 +0000
@@ -463,6 +463,8 @@
 
 				/* Move along one */
 				size = e->next_offset;
+				if (pos + size > newinfo->size - sizeof(*e))
+					return 0;
 				e = (struct ip6t_entry *)
 					(entry0 + pos + size);
 				if (pos + size >= newinfo->size)
@@ -487,6 +489,10 @@
 					if (newpos >= newinfo->size)
 						return 0;
 				}
+
+				if (newpos > newinfo->size - sizeof(*e))
+					return 0;
+
 				e = (struct ip6t_entry *)
 					(entry0 + newpos);
 				e->counters.pcnt = pos;
diff -urN linux-4.9-01/security/selinux/hooks.c linux-4.9-02/security/selinux/hooks.c
--- linux-4.9-01/security/selinux/hooks.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/security/selinux/hooks.c	2017-01-21 11:59:19.053141552 +0000
@@ -832,10 +832,14 @@
 	}
 
 	/*
-	 * If this is a user namespace mount, no contexts are allowed
-	 * on the command line and security labels must be ignored.
+	 * If this is a user namespace mount and the filesystem type is not
+	 * explicitly whitelisted, then no contexts are allowed on the command
+	 * line and security labels must be ignored.
 	 */
-	if (sb->s_user_ns != &init_user_ns) {
+	if (sb->s_user_ns != &init_user_ns &&
+	    strcmp(sb->s_type->name, "tmpfs") &&
+	    strcmp(sb->s_type->name, "ramfs") &&
+	    strcmp(sb->s_type->name, "devpts")) {
 		if (context_sid || fscontext_sid || rootcontext_sid ||
 		    defcontext_sid) {
 			rc = -EACCES;
diff -urN linux-4.9-01/tools/iio/iio_event_monitor.c linux-4.9-02/tools/iio/iio_event_monitor.c
--- linux-4.9-01/tools/iio/iio_event_monitor.c	2016-12-11 19:17:54.000000000 +0000
+++ linux-4.9-02/tools/iio/iio_event_monitor.c	2017-01-21 11:59:19.037142011 +0000
@@ -26,7 +26,7 @@
 #include <sys/ioctl.h>
 #include "iio_utils.h"
 #include <linux/iio/events.h>
-#include <linux/iio/types.h>
+#include "../../include/uapi/linux/iio/types.h"
 
 static const char * const iio_chan_type_name_spec[] = {
 	[IIO_VOLTAGE] = "voltage",
