diff -urN linux-4.4-01/arch/arm/boot/dts/imx6q-cm-fx6.dts linux-4.4-02/arch/arm/boot/dts/imx6q-cm-fx6.dts
--- linux-4.4-01/arch/arm/boot/dts/imx6q-cm-fx6.dts	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/arch/arm/boot/dts/imx6q-cm-fx6.dts	2016-09-16 10:21:59.048280546 +0100
@@ -97,11 +97,49 @@
 				MX6QDL_PAD_KEY_ROW0__UART4_RX_DATA	0x1b0b1
 			>;
 		};
+
+		pinctrl_usdhc1: usdhc1grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_CMD__SD1_CMD             0x17059
+				MX6QDL_PAD_SD1_CLK__SD1_CLK             0x10059
+				MX6QDL_PAD_SD1_DAT0__SD1_DATA0          0x17059
+				MX6QDL_PAD_SD1_DAT1__SD1_DATA1          0x17059
+				MX6QDL_PAD_SD1_DAT2__SD1_DATA2          0x17059
+				MX6QDL_PAD_SD1_DAT3__SD1_DATA3          0x17059
+			>;
+		};
+
+		pinctrl_usdhc3: usdhc3grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__SD3_CMD             0x17059
+				MX6QDL_PAD_SD3_CLK__SD3_CLK             0x10059
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0          0x17059
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1          0x17059
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2          0x17059
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3          0x17059
+			>;
+		};
 	};
 };
 
+&sata {
+	status = "okay";
+};
+
 &uart4 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_uart4>;
 	status = "okay";
 };
+
+&usdhc1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	status = "okay";
+};
+
+&usdhc3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	status = "okay";
+};
diff -urN linux-4.4-01/arch/arm/include/asm/crash-driver.h linux-4.4-02/arch/arm/include/asm/crash-driver.h
--- linux-4.4-01/arch/arm/include/asm/crash-driver.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.4-02/arch/arm/include/asm/crash-driver.h	2016-09-16 10:21:59.156277602 +0100
@@ -0,0 +1,6 @@
+#ifndef _ARM_CRASH_H
+#define _ARM_CRASH_H
+
+#include <asm-generic/crash-driver.h>
+
+#endif /* _ARM_CRASH_H */
diff -urN linux-4.4-01/arch/arm64/include/asm/crash-driver.h linux-4.4-02/arch/arm64/include/asm/crash-driver.h
--- linux-4.4-01/arch/arm64/include/asm/crash-driver.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.4-02/arch/arm64/include/asm/crash-driver.h	2016-09-16 10:21:59.156277602 +0100
@@ -0,0 +1,6 @@
+#ifndef _ARM64_CRASH_H
+#define _ARM64_CRASH_H
+
+#include <asm-generic/crash-driver.h>
+
+#endif /* _ARM64_CRASH_H */
diff -urN linux-4.4-01/arch/arm64/kernel/setup.c linux-4.4-02/arch/arm64/kernel/setup.c
--- linux-4.4-01/arch/arm64/kernel/setup.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/arch/arm64/kernel/setup.c	2016-09-16 10:21:58.992282075 +0100
@@ -381,3 +381,22 @@
 	return 0;
 }
 subsys_initcall(topology_init);
+
+/*
+ * Temporary hack to avoid need for console= on command line
+ */
+static int __init arm64_console_setup(void)
+{
+	/* Allow cmdline to override our assumed preferences */
+	if (console_set_on_cmdline)
+		return 0;
+
+	if (IS_ENABLED(CONFIG_SERIAL_AMBA_PL011))
+		add_preferred_console("ttyAMA", 0, "115200");
+
+	if (IS_ENABLED(CONFIG_SERIAL_8250))
+		add_preferred_console("ttyS", 0, "115200");
+
+	return 0;
+}
+early_initcall(arm64_console_setup);
diff -urN linux-4.4-01/arch/arm64/kernel/vdso/Makefile linux-4.4-02/arch/arm64/kernel/vdso/Makefile
--- linux-4.4-01/arch/arm64/kernel/vdso/Makefile	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/arch/arm64/kernel/vdso/Makefile	2016-09-16 10:21:58.813286949 +0100
@@ -55,7 +55,8 @@
 
 # Actual build commands
 quiet_cmd_vdsold = VDSOL   $@
-      cmd_vdsold = $(CC) $(c_flags) -Wl,-n -Wl,-T $^ -o $@
+      cmd_vdsold = $(CC) $(c_flags) -Wl,-n -Wl,-T $^ -o $@ \
+				    $(if $(AFTER_LINK),;$(AFTER_LINK))
 quiet_cmd_vdsoas = VDSOA   $@
       cmd_vdsoas = $(CC) $(a_flags) -c -o $@ $<
 
diff -urN linux-4.4-01/arch/ia64/include/asm/crash-driver.h linux-4.4-02/arch/ia64/include/asm/crash-driver.h
--- linux-4.4-01/arch/ia64/include/asm/crash-driver.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.4-02/arch/ia64/include/asm/crash-driver.h	2016-09-16 10:21:59.156277602 +0100
@@ -0,0 +1,90 @@
+#ifndef _ASM_IA64_CRASH_H
+#define _ASM_IA64_CRASH_H
+
+/*
+ * linux/include/asm-ia64/crash-driver.h
+ *
+ * Copyright (c) 2004 Red Hat, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifdef __KERNEL__
+
+#include <linux/efi.h>
+#include <linux/mm.h>
+#include <asm/mmzone.h>
+
+static inline void *
+map_virtual(u64 offset, struct page **pp)
+{
+	struct page *page;
+	unsigned long pfn;
+	u32 type;
+
+	if (REGION_NUMBER(offset) == 5) {
+		char byte;
+
+		if (__get_user(byte, (char *)offset) == 0)
+			return (void *)offset;
+		else
+			return NULL;
+	}
+
+	switch (type = efi_mem_type(offset))
+	{
+	case EFI_LOADER_CODE:
+	case EFI_LOADER_DATA:
+	case EFI_BOOT_SERVICES_CODE:
+	case EFI_BOOT_SERVICES_DATA:
+	case EFI_CONVENTIONAL_MEMORY:
+		break;
+
+	default:
+		printk(KERN_INFO
+		    "crash memory driver: invalid memory type for %lx: %d\n",
+			offset, type);
+		return NULL;
+	}
+
+	pfn = offset >> PAGE_SHIFT;
+
+	if (!pfn_valid(pfn)) {
+		printk(KERN_INFO
+			"crash memory driver: invalid pfn: %lx )\n", pfn);
+		return NULL;
+	}
+
+	page = pfn_to_page(pfn);
+
+	if (!page->virtual) {
+		printk(KERN_INFO
+		    "crash memory driver: offset: %lx page: %lx page->virtual: NULL\n",
+			offset, (unsigned long)page);
+		return NULL;
+	}
+
+	return (page->virtual + (offset & (PAGE_SIZE-1)));
+}
+
+static inline void unmap_virtual(struct page *page)
+{
+	return;
+}
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_IA64_CRASH_H */
diff -urN linux-4.4-01/arch/ia64/kernel/ia64_ksyms.c linux-4.4-02/arch/ia64/kernel/ia64_ksyms.c
--- linux-4.4-01/arch/ia64/kernel/ia64_ksyms.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/arch/ia64/kernel/ia64_ksyms.c	2016-09-16 10:21:59.156277602 +0100
@@ -84,6 +84,9 @@
 #include <asm/unwind.h>
 EXPORT_SYMBOL(unw_init_running);
 
+#include <linux/efi.h>
+EXPORT_SYMBOL_GPL(efi_mem_type);
+
 #if defined(CONFIG_IA64_ESI) || defined(CONFIG_IA64_ESI_MODULE)
 extern void esi_call_phys (void);
 EXPORT_SYMBOL_GPL(esi_call_phys);
diff -urN linux-4.4-01/arch/powerpc/include/asm/crash-driver.h linux-4.4-02/arch/powerpc/include/asm/crash-driver.h
--- linux-4.4-01/arch/powerpc/include/asm/crash-driver.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.4-02/arch/powerpc/include/asm/crash-driver.h	2016-09-16 10:21:59.157277575 +0100
@@ -0,0 +1,6 @@
+#ifndef _PPC64_CRASH_H
+#define _PPC64_CRASH_H
+
+#include <asm-generic/crash-driver.h>
+
+#endif /* _PPC64_CRASH_H */
diff -urN linux-4.4-01/arch/powerpc/kernel/vdso32/Makefile linux-4.4-02/arch/powerpc/kernel/vdso32/Makefile
--- linux-4.4-01/arch/powerpc/kernel/vdso32/Makefile	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/arch/powerpc/kernel/vdso32/Makefile	2016-09-16 10:21:58.814286921 +0100
@@ -43,7 +43,8 @@
 
 # actual build commands
 quiet_cmd_vdso32ld = VDSO32L $@
-      cmd_vdso32ld = $(CROSS32CC) $(c_flags) -Wl,-T $^ -o $@
+      cmd_vdso32ld = $(CROSS32CC) $(c_flags) -Wl,-T $^ -o $@ \
+		     $(if $(AFTER_LINK),; $(AFTER_LINK))
 quiet_cmd_vdso32as = VDSO32A $@
       cmd_vdso32as = $(CROSS32CC) $(a_flags) -c -o $@ $<
 
diff -urN linux-4.4-01/arch/powerpc/kernel/vdso64/Makefile linux-4.4-02/arch/powerpc/kernel/vdso64/Makefile
--- linux-4.4-01/arch/powerpc/kernel/vdso64/Makefile	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/arch/powerpc/kernel/vdso64/Makefile	2016-09-16 10:21:58.814286921 +0100
@@ -36,7 +36,8 @@
 
 # actual build commands
 quiet_cmd_vdso64ld = VDSO64L $@
-      cmd_vdso64ld = $(CC) $(c_flags) -Wl,-T $^ -o $@
+      cmd_vdso64ld = $(CC) $(c_flags) -Wl,-T $^ -o $@ \
+		     $(if $(AFTER_LINK),; $(AFTER_LINK))
 quiet_cmd_vdso64as = VDSO64A $@
       cmd_vdso64as = $(CC) $(a_flags) -c -o $@ $<
 
diff -urN linux-4.4-01/arch/s390/include/asm/crash-driver.h linux-4.4-02/arch/s390/include/asm/crash-driver.h
--- linux-4.4-01/arch/s390/include/asm/crash-driver.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.4-02/arch/s390/include/asm/crash-driver.h	2016-09-16 10:21:59.157277575 +0100
@@ -0,0 +1,60 @@
+#ifndef _S390_CRASH_H
+#define _S390_CRASH_H
+
+#ifdef __KERNEL__
+
+#include <linux/mm.h>
+#include <linux/highmem.h>
+
+/*
+ * For swapped prefix pages get bounce buffer using xlate_dev_mem_ptr()
+ */
+static inline void *map_virtual(u64 offset, struct page **pp)
+{
+	struct page *page;
+	unsigned long pfn;
+	void *vaddr;
+
+	vaddr = xlate_dev_mem_ptr(offset);
+	pfn = ((unsigned long) vaddr) >> PAGE_SHIFT;
+	if ((unsigned long) vaddr != offset)
+		page = pfn_to_page(pfn);
+	else
+		page = NULL;
+
+	if (!page_is_ram(pfn)) {
+		printk(KERN_INFO
+		    "crash memory driver: !page_is_ram(pfn: %lx)\n", pfn);
+		return NULL;
+	}
+
+	if (!pfn_valid(pfn)) {
+		printk(KERN_INFO
+		    "crash memory driver: invalid pfn: %lx )\n", pfn);
+		return NULL;
+	}
+
+	*pp = page;
+	return vaddr;
+}
+
+/*
+ * Free bounce buffer if necessary
+ */
+static inline void unmap_virtual(struct page *page)
+{
+	void *vaddr;
+
+	if (page) {
+		/*
+		 * Because for bounce buffers vaddr will never be 0
+		 * unxlate_dev_mem_ptr() will always free the bounce buffer.
+		 */
+		vaddr = (void *)(page_to_pfn(page) << PAGE_SHIFT);
+		unxlate_dev_mem_ptr(0, vaddr);
+	}
+}
+
+#endif /* __KERNEL__ */
+
+#endif /* _S390_CRASH_H */
diff -urN linux-4.4-01/arch/s390/kernel/vdso32/Makefile linux-4.4-02/arch/s390/kernel/vdso32/Makefile
--- linux-4.4-01/arch/s390/kernel/vdso32/Makefile	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/arch/s390/kernel/vdso32/Makefile	2016-09-16 10:21:58.814286921 +0100
@@ -43,7 +43,8 @@
 
 # actual build commands
 quiet_cmd_vdso32ld = VDSO32L $@
-      cmd_vdso32ld = $(CC) $(c_flags) -Wl,-T $^ -o $@
+      cmd_vdso32ld = $(CC) $(c_flags) -Wl,-T $^ -o $@ \
+		     $(if $(AFTER_LINK),; $(AFTER_LINK))
 quiet_cmd_vdso32as = VDSO32A $@
       cmd_vdso32as = $(CC) $(a_flags) -c -o $@ $<
 
diff -urN linux-4.4-01/arch/s390/kernel/vdso64/Makefile linux-4.4-02/arch/s390/kernel/vdso64/Makefile
--- linux-4.4-01/arch/s390/kernel/vdso64/Makefile	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/arch/s390/kernel/vdso64/Makefile	2016-09-16 10:21:58.814286921 +0100
@@ -43,7 +43,8 @@
 
 # actual build commands
 quiet_cmd_vdso64ld = VDSO64L $@
-      cmd_vdso64ld = $(CC) $(c_flags) -Wl,-T $^ -o $@
+      cmd_vdso64ld = $(CC) $(c_flags) -Wl,-T $^ -o $@ \
+		     $(if $(AFTER_LINK),; $(AFTER_LINK))
 quiet_cmd_vdso64as = VDSO64A $@
       cmd_vdso64as = $(CC) $(a_flags) -c -o $@ $<
 
diff -urN linux-4.4-01/arch/s390/mm/maccess.c linux-4.4-02/arch/s390/mm/maccess.c
--- linux-4.4-01/arch/s390/mm/maccess.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/arch/s390/mm/maccess.c	2016-09-16 10:21:59.157277575 +0100
@@ -197,6 +197,7 @@
 	put_online_cpus();
 	return bounce;
 }
+EXPORT_SYMBOL_GPL(xlate_dev_mem_ptr);
 
 /*
  * Free converted buffer for /dev/mem access (if necessary)
@@ -206,3 +207,4 @@
 	if ((void *) addr != buf)
 		free_page((unsigned long) buf);
 }
+EXPORT_SYMBOL_GPL(unxlate_dev_mem_ptr);
diff -urN linux-4.4-01/arch/x86/boot/compressed/eboot.c linux-4.4-02/arch/x86/boot/compressed/eboot.c
--- linux-4.4-01/arch/x86/boot/compressed/eboot.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/arch/x86/boot/compressed/eboot.c	2016-09-16 10:21:59.245275176 +0100
@@ -12,6 +12,7 @@
 #include <asm/efi.h>
 #include <asm/setup.h>
 #include <asm/desc.h>
+#include <asm/bootparam_utils.h>
 
 #include "../string.h"
 #include "eboot.h"
@@ -847,6 +848,55 @@
 	return status;
 }
 
+static int get_secure_boot(void)
+{
+	u8 sb, setup, moksbstate;
+	unsigned long datasize = sizeof(sb);
+	u32 attr;
+	efi_guid_t var_guid = EFI_GLOBAL_VARIABLE_GUID;
+	efi_status_t status;
+
+	status = efi_early->call((unsigned long)sys_table->runtime->get_variable,
+				L"SecureBoot", &var_guid, NULL, &datasize, &sb);
+
+	if (status != EFI_SUCCESS)
+		return 0;
+
+	if (sb == 0)
+		return 0;
+
+
+	status = efi_early->call((unsigned long)sys_table->runtime->get_variable,
+				L"SetupMode", &var_guid, NULL, &datasize,
+				&setup);
+
+	if (status != EFI_SUCCESS)
+		return 0;
+
+	if (setup == 1)
+		return 0;
+
+	/* See if a user has put shim into insecure_mode.  If so, and the variable
+	 * doesn't have the runtime attribute set, we might as well honor that.
+	 */
+	var_guid = EFI_SHIM_LOCK_GUID;
+	status = efi_early->call((unsigned long)sys_table->runtime->get_variable,
+				L"MokSBState", &var_guid, &attr, &datasize,
+				&moksbstate);
+
+	/* If it fails, we don't care why.  Default to secure */
+	if (status != EFI_SUCCESS)
+		return 1;
+
+	if (!(attr & EFI_VARIABLE_RUNTIME_ACCESS)) {
+		if (moksbstate == 1)
+			return 0;
+	}
+
+	return 1;
+}
+
+
 /*
  * See if we have Graphics Output Protocol
  */
@@ -1432,6 +1482,10 @@
 	else
 		setup_boot_services32(efi_early);
 
+	sanitize_boot_params(boot_params);
+
+	boot_params->secure_boot = get_secure_boot();
+
 	setup_graphics(boot_params);
 
 	setup_efi_pci(boot_params);
diff -urN linux-4.4-01/arch/x86/entry/vdso/Makefile linux-4.4-02/arch/x86/entry/vdso/Makefile
--- linux-4.4-01/arch/x86/entry/vdso/Makefile	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/arch/x86/entry/vdso/Makefile	2016-09-16 10:21:58.814286921 +0100
@@ -159,8 +159,9 @@
 quiet_cmd_vdso = VDSO    $@
       cmd_vdso = $(CC) -nostdlib -o $@ \
 		       $(VDSO_LDFLAGS) $(VDSO_LDFLAGS_$(filter %.lds,$(^F))) \
-		       -Wl,-T,$(filter %.lds,$^) $(filter %.o,$^) && \
-		 sh $(srctree)/$(src)/checkundef.sh '$(NM)' '$@'
+		       -Wl,-T,$(filter %.lds,$^) $(filter %.o,$^) \
+		$(if $(AFTER_LINK),; $(AFTER_LINK)) && \
+		sh $(srctree)/$(src)/checkundef.sh '$(NM)' '$@'
 
 VDSO_LDFLAGS = -fPIC -shared $(call cc-ldoption, -Wl$(comma)--hash-style=both) \
 	$(call cc-ldoption, -Wl$(comma)--build-id) -Wl,-Bsymbolic $(LTO_CFLAGS)
diff -urN linux-4.4-01/arch/x86/include/asm/crash-driver.h linux-4.4-02/arch/x86/include/asm/crash-driver.h
--- linux-4.4-01/arch/x86/include/asm/crash-driver.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.4-02/arch/x86/include/asm/crash-driver.h	2016-09-16 10:21:59.157277575 +0100
@@ -0,0 +1,6 @@
+#ifndef _X86_CRASH_H
+#define _X86_CRASH_H
+
+#include <asm-generic/crash-driver.h>
+
+#endif /* _X86_CRASH_H */
diff -urN linux-4.4-01/arch/x86/include/uapi/asm/bootparam.h linux-4.4-02/arch/x86/include/uapi/asm/bootparam.h
--- linux-4.4-01/arch/x86/include/uapi/asm/bootparam.h	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/arch/x86/include/uapi/asm/bootparam.h	2016-09-16 10:21:59.237275394 +0100
@@ -134,7 +134,8 @@
 	__u8  eddbuf_entries;				/* 0x1e9 */
 	__u8  edd_mbr_sig_buf_entries;			/* 0x1ea */
 	__u8  kbd_status;				/* 0x1eb */
-	__u8  _pad5[3];					/* 0x1ec */
+	__u8  secure_boot;				/* 0x1ec */
+	__u8  _pad5[2];					/* 0x1ed */
 	/*
 	 * The sentinel is set to a nonzero value (0xff) in header.S.
 	 *
diff -urN linux-4.4-01/arch/x86/Kconfig linux-4.4-02/arch/x86/Kconfig
--- linux-4.4-01/arch/x86/Kconfig	2016-09-16 10:21:30.557056923 +0100
+++ linux-4.4-02/arch/x86/Kconfig	2016-09-16 10:21:59.251275013 +0100
@@ -1721,6 +1721,17 @@
 
 	   If unsure, say N.
 
+config EFI_SECURE_BOOT_SIG_ENFORCE
+	def_bool n
+	depends on EFI
+	prompt "Force module signing when UEFI Secure Boot is enabled"
+	---help---
+	  UEFI Secure Boot provides a mechanism for ensuring that the
+	  firmware will only load signed bootloaders and kernels. Certain
+	  use cases may also require that all kernel modules also be signed.
+	  Say Y here to automatically enable module signature enforcement
+	  when a system boots with UEFI Secure Boot enabled.
+
 config SECCOMP
 	def_bool y
 	prompt "Enable seccomp to safely compute untrusted bytecode"
diff -urN linux-4.4-01/arch/x86/kernel/ioport.c linux-4.4-02/arch/x86/kernel/ioport.c
--- linux-4.4-01/arch/x86/kernel/ioport.c	2016-09-16 10:21:30.562056787 +0100
+++ linux-4.4-02/arch/x86/kernel/ioport.c	2016-09-16 10:21:59.192276621 +0100
@@ -15,6 +15,7 @@
 #include <linux/thread_info.h>
 #include <linux/syscalls.h>
 #include <linux/bitmap.h>
+#include <linux/module.h>
 #include <asm/syscalls.h>
 
 /*
@@ -28,7 +29,7 @@
 
 	if ((from + num <= from) || (from + num > IO_BITMAP_BITS))
 		return -EINVAL;
-	if (turn_on && !capable(CAP_SYS_RAWIO))
+	if (turn_on && (!capable(CAP_SYS_RAWIO) || secure_modules()))
 		return -EPERM;
 
 	/*
@@ -108,7 +109,7 @@
 		return -EINVAL;
 	/* Trying to gain more privileges? */
 	if (level > old) {
-		if (!capable(CAP_SYS_RAWIO))
+		if (!capable(CAP_SYS_RAWIO) || secure_modules())
 			return -EPERM;
 	}
 	regs->flags = (regs->flags & ~X86_EFLAGS_IOPL) |
diff -urN linux-4.4-01/arch/x86/kernel/kexec-bzimage64.c linux-4.4-02/arch/x86/kernel/kexec-bzimage64.c
--- linux-4.4-01/arch/x86/kernel/kexec-bzimage64.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/arch/x86/kernel/kexec-bzimage64.c	2016-09-16 10:21:59.402270898 +0100
@@ -180,6 +180,7 @@
 	if (efi_enabled(EFI_OLD_MEMMAP))
 		return 0;
 
+	params->secure_boot = boot_params.secure_boot;
 	ei->efi_loader_signature = current_ei->efi_loader_signature;
 	ei->efi_systab = current_ei->efi_systab;
 	ei->efi_systab_hi = current_ei->efi_systab_hi;
diff -urN linux-4.4-01/arch/x86/kernel/msr.c linux-4.4-02/arch/x86/kernel/msr.c
--- linux-4.4-01/arch/x86/kernel/msr.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/arch/x86/kernel/msr.c	2016-09-16 10:21:59.231275558 +0100
@@ -105,6 +105,9 @@
 	int err = 0;
 	ssize_t bytes = 0;
 
+	if (secure_modules())
+		return -EPERM;
+
 	if (count % 8)
 		return -EINVAL;	/* Invalid chunk size */
 
@@ -152,6 +155,10 @@
 			err = -EBADF;
 			break;
 		}
+		if (secure_modules()) {
+			err = -EPERM;
+			break;
+		}
 		if (copy_from_user(&regs, uregs, sizeof regs)) {
 			err = -EFAULT;
 			break;
diff -urN linux-4.4-01/arch/x86/kernel/setup.c linux-4.4-02/arch/x86/kernel/setup.c
--- linux-4.4-01/arch/x86/kernel/setup.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/arch/x86/kernel/setup.c	2016-09-16 10:21:59.304273569 +0100
@@ -70,6 +70,11 @@
 #include <linux/tboot.h>
 #include <linux/jiffies.h>
 
+#include <linux/fips.h>
+#include <linux/cred.h>
+#include <linux/sysrq.h>
+#include <linux/init_task.h>
+
 #include <video/edid.h>
 
 #include <asm/mtrr.h>
@@ -1143,6 +1148,14 @@
 
 	io_delay_init();
 
+#ifdef CONFIG_EFI_SECURE_BOOT_SIG_ENFORCE
+	if (boot_params.secure_boot) {
+		set_bit(EFI_SECURE_BOOT, &efi.flags);
+		enforce_signed_modules();
+		pr_info("Secure boot enabled\n");
+	}
+#endif
+
 	/*
 	 * Parse the ACPI tables for possible boot-time SMP configuration.
 	 */
@@ -1269,6 +1282,37 @@
 
 #endif /* CONFIG_X86_32 */
 
+#ifdef CONFIG_MAGIC_SYSRQ
+#ifdef CONFIG_MODULE_SIG
+extern bool sig_enforce;
+#endif
+
+static void sysrq_handle_secure_boot(int key)
+{
+	if (!efi_enabled(EFI_SECURE_BOOT))
+		return;
+
+	pr_info("Secure boot disabled\n");
+#ifdef CONFIG_MODULE_SIG
+	sig_enforce = fips_enabled;
+#endif
+}
+static struct sysrq_key_op secure_boot_sysrq_op = {
+	.handler	=	sysrq_handle_secure_boot,
+	.help_msg	=	"unSB(x)",
+	.action_msg	=	"Disabling Secure Boot restrictions",
+	.enable_mask	=	SYSRQ_DISABLE_USERSPACE,
+};
+static int __init secure_boot_sysrq(void)
+{
+	if (efi_enabled(EFI_SECURE_BOOT))
+		register_sysrq_key('x', &secure_boot_sysrq_op);
+	return 0;
+}
+late_initcall(secure_boot_sysrq);
+#endif /*CONFIG_MAGIC_SYSRQ*/
+
+
 static struct notifier_block kernel_offset_notifier = {
 	.notifier_call = dump_kernel_offset
 };
diff -urN linux-4.4-01/certs/system_keyring.c linux-4.4-02/certs/system_keyring.c
--- linux-4.4-01/certs/system_keyring.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/certs/system_keyring.c	2016-09-16 10:21:59.286274059 +0100
@@ -20,6 +20,9 @@
 
 struct key *system_trusted_keyring;
 EXPORT_SYMBOL_GPL(system_trusted_keyring);
+#ifdef CONFIG_SYSTEM_BLACKLIST_KEYRING
+struct key *system_blacklist_keyring;
+#endif
 
 extern __initconst const u8 system_certificate_list[];
 extern __initconst const unsigned long system_certificate_list_size;
@@ -41,6 +44,20 @@
 		panic("Can't allocate system trusted keyring\n");
 
 	set_bit(KEY_FLAG_TRUSTED_ONLY, &system_trusted_keyring->flags);
+
+	#ifdef CONFIG_SYSTEM_BLACKLIST_KEYRING
+	system_blacklist_keyring = keyring_alloc(".system_blacklist_keyring",
+				    KUIDT_INIT(0), KGIDT_INIT(0),
+				    current_cred(),
+				    (KEY_POS_ALL & ~KEY_POS_SETATTR) |
+				    KEY_USR_VIEW | KEY_USR_READ,
+				    KEY_ALLOC_NOT_IN_QUOTA, NULL);
+	if (IS_ERR(system_blacklist_keyring))
+		panic("Can't allocate system blacklist keyring\n");
+
+	set_bit(KEY_FLAG_TRUSTED_ONLY, &system_blacklist_keyring->flags);
+#endif
+
 	return 0;
 }
 
@@ -138,6 +155,16 @@
 	if (ret < 0)
 		goto error;
 
+#ifdef CONFIG_SYSTEM_BLACKLIST_KEYRING
+	ret = pkcs7_validate_trust(pkcs7, system_blacklist_keyring, &trusted);
+	if (!ret) {
+		/* module is signed with a cert in the blacklist.  reject */
+		pr_err("Module key is in the blacklist\n");
+		ret = -EKEYREJECTED;
+		goto error;
+	}
+#endif
+
 	ret = pkcs7_validate_trust(pkcs7, system_trusted_keyring, &trusted);
 	if (ret < 0)
 		goto error;
diff -urN linux-4.4-01/crypto/asymmetric_keys/efi_parser.c linux-4.4-02/crypto/asymmetric_keys/efi_parser.c
--- linux-4.4-01/crypto/asymmetric_keys/efi_parser.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.4-02/crypto/asymmetric_keys/efi_parser.c	2016-09-16 10:21:59.274274386 +0100
@@ -0,0 +1,109 @@
+/* EFI signature/key/certificate list parser
+ *
+ * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public Licence
+ * as published by the Free Software Foundation; either version
+ * 2 of the Licence, or (at your option) any later version.
+ */
+
+#define pr_fmt(fmt) "EFI: "fmt
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/err.h>
+#include <linux/efi.h>
+#include <keys/asymmetric-type.h>
+
+static __initdata efi_guid_t efi_cert_x509_guid = EFI_CERT_X509_GUID;
+
+/**
+ * parse_efi_signature_list - Parse an EFI signature list for certificates
+ * @data: The data blob to parse
+ * @size: The size of the data blob
+ * @keyring: The keyring to add extracted keys to
+ */
+int __init parse_efi_signature_list(const void *data, size_t size, struct key *keyring)
+{
+	unsigned offs = 0;
+	size_t lsize, esize, hsize, elsize;
+
+	pr_devel("-->%s(,%zu)\n", __func__, size);
+
+	while (size > 0) {
+		efi_signature_list_t list;
+		const efi_signature_data_t *elem;
+		key_ref_t key;
+
+		if (size < sizeof(list))
+			return -EBADMSG;
+
+		memcpy(&list, data, sizeof(list));
+		pr_devel("LIST[%04x] guid=%pUl ls=%x hs=%x ss=%x\n",
+			 offs,
+			 list.signature_type.b, list.signature_list_size,
+			 list.signature_header_size, list.signature_size);
+
+		lsize = list.signature_list_size;
+		hsize = list.signature_header_size;
+		esize = list.signature_size;
+		elsize = lsize - sizeof(list) - hsize;
+
+		if (lsize > size) {
+			pr_devel("<--%s() = -EBADMSG [overrun @%x]\n",
+				 __func__, offs);
+			return -EBADMSG;
+		}
+		if (lsize < sizeof(list) ||
+		    lsize - sizeof(list) < hsize ||
+		    esize < sizeof(*elem) ||
+		    elsize < esize ||
+		    elsize % esize != 0) {
+			pr_devel("- bad size combo @%x\n", offs);
+			return -EBADMSG;
+		}
+
+		if (efi_guidcmp(list.signature_type, efi_cert_x509_guid) != 0) {
+			data += lsize;
+			size -= lsize;
+			offs += lsize;
+			continue;
+		}
+
+		data += sizeof(list) + hsize;
+		size -= sizeof(list) + hsize;
+		offs += sizeof(list) + hsize;
+
+		for (; elsize > 0; elsize -= esize) {
+			elem = data;
+
+			pr_devel("ELEM[%04x]\n", offs);
+
+			key = key_create_or_update(
+				make_key_ref(keyring, 1),
+				"asymmetric",
+				NULL,
+				&elem->signature_data,
+				esize - sizeof(*elem),
+				(KEY_POS_ALL & ~KEY_POS_SETATTR) |
+				KEY_USR_VIEW,
+				KEY_ALLOC_NOT_IN_QUOTA |
+				KEY_ALLOC_TRUSTED);
+
+			if (IS_ERR(key))
+				pr_err("Problem loading in-kernel X.509 certificate (%ld)\n",
+				       PTR_ERR(key));
+			else
+				pr_notice("Loaded cert '%s' linked to '%s'\n",
+					  key_ref_to_ptr(key)->description,
+					  keyring->description);
+
+			data += esize;
+			size -= esize;
+			offs += esize;
+		}
+	}
+
+	return 0;
+}
diff -urN linux-4.4-01/crypto/asymmetric_keys/Kconfig linux-4.4-02/crypto/asymmetric_keys/Kconfig
--- linux-4.4-01/crypto/asymmetric_keys/Kconfig	2016-09-16 10:21:30.573056487 +0100
+++ linux-4.4-02/crypto/asymmetric_keys/Kconfig	2016-09-16 10:21:59.274274386 +0100
@@ -68,4 +68,12 @@
 	  This option provides support for verifying the signature(s) on a
 	  signed PE binary.
 
+config EFI_SIGNATURE_LIST_PARSER
+	bool "EFI signature list parser"
+	depends on EFI
+	select X509_CERTIFICATE_PARSER
+	help
+	  This option provides support for parsing EFI signature lists for
+	  X.509 certificates and turning them into keys.
+
 endif # ASYMMETRIC_KEY_TYPE
diff -urN linux-4.4-01/crypto/asymmetric_keys/Makefile linux-4.4-02/crypto/asymmetric_keys/Makefile
--- linux-4.4-01/crypto/asymmetric_keys/Makefile	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/crypto/asymmetric_keys/Makefile	2016-09-16 10:21:59.274274386 +0100
@@ -8,6 +8,7 @@
 
 obj-$(CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE) += public_key.o
 obj-$(CONFIG_PUBLIC_KEY_ALGO_RSA) += rsa.o
+obj-$(CONFIG_EFI_SIGNATURE_LIST_PARSER) += efi_parser.o
 
 #
 # X.509 Certificate handling
diff -urN linux-4.4-01/Documentation/x86/zero-page.txt linux-4.4-02/Documentation/x86/zero-page.txt
--- linux-4.4-01/Documentation/x86/zero-page.txt	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/Documentation/x86/zero-page.txt	2016-09-16 10:21:59.237275394 +0100
@@ -31,6 +31,8 @@
 1E9/001	ALL	eddbuf_entries	Number of entries in eddbuf (below)
 1EA/001	ALL	edd_mbr_sig_buf_entries	Number of entries in edd_mbr_sig_buffer
 				(below)
+1EB/001	ALL     kbd_status      Numlock is enabled
+1EC/001	ALL     secure_boot	Secure boot is enabled in the firmware
 1EF/001	ALL	sentinel	Used to detect broken bootloaders
 290/040	ALL	edd_mbr_sig_buffer EDD MBR signatures
 2D0/A00	ALL	e820_map	E820 memory map table
diff -urN linux-4.4-01/drivers/acpi/custom_method.c linux-4.4-02/drivers/acpi/custom_method.c
--- linux-4.4-01/drivers/acpi/custom_method.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/drivers/acpi/custom_method.c	2016-09-16 10:21:59.198276457 +0100
@@ -29,6 +29,9 @@
 	struct acpi_table_header table;
 	acpi_status status;
 
+	if (secure_modules())
+		return -EPERM;
+
 	if (!(*ppos)) {
 		/* parse the table header to get the table length */
 		if (count <= sizeof(struct acpi_table_header))
diff -urN linux-4.4-01/drivers/acpi/Kconfig linux-4.4-02/drivers/acpi/Kconfig
--- linux-4.4-01/drivers/acpi/Kconfig	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/drivers/acpi/Kconfig	2016-09-16 10:21:59.005281720 +0100
@@ -5,7 +5,7 @@
 menuconfig ACPI
 	bool "ACPI (Advanced Configuration and Power Interface) Support"
 	depends on !IA64_HP_SIM
-	depends on IA64 || X86 || (ARM64 && EXPERT)
+	depends on IA64 || X86 || ARM64
 	depends on PCI
 	select PNP
 	default y
diff -urN linux-4.4-01/drivers/acpi/osl.c linux-4.4-02/drivers/acpi/osl.c
--- linux-4.4-01/drivers/acpi/osl.c	2016-09-16 10:21:30.577056378 +0100
+++ linux-4.4-02/drivers/acpi/osl.c	2016-09-16 10:21:59.218275912 +0100
@@ -40,6 +40,7 @@
 #include <linux/list.h>
 #include <linux/jiffies.h>
 #include <linux/semaphore.h>
+#include <linux/module.h>
 
 #include <asm/io.h>
 #include <asm/uaccess.h>
@@ -252,7 +253,7 @@
 acpi_physical_address __init acpi_os_get_root_pointer(void)
 {
 #ifdef CONFIG_KEXEC
-	if (acpi_rsdp)
+	if (acpi_rsdp && !secure_modules())
 		return acpi_rsdp;
 #endif
 
diff -urN linux-4.4-01/drivers/base/firmware_class.c linux-4.4-02/drivers/base/firmware_class.c
--- linux-4.4-01/drivers/base/firmware_class.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/drivers/base/firmware_class.c	2016-09-16 10:21:59.391271198 +0100
@@ -1144,7 +1144,7 @@
 		}
 	} else {
 		ret = usermodehelper_read_trylock();
-		if (WARN_ON(ret)) {
+		if (ret) {
 			dev_err(device, "firmware: %s will not be loaded\n",
 				name);
 			goto out;
diff -urN linux-4.4-01/drivers/block/floppy.c linux-4.4-02/drivers/block/floppy.c
--- linux-4.4-01/drivers/block/floppy.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/drivers/block/floppy.c	2016-09-16 10:21:59.067280027 +0100
@@ -4634,8 +4634,7 @@
 	{"PNP0700", 0},
 	{}
 };
-
-MODULE_DEVICE_TABLE(pnp, floppy_pnpids);
+/* MODULE_DEVICE_TABLE(pnp, floppy_pnpids); */
 
 #else
 
diff -urN linux-4.4-01/drivers/char/crash.c linux-4.4-02/drivers/char/crash.c
--- linux-4.4-01/drivers/char/crash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.4-02/drivers/char/crash.c	2016-09-16 10:21:59.157277575 +0100
@@ -0,0 +1,128 @@
+/*
+ *  linux/drivers/char/crash.c
+ *
+ *  Copyright (C) 2004  Dave Anderson <anderson@redhat.com>
+ *  Copyright (C) 2004  Red Hat, Inc.
+ */
+
+/******************************************************************************
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2, or (at your option)
+ *   any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *****************************************************************************/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/types.h>
+#include <asm/crash-driver.h>
+
+#define CRASH_VERSION   "1.0"
+
+/*
+ *  These are the file operation functions that allow crash utility
+ *  access to physical memory.
+ */
+
+static loff_t
+crash_llseek(struct file * file, loff_t offset, int orig)
+{
+	switch (orig) {
+	case 0:
+		file->f_pos = offset;
+		return file->f_pos;
+	case 1:
+		file->f_pos += offset;
+		return file->f_pos;
+	default:
+		return -EINVAL;
+	}
+}
+
+/*
+ *  Determine the page address for an address offset value,
+ *  get a virtual address for it, and copy it out.
+ *  Accesses must fit within a page.
+ */
+static ssize_t
+crash_read(struct file *file, char *buf, size_t count, loff_t *poff)
+{
+	void *vaddr;
+	struct page *page;
+	u64 offset;
+	ssize_t read;
+
+	offset = *poff;
+	if (offset >> PAGE_SHIFT != (offset+count-1) >> PAGE_SHIFT)
+		return -EINVAL;
+
+	vaddr = map_virtual(offset, &page);
+	if (!vaddr)
+		return -EFAULT;
+
+	if (copy_to_user(buf, vaddr, count)) {
+		unmap_virtual(page);
+		return -EFAULT;
+	}
+	unmap_virtual(page);
+
+	read = count;
+	*poff += read;
+	return read;
+}
+
+static struct file_operations crash_fops = {
+	.owner = THIS_MODULE,
+	.llseek = crash_llseek,
+	.read = crash_read,
+};
+
+static struct miscdevice crash_dev = {
+	MISC_DYNAMIC_MINOR,
+	"crash",
+	&crash_fops
+};
+
+static int __init
+crash_init(void)
+{
+	int ret;
+
+	ret = misc_register(&crash_dev);
+	if (ret) {
+		printk(KERN_ERR
+		    "crash memory driver: cannot misc_register (MISC_DYNAMIC_MINOR)\n");
+		goto out;
+	}
+
+	ret = 0;
+	printk(KERN_INFO "crash memory driver: version %s\n", CRASH_VERSION);
+out:
+	return ret;
+}
+
+static void __exit
+crash_cleanup_module(void)
+{
+	misc_deregister(&crash_dev);
+}
+
+module_init(crash_init);
+module_exit(crash_cleanup_module);
+
+MODULE_LICENSE("GPL");
diff -urN linux-4.4-01/drivers/char/Kconfig linux-4.4-02/drivers/char/Kconfig
--- linux-4.4-01/drivers/char/Kconfig	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/drivers/char/Kconfig	2016-09-16 10:21:59.157277575 +0100
@@ -4,6 +4,9 @@
 
 menu "Character devices"
 
+config CRASH
+	tristate "Crash Utility memory driver"
+
 source "drivers/tty/Kconfig"
 
 config DEVMEM
diff -urN linux-4.4-01/drivers/char/Makefile linux-4.4-02/drivers/char/Makefile
--- linux-4.4-01/drivers/char/Makefile	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/drivers/char/Makefile	2016-09-16 10:21:59.157277575 +0100
@@ -60,3 +60,5 @@
 
 obj-$(CONFIG_TILE_SROM)		+= tile-srom.o
 obj-$(CONFIG_XILLYBUS)		+= xillybus/
+
+obj-$(CONFIG_CRASH)            += crash.o
diff -urN linux-4.4-01/drivers/char/mem.c linux-4.4-02/drivers/char/mem.c
--- linux-4.4-01/drivers/char/mem.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/drivers/char/mem.c	2016-09-16 10:21:59.212276076 +0100
@@ -27,6 +27,7 @@
 #include <linux/export.h>
 #include <linux/io.h>
 #include <linux/uio.h>
+#include <linux/module.h>
 
 #include <linux/uaccess.h>
 
@@ -166,6 +167,9 @@
 	if (p != *ppos)
 		return -EFBIG;
 
+	if (secure_modules())
+		return -EPERM;
+
 	if (!valid_phys_addr_range(p, count))
 		return -EFAULT;
 
@@ -512,6 +516,9 @@
 	char *kbuf; /* k-addr because vwrite() takes vmlist_lock rwlock */
 	int err = 0;
 
+	if (secure_modules())
+		return -EPERM;
+
 	if (p < (unsigned long) high_memory) {
 		unsigned long to_write = min_t(unsigned long, count,
 					       (unsigned long)high_memory - p);
@@ -577,6 +584,9 @@
 	unsigned long i = *ppos;
 	const char __user *tmp = buf;
 
+	if (secure_modules())
+		return -EPERM;
+
 	if (!access_ok(VERIFY_READ, buf, count))
 		return -EFAULT;
 	while (count-- > 0 && i < 65536) {
diff -urN linux-4.4-01/drivers/gpu/drm/i915/i915_dma.c linux-4.4-02/drivers/gpu/drm/i915/i915_dma.c
--- linux-4.4-01/drivers/gpu/drm/i915/i915_dma.c	2016-09-16 10:21:30.611055452 +0100
+++ linux-4.4-02/drivers/gpu/drm/i915/i915_dma.c	2016-09-16 10:21:59.397271034 +0100
@@ -151,7 +151,7 @@
 		value = 1;
 		break;
 	case I915_PARAM_MMAP_VERSION:
-		value = 1;
+		value = 0;
 		break;
 	case I915_PARAM_SUBSLICE_TOTAL:
 		value = INTEL_INFO(dev)->subslice_total;
diff -urN linux-4.4-01/drivers/gpu/drm/i915/intel_display.c linux-4.4-02/drivers/gpu/drm/i915/intel_display.c
--- linux-4.4-01/drivers/gpu/drm/i915/intel_display.c	2016-09-16 10:21:30.616055315 +0100
+++ linux-4.4-02/drivers/gpu/drm/i915/intel_display.c	2016-09-16 10:21:59.312273351 +0100
@@ -12821,7 +12821,7 @@
 		sw_config = to_intel_crtc_state(crtc->state);
 		if (!intel_pipe_config_compare(dev, sw_config,
 					       pipe_config, false)) {
-			I915_STATE_WARN(1, "pipe state doesn't match!\n");
+			DRM_DEBUG_KMS("pipe state doesn't match!\n");
 			intel_dump_pipe_config(intel_crtc, pipe_config,
 					       "[hw state]");
 			intel_dump_pipe_config(intel_crtc, sw_config,
diff -urN linux-4.4-01/drivers/input/keyboard/atkbd.c linux-4.4-02/drivers/input/keyboard/atkbd.c
--- linux-4.4-01/drivers/input/keyboard/atkbd.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/drivers/input/keyboard/atkbd.c	2016-09-16 10:21:59.058280273 +0100
@@ -436,11 +436,15 @@
 		goto out;
 	case ATKBD_RET_ACK:
 	case ATKBD_RET_NAK:
+# if 0
+		/* Quite a few key switchers and other tools trigger this
+		 * and it confuses people who can do nothing about it */
 		if (printk_ratelimit())
 			dev_warn(&serio->dev,
 				 "Spurious %s on %s. "
 				 "Some program might be trying to access hardware directly.\n",
 				 data == ATKBD_RET_ACK ? "ACK" : "NAK", serio->phys);
+#endif
 		goto out;
 	case ATKBD_RET_ERR:
 		atkbd->err_count++;
diff -urN linux-4.4-01/drivers/input/misc/pcspkr.c linux-4.4-02/drivers/input/misc/pcspkr.c
--- linux-4.4-01/drivers/input/misc/pcspkr.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/drivers/input/misc/pcspkr.c	2016-09-16 10:21:59.113278775 +0100
@@ -23,7 +23,6 @@
 MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>");
 MODULE_DESCRIPTION("PC Speaker beeper driver");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:pcspkr");
 
 static int pcspkr_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
 {
diff -urN linux-4.4-01/drivers/input/misc/uinput.c linux-4.4-02/drivers/input/misc/uinput.c
--- linux-4.4-01/drivers/input/misc/uinput.c	2016-09-16 10:21:30.678053626 +0100
+++ linux-4.4-02/drivers/input/misc/uinput.c	2016-09-16 10:21:59.304273569 +0100
@@ -364,6 +364,7 @@
 	if (!udev->dev)
 		return -ENOMEM;
 
+	udev->dev->flags |= INPUTDEV_FLAGS_SYNTHETIC;
 	udev->dev->event = uinput_dev_event;
 	input_set_drvdata(udev->dev, udev);
 
diff -urN linux-4.4-01/drivers/input/mouse/synaptics.c linux-4.4-02/drivers/input/mouse/synaptics.c
--- linux-4.4-01/drivers/input/mouse/synaptics.c	2016-09-16 10:21:30.679053599 +0100
+++ linux-4.4-02/drivers/input/mouse/synaptics.c	2016-09-16 10:21:59.386271334 +0100
@@ -941,6 +941,14 @@
 		input_report_abs(dev, ABS_MT_PRESSURE, hw[i]->z);
 	}
 
+	/* keep (slot count <= num_fingers) by pinning all slots */
+	if (num_fingers >= 3) {
+		for (i = 0; i < 3; i++) {
+			input_mt_slot(dev, i);
+			input_mt_report_slot_state(dev, MT_TOOL_FINGER, true);
+		}
+	}
+
 	input_mt_drop_unused(dev);
 
 	/* Don't use active slot count to generate BTN_TOOL events. */
diff -urN linux-4.4-01/drivers/input/serio/i8042.c linux-4.4-02/drivers/input/serio/i8042.c
--- linux-4.4-01/drivers/input/serio/i8042.c	2016-09-16 10:21:30.680053571 +0100
+++ linux-4.4-02/drivers/input/serio/i8042.c	2016-09-16 10:21:59.318273187 +0100
@@ -1549,6 +1549,22 @@
 	.notifier_call = i8042_kbd_bind_notifier,
 };
 
+#ifdef CONFIG_DMI
+static struct dmi_system_id __initdata dmi_system_table[] = {
+	{
+		.matches = {
+			DMI_MATCH(DMI_BIOS_VENDOR, "Apple Computer, Inc.")
+		},
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BIOS_VENDOR, "Apple Inc.")
+		},
+	},
+	{}
+};
+#endif /*CONFIG_DMI*/
+
 static int __init i8042_init(void)
 {
 	struct platform_device *pdev;
@@ -1556,6 +1572,12 @@
 
 	dbg_init();
 
+#ifdef CONFIG_DMI
+	/* Intel Apple Macs never have an i8042 controller */
+	if (dmi_check_system(dmi_system_table) > 0)
+		return -ENODEV;
+#endif /*CONFIG_DMI*/
+
 	err = i8042_platform_init();
 	if (err)
 		return err;
diff -urN linux-4.4-01/drivers/media/pci/ivtv/ivtv-driver.c linux-4.4-02/drivers/media/pci/ivtv/ivtv-driver.c
--- linux-4.4-01/drivers/media/pci/ivtv/ivtv-driver.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/drivers/media/pci/ivtv/ivtv-driver.c	2016-09-16 10:21:59.408270735 +0100
@@ -826,7 +826,7 @@
 				IVTV_CARD_INPUT_VID_TUNER)
 			break;
 	}
-	if (i == itv->nof_inputs)
+	if (i >= itv->nof_inputs)
 		i = 0;
 	itv->active_input = i;
 	itv->audio_input = itv->card->video_inputs[i].audio_index;
diff -urN linux-4.4-01/drivers/mfd/Makefile linux-4.4-02/drivers/mfd/Makefile
--- linux-4.4-01/drivers/mfd/Makefile	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/drivers/mfd/Makefile	2016-09-16 10:21:59.040280764 +0100
@@ -61,7 +61,8 @@
 wm8350-objs			+= wm8350-irq.o
 obj-$(CONFIG_MFD_WM8350)	+= wm8350.o
 obj-$(CONFIG_MFD_WM8350_I2C)	+= wm8350-i2c.o
-obj-$(CONFIG_MFD_WM8994)	+= wm8994-core.o wm8994-irq.o wm8994-regmap.o
+wm8994-objs			:= wm8994-core.o wm8994-irq.o wm8994-regmap.o
+obj-$(CONFIG_MFD_WM8994)	+= wm8994.o
 
 obj-$(CONFIG_TPS6105X)		+= tps6105x.o
 obj-$(CONFIG_TPS65010)		+= tps65010.o
diff -urN linux-4.4-01/drivers/misc/lis3lv02d/lis3lv02d.c linux-4.4-02/drivers/misc/lis3lv02d/lis3lv02d.c
--- linux-4.4-01/drivers/misc/lis3lv02d/lis3lv02d.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/drivers/misc/lis3lv02d/lis3lv02d.c	2016-09-16 10:21:59.342272534 +0100
@@ -216,7 +216,8 @@
 /* conversion btw sampling rate and the register values */
 static int lis3_12_rates[4] = {40, 160, 640, 2560};
 static int lis3_8_rates[2] = {100, 400};
-static int lis3_3dc_rates[16] = {0, 1, 10, 25, 50, 100, 200, 400, 1600, 5000};
+/* LIS3DC: 0 = power off, above 9 = undefined */
+static int lis3_3dc_rates[16] = {0, 1, 10, 25, 50, 100, 200, 400, 1600, 5000, -1, -1, -1, -1, -1, -1};
 static int lis3_3dlh_rates[4] = {50, 100, 400, 1000};
 
 /* ODR is Output Data Rate */
@@ -231,12 +232,11 @@
 	return lis3->odrs[(ctrl >> shift)];
 }
 
-static int lis3lv02d_get_pwron_wait(struct lis3lv02d *lis3)
+static int lis3lv02d_wait_pwron(struct lis3lv02d *lis3)
 {
 	int div = lis3lv02d_get_odr(lis3);
-
-	if (WARN_ONCE(div == 0, "device returned spurious data"))
-		return -ENXIO;
+	if (div <= 0)
+		div = 1; /* maximum delay */
 
 	/* LIS3 power on delay is quite long */
 	msleep(lis3->pwron_delay / div);
@@ -303,7 +303,7 @@
 
 	lis3->read(lis3, ctlreg, &reg);
 	lis3->write(lis3, ctlreg, (reg | selftest));
-	ret = lis3lv02d_get_pwron_wait(lis3);
+	ret = lis3lv02d_wait_pwron(lis3);
 	if (ret)
 		goto fail;
 
@@ -314,7 +314,7 @@
 
 	/* back to normal settings */
 	lis3->write(lis3, ctlreg, reg);
-	ret = lis3lv02d_get_pwron_wait(lis3);
+	ret = lis3lv02d_wait_pwron(lis3);
 	if (ret)
 		goto fail;
 
@@ -434,7 +434,7 @@
 		}
 	}
 
-	err = lis3lv02d_get_pwron_wait(lis3);
+	err = lis3lv02d_wait_pwron(lis3);
 	if (err)
 		return err;
 
diff -urN linux-4.4-01/drivers/net/wireless/ath/ath9k/mac.c linux-4.4-02/drivers/net/wireless/ath/ath9k/mac.c
--- linux-4.4-01/drivers/net/wireless/ath/ath9k/mac.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/drivers/net/wireless/ath/ath9k/mac.c	2016-09-16 10:21:59.374271661 +0100
@@ -693,7 +693,7 @@
 {
 #define AH_RX_STOP_DMA_TIMEOUT 10000   /* usec */
 	struct ath_common *common = ath9k_hw_common(ah);
-	u32 mac_status, last_mac_status = 0;
+	u32 mac_status = 0, last_mac_status = 0;
 	int i;
 
 	/* Enable access to the DMA observation bus */
@@ -723,6 +723,16 @@
 	}
 
 	if (i == 0) {
+		if (!AR_SREV_9300_20_OR_LATER(ah) &&
+		    (mac_status & 0x700) == 0) {
+			/*
+			 * DMA is idle but the MAC is still stuck
+			 * processing events
+			 */
+			*reset = true;
+			return true;
+		}
+
 		ath_err(common,
 			"DMA failed to stop in %d ms AR_CR=0x%08x AR_DIAG_SW=0x%08x DMADBG_7=0x%08x\n",
 			AH_RX_STOP_DMA_TIMEOUT / 1000,
diff -urN linux-4.4-01/drivers/pci/pci-sysfs.c linux-4.4-02/drivers/pci/pci-sysfs.c
--- linux-4.4-01/drivers/pci/pci-sysfs.c	2016-09-16 10:21:30.839049239 +0100
+++ linux-4.4-02/drivers/pci/pci-sysfs.c	2016-09-16 10:21:59.174277111 +0100
@@ -30,6 +30,7 @@
 #include <linux/vgaarb.h>
 #include <linux/pm_runtime.h>
 #include <linux/of.h>
+#include <linux/module.h>
 #include "pci.h"
 
 static int sysfs_initialized;	/* = 0 */
@@ -713,6 +714,9 @@
 	loff_t init_off = off;
 	u8 *data = (u8 *) buf;
 
+	if (secure_modules())
+		return -EPERM;
+
 	if (off > dev->cfg_size)
 		return 0;
 	if (off + count > dev->cfg_size) {
@@ -1007,6 +1011,9 @@
 	resource_size_t start, end;
 	int i;
 
+	if (secure_modules())
+		return -EPERM;
+
 	for (i = 0; i < PCI_ROM_RESOURCE; i++)
 		if (res == &pdev->resource[i])
 			break;
@@ -1108,6 +1115,9 @@
 				     struct bin_attribute *attr, char *buf,
 				     loff_t off, size_t count)
 {
+	if (secure_modules())
+		return -EPERM;
+
 	return pci_resource_io(filp, kobj, attr, buf, off, count, true);
 }
 
diff -urN linux-4.4-01/drivers/pci/proc.c linux-4.4-02/drivers/pci/proc.c
--- linux-4.4-01/drivers/pci/proc.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/drivers/pci/proc.c	2016-09-16 10:21:59.174277111 +0100
@@ -116,6 +116,9 @@
 	int size = dev->cfg_size;
 	int cnt;
 
+	if (secure_modules())
+		return -EPERM;
+
 	if (pos >= size)
 		return 0;
 	if (nbytes >= size)
@@ -195,6 +198,9 @@
 #endif /* HAVE_PCI_MMAP */
 	int ret = 0;
 
+	if (secure_modules())
+		return -EPERM;
+
 	switch (cmd) {
 	case PCIIOC_CONTROLLER:
 		ret = pci_domain_nr(dev->bus);
@@ -233,7 +239,7 @@
 	struct pci_filp_private *fpriv = file->private_data;
 	int i, ret;
 
-	if (!capable(CAP_SYS_RAWIO))
+	if (!capable(CAP_SYS_RAWIO) || secure_modules())
 		return -EPERM;
 
 	/* Make sure the caller is mapping a real resource for this device */
diff -urN linux-4.4-01/drivers/pci/syscall.c linux-4.4-02/drivers/pci/syscall.c
--- linux-4.4-01/drivers/pci/syscall.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/drivers/pci/syscall.c	2016-09-16 10:21:59.174277111 +0100
@@ -10,6 +10,7 @@
 #include <linux/errno.h>
 #include <linux/pci.h>
 #include <linux/syscalls.h>
+#include <linux/module.h>
 #include <asm/uaccess.h>
 #include "pci.h"
 
@@ -92,7 +93,7 @@
 	u32 dword;
 	int err = 0;
 
-	if (!capable(CAP_SYS_ADMIN))
+	if (!capable(CAP_SYS_ADMIN) || secure_modules())
 		return -EPERM;
 
 	dev = pci_get_bus_and_slot(bus, dfn);
diff -urN linux-4.4-01/drivers/platform/x86/asus-wmi.c linux-4.4-02/drivers/platform/x86/asus-wmi.c
--- linux-4.4-01/drivers/platform/x86/asus-wmi.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/drivers/platform/x86/asus-wmi.c	2016-09-16 10:21:59.205276267 +0100
@@ -1870,6 +1870,9 @@
 	int err;
 	u32 retval = -1;
 
+	if (secure_modules())
+		return -EPERM;
+
 	err = asus_wmi_get_devstate(asus, asus->debug.dev_id, &retval);
 
 	if (err < 0)
@@ -1886,6 +1889,9 @@
 	int err;
 	u32 retval = -1;
 
+	if (secure_modules())
+		return -EPERM;
+
 	err = asus_wmi_set_devstate(asus->debug.dev_id, asus->debug.ctrl_param,
 				    &retval);
 
@@ -1910,6 +1916,9 @@
 	union acpi_object *obj;
 	acpi_status status;
 
+	if (secure_modules())
+		return -EPERM;
+
 	status = wmi_evaluate_method(ASUS_WMI_MGMT_GUID,
 				     1, asus->debug.method_id,
 				     &input, &output);
diff -urN linux-4.4-01/drivers/scsi/sd.c linux-4.4-02/drivers/scsi/sd.c
--- linux-4.4-01/drivers/scsi/sd.c	2016-09-16 10:21:30.963045860 +0100
+++ linux-4.4-02/drivers/scsi/sd.c	2016-09-16 10:21:59.363271961 +0100
@@ -2813,7 +2813,7 @@
 static int sd_revalidate_disk(struct gendisk *disk)
 {
 	struct scsi_disk *sdkp = scsi_disk(disk);
-	struct scsi_device *sdp = sdkp->device;
+	struct scsi_device *sdp;
 	struct request_queue *q = sdkp->disk->queue;
 	unsigned char *buffer;
 	unsigned int dev_max, rw_max;
@@ -2821,6 +2821,11 @@
 	SCSI_LOG_HLQUEUE(3, sd_printk(KERN_INFO, sdkp,
 				      "sd_revalidate_disk\n"));
 
+	if (WARN_ONCE((!sdkp), "Invalid scsi_disk from %p\n", disk))
+		goto out;
+
+	sdp = sdkp->device;
+
 	/*
 	 * If the device is offline, don't try and read capacity or any
 	 * of the other niceties.
diff -urN linux-4.4-01/drivers/tty/sysrq.c linux-4.4-02/drivers/tty/sysrq.c
--- linux-4.4-01/drivers/tty/sysrq.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/drivers/tty/sysrq.c	2016-09-16 10:21:59.304273569 +0100
@@ -472,6 +472,7 @@
 	/* x: May be registered on mips for TLB dump */
 	/* x: May be registered on ppc/powerpc for xmon */
 	/* x: May be registered on sparc64 for global PMU dump */
+	/* x: May be registered on x86_64 for disabling secure boot */
 	NULL,				/* x */
 	/* y: May be registered on sparc64 for global register dump */
 	NULL,				/* y */
@@ -515,7 +516,7 @@
                 sysrq_key_table[i] = op_p;
 }
 
-void __handle_sysrq(int key, bool check_mask)
+void __handle_sysrq(int key, int from)
 {
 	struct sysrq_key_op *op_p;
 	int orig_log_level;
@@ -535,11 +536,15 @@
 
         op_p = __sysrq_get_key_op(key);
         if (op_p) {
+		/* Ban synthetic events from some sysrq functionality */
+		if ((from == SYSRQ_FROM_PROC || from == SYSRQ_FROM_SYNTHETIC) &&
+		    op_p->enable_mask & SYSRQ_DISABLE_USERSPACE)
+			printk("This sysrq operation is disabled from userspace.\n");
 		/*
 		 * Should we check for enabled operations (/proc/sysrq-trigger
 		 * should not) and is the invoked operation enabled?
 		 */
-		if (!check_mask || sysrq_on_mask(op_p->enable_mask)) {
+		if (from == SYSRQ_FROM_KERNEL || sysrq_on_mask(op_p->enable_mask)) {
 			pr_cont("%s\n", op_p->action_msg);
 			console_loglevel = orig_log_level;
 			op_p->handler(key);
@@ -571,7 +576,7 @@
 void handle_sysrq(int key)
 {
 	if (sysrq_on())
-		__handle_sysrq(key, true);
+		__handle_sysrq(key, SYSRQ_FROM_KERNEL);
 }
 EXPORT_SYMBOL(handle_sysrq);
 
@@ -652,7 +657,7 @@
 static void sysrq_handle_reset_request(struct sysrq_state *state)
 {
 	if (state->reset_requested)
-		__handle_sysrq(sysrq_xlate[KEY_B], false);
+		__handle_sysrq(sysrq_xlate[KEY_B], SYSRQ_FROM_KERNEL);
 
 	if (sysrq_reset_downtime_ms)
 		mod_timer(&state->keyreset_timer,
@@ -803,8 +808,10 @@
 
 	default:
 		if (sysrq->active && value && value != 2) {
+			int from = sysrq->handle.dev->flags & INPUTDEV_FLAGS_SYNTHETIC ?
+					SYSRQ_FROM_SYNTHETIC : 0;
 			sysrq->need_reinject = false;
-			__handle_sysrq(sysrq_xlate[code], true);
+			__handle_sysrq(sysrq_xlate[code], from);
 		}
 		break;
 	}
@@ -1088,7 +1095,7 @@
 
 		if (get_user(c, buf))
 			return -EFAULT;
-		__handle_sysrq(c, false);
+		__handle_sysrq(c, SYSRQ_FROM_PROC);
 	}
 
 	return count;
diff -urN linux-4.4-01/drivers/usb/core/hub.c linux-4.4-02/drivers/usb/core/hub.c
--- linux-4.4-01/drivers/usb/core/hub.c	2016-09-16 10:21:31.020044307 +0100
+++ linux-4.4-02/drivers/usb/core/hub.c	2016-09-16 10:21:59.414270571 +0100
@@ -5056,6 +5056,13 @@
 			(u16) hub->change_bits[0],
 			(u16) hub->event_bits[0]);
 
+	/* Don't disconnect USB-SATA on TrimSlice */
+	if (strcmp(dev_name(hdev->bus->controller), "tegra-ehci.0") == 0) {
+		if ((hdev->state == 7) && (hub->change_bits[0] == 0) &&
+				(hub->event_bits[0] == 0x2))
+			hub->event_bits[0] = 0;
+	}
+
 	/* Lock the device, then check to see if we were
 	 * disconnected while waiting for the lock to succeed. */
 	usb_lock_device(hdev);
@@ -5489,8 +5496,10 @@
 	return 0;
 
 re_enumerate:
-	usb_release_bos_descriptor(udev);
-	udev->bos = bos;
+	if (udev->bos != bos) {
+		usb_release_bos_descriptor(udev);
+		udev->bos = bos;
+	}
 re_enumerate_no_bos:
 	/* LPM state doesn't matter when we're about to destroy the device. */
 	hub_port_logical_disconnect(parent_hub, port1);
diff -urN linux-4.4-01/drivers/video/console/fbcon.c linux-4.4-02/drivers/video/console/fbcon.c
--- linux-4.4-01/drivers/video/console/fbcon.c	2016-09-16 10:21:31.076042781 +0100
+++ linux-4.4-02/drivers/video/console/fbcon.c	2016-09-16 10:21:59.128278366 +0100
@@ -634,13 +634,15 @@
 		kfree(save);
 	}
 
-	if (logo_lines > vc->vc_bottom) {
-		logo_shown = FBCON_LOGO_CANSHOW;
-		printk(KERN_INFO
-		       "fbcon_init: disable boot-logo (boot-logo bigger than screen).\n");
-	} else if (logo_shown != FBCON_LOGO_DONTSHOW) {
-		logo_shown = FBCON_LOGO_DRAW;
-		vc->vc_top = logo_lines;
+	if (logo_shown != FBCON_LOGO_DONTSHOW) {
+		if (logo_lines > vc->vc_bottom) {
+			logo_shown = FBCON_LOGO_CANSHOW;
+			printk(KERN_INFO
+			       "fbcon_init: disable boot-logo (boot-logo bigger than screen).\n");
+		} else {
+			logo_shown = FBCON_LOGO_DRAW;
+			vc->vc_top = logo_lines;
+		}
 	}
 }
 #endif /* MODULE */
@@ -3625,6 +3627,14 @@
 	return 0;
 }
 
+static int __init quiet_logo(char *str)
+{
+	logo_shown = FBCON_LOGO_DONTSHOW;
+	return 0;
+}
+
+early_param("quiet", quiet_logo);
+
 fs_initcall(fb_console_init);
 
 #ifdef MODULE
diff -urN linux-4.4-01/drivers/xen/xen-pciback/pciback_ops.c linux-4.4-02/drivers/xen/xen-pciback/pciback_ops.c
--- linux-4.4-01/drivers/xen/xen-pciback/pciback_ops.c	2016-09-16 10:21:31.084042563 +0100
+++ linux-4.4-02/drivers/xen/xen-pciback/pciback_ops.c	2016-09-16 10:21:59.380271498 +0100
@@ -126,8 +126,6 @@
 		if (pci_is_enabled(dev))
 			pci_disable_device(dev);
 
-		pci_write_config_word(dev, PCI_COMMAND, 0);
-
 		dev->is_busmaster = 0;
 	} else {
 		pci_read_config_word(dev, PCI_COMMAND, &cmd);
diff -urN linux-4.4-01/include/asm-generic/crash-driver.h linux-4.4-02/include/asm-generic/crash-driver.h
--- linux-4.4-01/include/asm-generic/crash-driver.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.4-02/include/asm-generic/crash-driver.h	2016-09-16 10:21:59.157277575 +0100
@@ -0,0 +1,72 @@
+#ifndef __CRASH_H__
+#define __CRASH_H__
+
+/*
+ * include/linux/crash-driver.h
+ *
+ * Copyright (c) 2013 Red Hat, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifdef __KERNEL__
+
+#include <linux/mm.h>
+#include <linux/highmem.h>
+
+static inline void *
+map_virtual(u64 offset, struct page **pp)
+{
+	struct page *page;
+	unsigned long pfn;
+	void *vaddr;
+
+	pfn = (unsigned long)(offset >> PAGE_SHIFT);
+
+	if (!page_is_ram(pfn)) {
+		printk(KERN_INFO
+		    "crash memory driver: !page_is_ram(pfn: %lx)\n", pfn);
+		return NULL;
+	}
+
+	if (!pfn_valid(pfn)) {
+		printk(KERN_INFO
+		    "crash memory driver: invalid pfn: %lx )\n", pfn);
+		return NULL;
+	}
+
+	page = pfn_to_page(pfn);
+
+	vaddr = kmap(page);
+	if (!vaddr) {
+		printk(KERN_INFO
+		    "crash memory driver: pfn: %lx kmap(page: %lx) failed\n",
+			pfn, (unsigned long)page);
+		return NULL;
+	}
+
+	*pp = page;
+	return (vaddr + (offset & (PAGE_SIZE-1)));
+}
+
+static inline void unmap_virtual(struct page *page)
+{
+	kunmap(page);
+}
+
+#endif /* __KERNEL__ */
+
+#endif /* __CRASH_H__ */
diff -urN linux-4.4-01/include/keys/system_keyring.h linux-4.4-02/include/keys/system_keyring.h
--- linux-4.4-01/include/keys/system_keyring.h	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/include/keys/system_keyring.h	2016-09-16 10:21:59.286274059 +0100
@@ -35,4 +35,8 @@
 			      enum key_being_used_for usage);
 #endif
 
+#ifdef CONFIG_SYSTEM_BLACKLIST_KEYRING
+extern struct key *system_blacklist_keyring;
+#endif
+
 #endif /* _KEYS_SYSTEM_KEYRING_H */
diff -urN linux-4.4-01/include/linux/efi.h linux-4.4-02/include/linux/efi.h
--- linux-4.4-01/include/linux/efi.h	2016-09-16 10:21:31.245038176 +0100
+++ linux-4.4-02/include/linux/efi.h	2016-09-16 10:21:59.292273896 +0100
@@ -599,11 +599,23 @@
 #define EFI_PROPERTIES_TABLE_GUID \
     EFI_GUID(  0x880aaca3, 0x4adc, 0x4a04, 0x90, 0x79, 0xb7, 0x47, 0x34, 0x08, 0x25, 0xe5 )
 
+#define EFI_CERT_SHA256_GUID \
+    EFI_GUID(  0xc1c41626, 0x504c, 0x4092, 0xac, 0xa9, 0x41, 0xf9, 0x36, 0x93, 0x43, 0x28 )
+
+#define EFI_CERT_X509_GUID \
+    EFI_GUID(  0xa5c059a1, 0x94e4, 0x4aa7, 0x87, 0xb5, 0xab, 0x15, 0x5c, 0x2b, 0xf0, 0x72 )
+
 typedef struct {
 	efi_guid_t guid;
 	u64 table;
 } efi_config_table_64_t;
 
+#define EFI_IMAGE_SECURITY_DATABASE_GUID \
+    EFI_GUID(  0xd719b2cb, 0x3d3a, 0x4596, 0xa3, 0xbc, 0xda, 0xd0, 0x0e, 0x67, 0x65, 0x6f )
+
+#define EFI_SHIM_LOCK_GUID \
+    EFI_GUID(  0x605dab50, 0xe046, 0x4300, 0xab, 0xb6, 0x3d, 0xd8, 0x10, 0xdd, 0x8b, 0x23 )
+
 typedef struct {
 	efi_guid_t guid;
 	u32 table;
@@ -823,6 +835,20 @@
 
 #define EFI_INVALID_TABLE_ADDR		(~0UL)
 
+typedef struct  {
+	efi_guid_t signature_owner;
+	u8 signature_data[];
+} efi_signature_data_t;
+
+typedef struct {
+	efi_guid_t signature_type;
+	u32 signature_list_size;
+	u32 signature_header_size;
+	u32 signature_size;
+	u8 signature_header[];
+	/* efi_signature_data_t signatures[][] */
+} efi_signature_list_t;
+
 /*
  * All runtime access to EFI goes through this structure:
  */
@@ -941,6 +967,10 @@
 char * __init efi_md_typeattr_format(char *buf, size_t size,
 				     const efi_memory_desc_t *md);
 
+struct key;
+extern int __init parse_efi_signature_list(const void *data, size_t size,
+					   struct key *keyring);
+
 /**
  * efi_range_is_wc - check the WC bit on an address range
  * @start: starting kvirt address
@@ -980,6 +1010,7 @@
 #define EFI_ARCH_1		7	/* First arch-specific bit */
 #define EFI_DBG			8	/* Print additional debug info at runtime */
 #define EFI_NX_PE_DATA		9	/* Can runtime data regions be mapped non-executable? */
+#define EFI_SECURE_BOOT		10	/* Are we in Secure Boot mode? */
 
 #ifdef CONFIG_EFI
 /*
diff -urN linux-4.4-01/include/linux/input.h linux-4.4-02/include/linux/input.h
--- linux-4.4-01/include/linux/input.h	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/include/linux/input.h	2016-09-16 10:21:59.304273569 +0100
@@ -42,6 +42,7 @@
  * @phys: physical path to the device in the system hierarchy
  * @uniq: unique identification code for the device (if device has it)
  * @id: id of the device (struct input_id)
+ * @flags: input device flags (SYNTHETIC, etc.)
  * @propbit: bitmap of device properties and quirks
  * @evbit: bitmap of types of events supported by the device (EV_KEY,
  *	EV_REL, etc.)
@@ -124,6 +125,8 @@
 	const char *uniq;
 	struct input_id id;
 
+	unsigned int flags;
+
 	unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];
 
 	unsigned long evbit[BITS_TO_LONGS(EV_CNT)];
@@ -190,6 +193,8 @@
 };
 #define to_input_dev(d) container_of(d, struct input_dev, dev)
 
+#define	INPUTDEV_FLAGS_SYNTHETIC	0x000000001
+
 /*
  * Verify that we are in sync with input_device_id mod_devicetable.h #defines
  */
diff -urN linux-4.4-01/include/linux/module.h linux-4.4-02/include/linux/module.h
--- linux-4.4-01/include/linux/module.h	2016-09-16 10:21:31.248038095 +0100
+++ linux-4.4-02/include/linux/module.h	2016-09-16 10:21:59.238275367 +0100
@@ -273,6 +273,12 @@
 
 struct notifier_block;
 
+#ifdef CONFIG_MODULE_SIG
+extern void enforce_signed_modules(void);
+#else
+static inline void enforce_signed_modules(void) {};
+#endif
+
 #ifdef CONFIG_MODULES
 
 extern int modules_disabled; /* for sysctl */
@@ -636,6 +642,8 @@
 	return module && module->async_probe_requested;
 }
 
+extern bool secure_modules(void);
+
 #else /* !CONFIG_MODULES... */
 
 /* Given an address, look for it in the exception tables. */
@@ -752,6 +760,10 @@
 	return false;
 }
 
+static inline bool secure_modules(void)
+{
+	return false;
+}
 #endif /* CONFIG_MODULES */
 
 #ifdef CONFIG_SYSFS
diff -urN linux-4.4-01/include/linux/sysrq.h linux-4.4-02/include/linux/sysrq.h
--- linux-4.4-01/include/linux/sysrq.h	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/include/linux/sysrq.h	2016-09-16 10:21:59.304273569 +0100
@@ -28,6 +28,8 @@
 #define SYSRQ_ENABLE_BOOT	0x0080
 #define SYSRQ_ENABLE_RTNICE	0x0100
 
+#define SYSRQ_DISABLE_USERSPACE	0x00010000
+
 struct sysrq_key_op {
 	void (*handler)(int);
 	char *help_msg;
@@ -42,8 +44,12 @@
  * are available -- else NULL's).
  */
 
+#define SYSRQ_FROM_KERNEL	0x0001
+#define SYSRQ_FROM_PROC		0x0002
+#define SYSRQ_FROM_SYNTHETIC	0x0004
+
 void handle_sysrq(int key);
-void __handle_sysrq(int key, bool check_mask);
+void __handle_sysrq(int key, int from);
 int register_sysrq_key(int key, struct sysrq_key_op *op);
 int unregister_sysrq_key(int key, struct sysrq_key_op *op);
 struct sysrq_key_op *__sysrq_get_key_op(int key);
diff -urN linux-4.4-01/init/Kconfig linux-4.4-02/init/Kconfig
--- linux-4.4-01/init/Kconfig	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/init/Kconfig	2016-09-16 10:21:59.369271798 +0100
@@ -1154,7 +1154,7 @@
 endif # CGROUPS
 
 config CHECKPOINT_RESTORE
-	bool "Checkpoint/restore support" if EXPERT
+	bool "Checkpoint/restore support"
 	select PROC_CHILDREN
 	default n
 	help
@@ -1166,7 +1166,7 @@
 	  If unsure, say N here.
 
 menuconfig NAMESPACES
-	bool "Namespaces support" if EXPERT
+	bool "Namespaces support"
 	depends on MULTIUSER
 	default !EXPERT
 	help
@@ -1795,6 +1795,15 @@
 	  module verification, kexec image verification and firmware blob
 	  verification.
 
+config SYSTEM_BLACKLIST_KEYRING
+	bool "Provide system-wide ring of blacklisted keys"
+	depends on KEYS
+	help
+	  Provide a system keyring to which blacklisted keys can be added.
+	  Keys in the keyring are considered entirely untrusted.  Keys in this
+	  keyring are used by the module signature checking to reject loading
+	  of modules signed with a blacklisted key.
+
 config PROFILING
 	bool "Profiling support"
 	help
@@ -1936,6 +1945,15 @@
 comment "Do not forget to sign required modules with scripts/sign-file"
 	depends on MODULE_SIG_FORCE && !MODULE_SIG_ALL
 
+config MODULE_SIG_UEFI
+	bool "Allow modules signed with certs stored in UEFI"
+	depends on MODULE_SIG && SYSTEM_BLACKLIST_KEYRING && EFI
+	select EFI_SIGNATURE_LIST_PARSER
+	help
+	  This will import certificates stored in UEFI and allow modules
+	  signed with those to be loaded.  It will also disallow loading
+	  of modules stored in the UEFI dbx variable.
+
 choice
 	prompt "Which hash algorithm should modules be signed with?"
 	depends on MODULE_SIG
diff -urN linux-4.4-01/kernel/debug/kdb/kdb_main.c linux-4.4-02/kernel/debug/kdb/kdb_main.c
--- linux-4.4-01/kernel/debug/kdb/kdb_main.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/kernel/debug/kdb/kdb_main.c	2016-09-16 10:21:59.304273569 +0100
@@ -1968,7 +1968,7 @@
 		return KDB_ARGCOUNT;
 
 	kdb_trap_printk++;
-	__handle_sysrq(*argv[1], check_mask);
+	__handle_sysrq(*argv[1], check_mask & SYSRQ_FROM_KERNEL);
 	kdb_trap_printk--;
 
 	return 0;
diff -urN linux-4.4-01/kernel/kexec.c linux-4.4-02/kernel/kexec.c
--- linux-4.4-01/kernel/kexec.c	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/kernel/kexec.c	2016-09-16 10:21:59.225275721 +0100
@@ -12,6 +12,7 @@
 #include <linux/mm.h>
 #include <linux/file.h>
 #include <linux/kexec.h>
+#include <linux/module.h>
 #include <linux/mutex.h>
 #include <linux/list.h>
 #include <linux/syscalls.h>
@@ -135,6 +136,13 @@
 		return -EPERM;
 
 	/*
+	 * kexec can be used to circumvent module loading restrictions, so
+	 * prevent loading in that case
+	 */
+	if (secure_modules())
+		return -EPERM;
+
+	/*
 	 * Verify we have a legal set of flags
 	 * This leaves us room for future extensions.
 	 */
diff -urN linux-4.4-01/kernel/Makefile linux-4.4-02/kernel/Makefile
--- linux-4.4-01/kernel/Makefile	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/kernel/Makefile	2016-09-16 10:21:59.292273896 +0100
@@ -47,6 +47,7 @@
 obj-$(CONFIG_UID16) += uid16.o
 obj-$(CONFIG_MODULES) += module.o
 obj-$(CONFIG_MODULE_SIG) += module_signing.o
+obj-$(CONFIG_MODULE_SIG_UEFI) += modsign_uefi.o
 obj-$(CONFIG_KALLSYMS) += kallsyms.o
 obj-$(CONFIG_BSD_PROCESS_ACCT) += acct.o
 obj-$(CONFIG_KEXEC_CORE) += kexec_core.o
@@ -104,6 +105,8 @@
 
 obj-$(CONFIG_HAS_IOMEM) += memremap.o
 
+$(obj)/modsign_uefi.o: KBUILD_CFLAGS += -fshort-wchar
+
 $(obj)/configs.o: $(obj)/config_data.h
 
 # config_data.h contains the same information as ikconfig.h but gzipped.
diff -urN linux-4.4-01/kernel/modsign_uefi.c linux-4.4-02/kernel/modsign_uefi.c
--- linux-4.4-01/kernel/modsign_uefi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.4-02/kernel/modsign_uefi.c	2016-09-16 10:21:59.298273732 +0100
@@ -0,0 +1,114 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/cred.h>
+#include <linux/err.h>
+#include <linux/efi.h>
+#include <linux/slab.h>
+#include <keys/asymmetric-type.h>
+#include <keys/system_keyring.h>
+#include "module-internal.h"
+
+static __init int check_ignore_db(void)
+{
+	efi_status_t status;
+	unsigned int db = 0;
+	unsigned long size = sizeof(db);
+	efi_guid_t guid = EFI_SHIM_LOCK_GUID;
+
+	/* Check and see if the MokIgnoreDB variable exists.  If that fails
+	 * then we don't ignore DB.  If it succeeds, we do.
+	 */
+	status = efi.get_variable(L"MokIgnoreDB", &guid, NULL, &size, &db);
+	if (status != EFI_SUCCESS)
+		return 0;
+
+	return 1;
+}
+
+static __init void *get_cert_list(efi_char16_t *name, efi_guid_t *guid, unsigned long *size)
+{
+	efi_status_t status;
+	unsigned long lsize = 4;
+	unsigned long tmpdb[4];
+	void *db = NULL;
+
+	status = efi.get_variable(name, guid, NULL, &lsize, &tmpdb);
+	if (status != EFI_BUFFER_TOO_SMALL) {
+		pr_err("Couldn't get size: 0x%lx\n", status);
+		return NULL;
+	}
+
+	db = kmalloc(lsize, GFP_KERNEL);
+	if (!db) {
+		pr_err("Couldn't allocate memory for uefi cert list\n");
+		goto out;
+	}
+
+	status = efi.get_variable(name, guid, NULL, &lsize, db);
+	if (status != EFI_SUCCESS) {
+		kfree(db);
+		db = NULL;
+		pr_err("Error reading db var: 0x%lx\n", status);
+	}
+out:
+	*size = lsize;
+	return db;
+}
+
+/*
+ *  * Load the certs contained in the UEFI databases
+ *   */
+static int __init load_uefi_certs(void)
+{
+	efi_guid_t secure_var = EFI_IMAGE_SECURITY_DATABASE_GUID;
+	efi_guid_t mok_var = EFI_SHIM_LOCK_GUID;
+	void *db = NULL, *dbx = NULL, *mok = NULL;
+	unsigned long dbsize = 0, dbxsize = 0, moksize = 0;
+	int ignore_db, rc = 0;
+
+	/* Check if SB is enabled and just return if not */
+	if (!efi_enabled(EFI_SECURE_BOOT))
+		return 0;
+
+	/* See if the user has setup Ignore DB mode */
+	ignore_db = check_ignore_db();
+
+	/* Get db, MokListRT, and dbx.  They might not exist, so it isn't
+	 * an error if we can't get them.
+	 */
+	if (!ignore_db) {
+		db = get_cert_list(L"db", &secure_var, &dbsize);
+		if (!db) {
+			pr_err("MODSIGN: Couldn't get UEFI db list\n");
+		} else {
+			rc = parse_efi_signature_list(db, dbsize, system_trusted_keyring);
+			if (rc)
+				pr_err("Couldn't parse db signatures: %d\n", rc);
+			kfree(db);
+		}
+	}
+
+	mok = get_cert_list(L"MokListRT", &mok_var, &moksize);
+	if (!mok) {
+		pr_info("MODSIGN: Couldn't get UEFI MokListRT\n");
+	} else {
+		rc = parse_efi_signature_list(mok, moksize, system_trusted_keyring);
+		if (rc)
+			pr_err("Couldn't parse MokListRT signatures: %d\n", rc);
+		kfree(mok);
+	}
+
+	dbx = get_cert_list(L"dbx", &secure_var, &dbxsize);
+	if (!dbx) {
+		pr_info("MODSIGN: Couldn't get UEFI dbx list\n");
+	} else {
+		rc = parse_efi_signature_list(dbx, dbxsize,
+			system_blacklist_keyring);
+		if (rc)
+			pr_err("Couldn't parse dbx signatures: %d\n", rc);
+		kfree(dbx);
+	}
+
+	return rc;
+}
+late_initcall(load_uefi_certs);
diff -urN linux-4.4-01/kernel/module.c linux-4.4-02/kernel/module.c
--- linux-4.4-01/kernel/module.c	2016-09-16 10:21:31.301036650 +0100
+++ linux-4.4-02/kernel/module.c	2016-09-16 10:21:59.305273541 +0100
@@ -292,7 +292,7 @@
 #endif
 }
 
-static bool sig_enforce = IS_ENABLED(CONFIG_MODULE_SIG_FORCE);
+bool sig_enforce = IS_ENABLED(CONFIG_MODULE_SIG_FORCE);
 #ifndef CONFIG_MODULE_SIG_FORCE
 module_param(sig_enforce, bool_enable_only, 0644);
 #endif /* !CONFIG_MODULE_SIG_FORCE */
@@ -4132,3 +4132,20 @@
 }
 EXPORT_SYMBOL(module_layout);
 #endif
+
+#ifdef CONFIG_MODULE_SIG
+void enforce_signed_modules(void)
+{
+	sig_enforce = true;
+}
+#endif
+
+bool secure_modules(void)
+{
+#ifdef CONFIG_MODULE_SIG
+	return (sig_enforce || modules_disabled);
+#else
+	return modules_disabled;
+#endif
+}
+EXPORT_SYMBOL(secure_modules);
diff -urN linux-4.4-01/kernel/power/hibernate.c linux-4.4-02/kernel/power/hibernate.c
--- linux-4.4-01/kernel/power/hibernate.c	2016-09-16 10:21:31.301036650 +0100
+++ linux-4.4-02/kernel/power/hibernate.c	2016-09-16 10:21:59.262274713 +0100
@@ -29,6 +29,7 @@
 #include <linux/ctype.h>
 #include <linux/genhd.h>
 #include <linux/ktime.h>
+#include <linux/module.h>
 #include <trace/events/power.h>
 
 #include "power.h"
@@ -66,7 +67,7 @@
 
 bool hibernation_available(void)
 {
-	return (nohibernate == 0);
+	return ((nohibernate == 0) && !secure_modules());
 }
 
 /**
diff -urN linux-4.4-01/kernel/watchdog.c linux-4.4-02/kernel/watchdog.c
--- linux-4.4-01/kernel/watchdog.c	2016-09-16 10:21:31.324036024 +0100
+++ linux-4.4-02/kernel/watchdog.c	2016-09-16 10:21:59.348272370 +0100
@@ -20,6 +20,7 @@
 #include <linux/smpboot.h>
 #include <linux/sched/rt.h>
 #include <linux/tick.h>
+#include <linux/dmi.h>
 
 #include <asm/irq_regs.h>
 #include <linux/kvm_para.h>
@@ -185,6 +186,32 @@
 __setup("hardlockup_all_cpu_backtrace=", hardlockup_all_cpu_backtrace_setup);
 #endif
 
+static int disable_watchdog(const struct dmi_system_id *d)
+{
+	printk(KERN_INFO "watchdog: disabled (inside virtual machine)\n");
+	watchdog_user_enabled = 0;
+	return 0;
+}
+
+static const struct dmi_system_id watchdog_virt_dmi_table[] = {
+	{
+		.callback = disable_watchdog,
+		.ident = "VMware",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "VMware, Inc."),
+		},
+	},
+	{
+		.callback = disable_watchdog,
+		.ident = "Bochs",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Bochs"),
+		},
+	},
+	{}
+};
+
+
 /*
  * Hard-lockup warnings should be triggered after just a few seconds. Soft-
  * lockups can have false positives under extreme conditions. So we generally
@@ -1037,6 +1064,8 @@
 
 void __init lockup_detector_init(void)
 {
+	dmi_check_system(watchdog_virt_dmi_table);
+
 	set_sample_period();
 
 #ifdef CONFIG_NO_HZ_FULL
diff -urN linux-4.4-01/lib/Kconfig linux-4.4-02/lib/Kconfig
--- linux-4.4-01/lib/Kconfig	2016-09-16 10:21:31.335035724 +0100
+++ linux-4.4-02/lib/Kconfig	2016-09-16 10:21:58.976282512 +0100
@@ -396,7 +396,8 @@
 	bool
 
 config CPUMASK_OFFSTACK
-	bool "Force CPU masks off stack" if DEBUG_PER_CPU_MAPS
+	bool "Force CPU masks off stack"
+	depends on SMP
 	help
 	  Use dynamic allocation for cpumask_var_t, instead of putting
 	  them on the stack.  This is a bit more expensive, but avoids
diff -urN linux-4.4-01/lib/Kconfig.debug linux-4.4-02/lib/Kconfig.debug
--- linux-4.4-01/lib/Kconfig.debug	2016-01-10 23:01:32.000000000 +0000
+++ linux-4.4-02/lib/Kconfig.debug	2016-09-16 10:21:59.149277793 +0100
@@ -165,7 +165,23 @@
 	  Generate dwarf4 debug info. This requires recent versions
 	  of gcc and gdb. It makes the debug information larger.
 	  But it significantly improves the success of resolving
-	  variables in gdb on optimized code.
+	  variables in gdb on optimized code.  The gcc docs also
+	  recommend enabling -fvar-tracking-assignments for maximum
+	  benefit. (see DEBUG_INFO_VTA)
+
+config DEBUG_INFO_VTA
+	bool "Enable var-tracking-assignments for debuginfo"
+	depends on DEBUG_INFO
+	help
+	  Enable gcc -fvar-tracking-assignments for improved debug
+	  information on variable locations in optimized code.  Per
+	  gcc, DEBUG_INFO_DWARF4 is recommended for best use of VTA.
+
+	  VTA has been implicated in codegen bugs (gcc PR61801,
+	  PR61904), so this may deserve some caution.  One can set
+	  GCC_COMPARE_DEBUG=-fvar-tracking-assignments-toggle in the
+	  environment to automatically compile everything both ways,
+	  generating an error if anything differs.
 
 config GDB_SCRIPTS
 	bool "Provide GDB scripts for kernel debugging"
diff -urN linux-4.4-01/Makefile linux-4.4-02/Makefile
--- linux-4.4-01/Makefile	2016-09-16 10:21:30.522057877 +0100
+++ linux-4.4-02/Makefile	2016-09-16 10:21:59.144277929 +0100
@@ -701,7 +701,11 @@
 endif
 endif
 
+ifdef CONFIG_DEBUG_INFO_VTA
+KBUILD_CFLAGS   += $(call cc-option, -fvar-tracking-assignments)
+else
 KBUILD_CFLAGS   += $(call cc-option, -fno-var-tracking-assignments)
+endif
 
 ifdef CONFIG_DEBUG_INFO
 ifdef CONFIG_DEBUG_INFO_SPLIT
diff -urN linux-4.4-01/net/ipv4/netfilter/arp_tables.c linux-4.4-02/net/ipv4/netfilter/arp_tables.c
--- linux-4.4-01/net/ipv4/netfilter/arp_tables.c	2016-09-16 10:21:31.401033926 +0100
+++ linux-4.4-02/net/ipv4/netfilter/arp_tables.c	2016-09-16 10:21:59.453269508 +0100
@@ -449,6 +449,10 @@
 
 				/* Move along one */
 				size = e->next_offset;
+
+				if (pos + size > newinfo->size - sizeof(*e))
+					return 0;
+
 				e = (struct arpt_entry *)
 					(entry0 + pos + size);
 				if (pos + size >= newinfo->size)
@@ -461,14 +465,6 @@
 				if (strcmp(t->target.u.user.name,
 					   XT_STANDARD_TARGET) == 0 &&
 				    newpos >= 0) {
-					if (newpos > newinfo->size -
-						sizeof(struct arpt_entry)) {
-						duprintf("mark_source_chains: "
-							"bad verdict (%i)\n",
-								newpos);
-						return 0;
-					}
-
 					/* This a jump; chase it. */
 					duprintf("Jump rule %u -> %u\n",
 						 pos, newpos);
@@ -482,6 +478,10 @@
 					if (newpos >= newinfo->size)
 						return 0;
 				}
+
+				if (newpos > newinfo->size - sizeof(*e))
+					return 0;
+
 				e = (struct arpt_entry *)
 					(entry0 + newpos);
 				e->counters.pcnt = pos;
diff -urN linux-4.4-01/net/ipv4/netfilter/ip_tables.c linux-4.4-02/net/ipv4/netfilter/ip_tables.c
--- linux-4.4-01/net/ipv4/netfilter/ip_tables.c	2016-09-16 10:21:31.402033898 +0100
+++ linux-4.4-02/net/ipv4/netfilter/ip_tables.c	2016-09-16 10:21:59.453269508 +0100
@@ -530,6 +530,10 @@
 
 				/* Move along one */
 				size = e->next_offset;
+
+				if (pos + size > newinfo->size - sizeof(*e))
+					return 0;
+
 				e = (struct ipt_entry *)
 					(entry0 + pos + size);
 				if (pos + size >= newinfo->size)
@@ -542,13 +546,6 @@
 				if (strcmp(t->target.u.user.name,
 					   XT_STANDARD_TARGET) == 0 &&
 				    newpos >= 0) {
-					if (newpos > newinfo->size -
-						sizeof(struct ipt_entry)) {
-						duprintf("mark_source_chains: "
-							"bad verdict (%i)\n",
-								newpos);
-						return 0;
-					}
 					/* This a jump; chase it. */
 					duprintf("Jump rule %u -> %u\n",
 						 pos, newpos);
@@ -562,6 +559,10 @@
 					if (newpos >= newinfo->size)
 						return 0;
 				}
+
+				if (newpos > newinfo->size - sizeof(*e))
+					return 0;
+
 				e = (struct ipt_entry *)
 					(entry0 + newpos);
 				e->counters.pcnt = pos;
diff -urN linux-4.4-01/net/ipv6/netfilter/ip6_tables.c linux-4.4-02/net/ipv6/netfilter/ip6_tables.c
--- linux-4.4-01/net/ipv6/netfilter/ip6_tables.c	2016-09-16 10:21:31.433033054 +0100
+++ linux-4.4-02/net/ipv6/netfilter/ip6_tables.c	2016-09-16 10:21:59.461269291 +0100
@@ -542,6 +542,8 @@
 
 				/* Move along one */
 				size = e->next_offset;
+				if (pos + size > newinfo->size - sizeof(*e))
+					return 0;
 				e = (struct ip6t_entry *)
 					(entry0 + pos + size);
 				if (pos + size >= newinfo->size)
@@ -554,13 +556,6 @@
 				if (strcmp(t->target.u.user.name,
 					   XT_STANDARD_TARGET) == 0 &&
 				    newpos >= 0) {
-					if (newpos > newinfo->size -
-						sizeof(struct ip6t_entry)) {
-						duprintf("mark_source_chains: "
-							"bad verdict (%i)\n",
-								newpos);
-						return 0;
-					}
 					/* This a jump; chase it. */
 					duprintf("Jump rule %u -> %u\n",
 						 pos, newpos);
@@ -574,6 +569,10 @@
 					if (newpos >= newinfo->size)
 						return 0;
 				}
+
+				if (newpos > newinfo->size - sizeof(*e))
+					return 0;
+
 				e = (struct ip6t_entry *)
 					(entry0 + newpos);
 				e->counters.pcnt = pos;
diff -urN linux-4.4-01/net/netfilter/x_tables.c linux-4.4-02/net/netfilter/x_tables.c
--- linux-4.4-01/net/netfilter/x_tables.c	2016-09-16 10:21:31.455032454 +0100
+++ linux-4.4-02/net/netfilter/x_tables.c	2016-09-16 10:21:59.435269999 +0100
@@ -903,6 +903,9 @@
 	if (sz < sizeof(*info))
 		return NULL;
 
+	if (sz < sizeof(*info))
+		return NULL;
+
 	/* Pedantry: prevent them from hitting BUG() in vmalloc.c --RR */
 	if ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages)
 		return NULL;
diff -urN linux-4.4-01/scripts/link-vmlinux.sh linux-4.4-02/scripts/link-vmlinux.sh
--- linux-4.4-01/scripts/link-vmlinux.sh	2016-09-16 10:21:31.503031146 +0100
+++ linux-4.4-02/scripts/link-vmlinux.sh	2016-09-16 10:21:58.814286921 +0100
@@ -65,6 +65,10 @@
 			-lutil -lrt -lpthread ${1}
 		rm -f linux
 	fi
+	if [ -n "${AFTER_LINK}" ]; then
+		/usr/lib/rpm/debugedit -b ${RPM_BUILD_DIR} -d /usr/src/debug -i ${2} \
+			> ${2}.id
+	fi
 }
 
 
